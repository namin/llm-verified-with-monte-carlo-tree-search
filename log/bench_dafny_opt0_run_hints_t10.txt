

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_opt0 --seed 42 


[2024-01-13 10:55:52,070] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)

SCORE
1.0
['  | Constant(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

SCORE
1.0
['  | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string => int): int 

  |
6 | function method Eval(e: Expr, env: string => int): int
  |                                           ^

ex.dfy(6,42): Error: closeparen expected
  |
6 | function method Eval(e: Expr, env: string => int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string => int): int \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string => int): int 
{

  |
6 | function method Eval(e: Expr, env: string => int): int 
  |                                           ^

ex.dfy(6,42): Error: closeparen expected
  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
6 | function method Eval(e: Expr, env: string => int): int 
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string => int): int 
{
  match e

  |
6 | function method Eval(e: Expr, env: string => int): int 
  |                                           ^

ex.dfy(6,42): Error: closeparen expected
  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string => int): int 
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val

  |
9 |   case Constant(val) => val
  |                            ^

ex.dfy(9,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Constant(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)

   |
11 |   case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
   |                                                                      ^

ex.dfy(11,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right

   |
17 |   case Add(Constant(0), right) => right
   |                                        ^

ex.dfy(17,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Constant(0), right) => right\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left

   |
18 |   case Add(left, Constant(0)) => left
   |                                      ^

ex.dfy(18,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, Constant(0)) => left\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))

   |
19 |   case Add(left, right) => Add(Optimize(left), Optimize(right))
   |                                                                ^

ex.dfy(19,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Add(Optimize(left), Optimize(right))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
26 |   match e
   |          ^

ex.dfy(26,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 

   |
27 |   case Constant(_) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Constant(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 

   |
28 |   case Var(_) =>
   |                 ^

ex.dfy(28,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 

   |
29 |   case Add(left, right) =>
   |                           ^

ex.dfy(29,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 
    OptimizerPreservesSemantics(left, env);

   |
30 |     OptimizerPreservesSemantics(left, env);
   |                                            ^

ex.dfy(30,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);

   |
31 |     OptimizerPreservesSemantics(right, env);
   |                                             ^

ex.dfy(31,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Constant(0), right) => right
  case Add(left, Constant(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) => 
  case Var(_) => 
  case Add(left, right) => 
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 15 (including failed: 1)

cache stats {'hit': 0, 'miss': 36}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87]

Trial calls: [36]


Time Statistics:

  Min: 87.00 sec, Max: 87.00 sec, Average: 87.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 36 calls, Max: 36 calls, Average: 36.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87]

Trial calls: [36]


Time Statistics:

  Min: 87.00 sec, Max: 87.00 sec, Average: 87.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 36 calls, Max: 36 calls, Average: 36.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['              | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)

   |
10 |     case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
   |                                                                  ^

ex.dfy(10,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |     case Add(lhs, Const(0)) => Optimize(lhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, Const(0)) => Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)

   |
17 |     case Add(Const(0), rhs) => Optimize(rhs)
   |                                             ^

ex.dfy(17,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))

   |
18 |     case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
   |                                                            ^

ex.dfy(18,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e

   |
25 |     match e
   |            ^

ex.dfy(25,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 

   |
26 |     case Const(_) =>
   |                     ^

ex.dfy(26,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 

   |
27 |     case Var(_) =>
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>

   |
28 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);

   |
29 |         OptimizePreservesEvaluation(lhs, env);
   |                                               ^

ex.dfy(29,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEvaluation(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env)

   |
30 |         OptimizePreservesEvaluation(rhs, env)
   |                                              ^

ex.dfy(30,45): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEvaluation(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env)
    case _ => 

   |
30 |         OptimizePreservesEvaluation(rhs, env)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(30,8): Error: missing semicolon at end of statement
   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env)
    case _ => 
}

   |
30 |         OptimizePreservesEvaluation(rhs, env)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(30,8): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['    match e\n']
['    case Const(_) => \n']
['    case Var(_) => \n']
['    case Add(lhs, rhs) =>\n']
['        OptimizePreservesEvaluation(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env);

   |
30 |         OptimizePreservesEvaluation(rhs, env);
   |                                               ^

ex.dfy(30,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEvaluation(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env);
    case _ => 

   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env);
    case _ => 
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env);
    case _ => 
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
    ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    match e
    case Const(_) => 
    case Var(_) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEvaluation(lhs, env);
        OptimizePreservesEvaluation(rhs, env);
    case _ => 
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 15 (including failed: 1)

cache stats {'hit': 6, 'miss': 36}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94]

Trial calls: [36, 42]


Time Statistics:

  Min: 87.00 sec, Max: 94.00 sec, Average: 90.50 sec, Standard Deviation: 3.50 sec

Call Statistics:

  Min: 36 calls, Max: 42 calls, Average: 39.00 calls, Standard Deviation: 3.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94]

Trial calls: [36, 42]


Time Statistics:

  Min: 87.00 sec, Max: 94.00 sec, Average: 90.50 sec, Standard Deviation: 3.50 sec

Call Statistics:

  Min: 36 calls, Max: 42 calls, Average: 39.00 calls, Standard Deviation: 3.00 calls

Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr = Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)

SCORE
1.0
['             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n

  |
8 |   case Const(n) => n
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
10 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(10,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
16 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
17 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
18 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>

   |
26 |   case Const(_) =>
   |                   ^

ex.dfy(26,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>

   |
27 |   case Var(_) =>
   |                 ^

ex.dfy(27,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>

   |
28 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
29 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
30 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(30,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);

   |
31 |     OptimizePreservesSemantics(e1, env);
   |                                         ^

ex.dfy(31,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);

   |
32 |     OptimizePreservesSemantics(e2, env);
   |                                         ^

ex.dfy(32,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 14 (including failed: 0)

cache stats {'hit': 0, 'miss': 34}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86]

Trial calls: [36, 42, 34]


Time Statistics:

  Min: 86.00 sec, Max: 94.00 sec, Average: 89.00 sec, Standard Deviation: 3.56 sec

Call Statistics:

  Min: 34 calls, Max: 42 calls, Average: 37.33 calls, Standard Deviation: 3.40 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86]

Trial calls: [36, 42, 34]


Time Statistics:

  Min: 86.00 sec, Max: 94.00 sec, Average: 89.00 sec, Standard Deviation: 3.56 sec

Call Statistics:

  Min: 34 calls, Max: 42 calls, Average: 37.33 calls, Standard Deviation: 3.40 calls

Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
['  | Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string => int): int

  |
6 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(6,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string => int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string => int): int
{

  |
6 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(6,35): Error: closeparen expected
  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string => int): int
{
  match e

  |
6 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(6,35): Error: closeparen expected
  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
['function Eval(e: Expr, env: string => int): int\n']
['{\n']
['  match e\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
{

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
{
  match e

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(6,35): Error: invalid TypeAndToken
  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
  reads env

  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(6,35): Error: invalid TypeAndToken
  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  reads env\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
  reads env
{

  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(6,35): Error: invalid TypeAndToken
  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
-1.0
['{\n']
['  | Add(e1: Expr, e2: Expr)\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i

  |
9 |   case Const(i) => i
  |                     ^

ex.dfy(9,20): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
11 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(11,51): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range

  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                ^^^^^^

ex.dfy(7,31): Error: member 'domain' does not exist in function type '_#Func1'
  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                            ^^^

ex.dfy(7,43): Error: member 'Var' does not exist in datatype 'Expr'
  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                                          ^^^^^

ex.dfy(7,57): Error: member 'range' does not exist in function type '_#Func1'
3 resolution/type errors detected in ex.dfy

SCORE
None
['  requires forall x | x in env.domain :: e.Var(x) in env.range\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{
  match e

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{
  match e
  case Const(i) => i

   |
10 |   case Const(i) => i
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{
  match e
  case Const(i) => i
  case Var(name) => env(name)

   |
11 |   case Var(name) => env(name)
   |                              ^

ex.dfy(11,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
12 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(12,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
  requires forall x | x in env.domain :: e.Var(x) in env.range
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                ^^^^^^

ex.dfy(7,31): Error: member 'domain' does not exist in function type '_#Func1'
  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                            ^^^

ex.dfy(7,43): Error: member 'Var' does not exist in datatype 'Expr'
  |
7 |   requires forall x | x in env.domain :: e.Var(x) in env.range
  |                                                          ^^^^^

ex.dfy(7,57): Error: member 'range' does not exist in function type '_#Func1'
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i

  |
9 |   case Const(i) => i
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
11 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(11,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
17 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
18 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(18,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
19 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(19,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
26 |   match e
   |          ^

ex.dfy(26,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>

   |
27 |   case Const(_) =>
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>

   |
28 |   case Var(_) =>
   |                 ^

ex.dfy(28,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>

   |
29 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);

   |
30 |     assert Optimize(e) == Optimize(e2);
   |                                        ^

ex.dfy(30,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == Optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);

   |
31 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(31,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>

   |
32 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);

   |
33 |     assert Optimize(e) == Optimize(e1);
   |                                        ^

ex.dfy(33,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == Optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);

   |
34 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(34,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);
  case Add(e1, e2) =>

   |
35 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(35,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);
  case Add(e1, e2) =>
    assert Optimize(e) == Add(Optimize(e1), Optimize(e2));

   |
36 |     assert Optimize(e) == Add(Optimize(e1), Optimize(e2));
   |                                                           ^

ex.dfy(36,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == Add(Optimize(e1), Optimize(e2));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);
  case Add(e1, e2) =>
    assert Optimize(e) == Add(Optimize(e1), Optimize(e2));
    OptimizePreservesEval(e1, env);

   |
37 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);
  case Add(e1, e2) =>
    assert Optimize(e) == Add(Optimize(e1), Optimize(e2));
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);

   |
38 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(38,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(Const(0), e2) =>
    assert Optimize(e) == Optimize(e2);
    OptimizePreservesEval(e2, env);
  case Add(e1, Const(0)) =>
    assert Optimize(e) == Optimize(e1);
    OptimizePreservesEval(e1, env);
  case Add(e1, e2) =>
    assert Optimize(e) == Add(Optimize(e1), Optimize(e2));
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
}

ex.dfy(29,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4596,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.

   |
26 |   // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
   |                                                                                                                  ^

ex.dfy(26,113): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {

   |
27 |   if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
   |                                                                                      ^

ex.dfy(27,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
  } else {

   |
28 |   } else {
   |           ^

ex.dfy(28,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
  } else {
    // Recursive case: if e is an addition, optimize both sub-expressions.

   |
29 |     // Recursive case: if e is an addition, optimize both sub-expressions.
   |                                                                           ^

ex.dfy(29,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: if e is an addition, optimize both sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
  } else {
    // Recursive case: if e is an addition, optimize both sub-expressions.
    assert e == Add(_, _)

   |
30 |     assert e == Add(_, _)
   |                          ^

ex.dfy(30,25): Error: invalid AssertStmt
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(_, _)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
  } else {
    // Recursive case: if e is an addition, optimize both sub-expressions.
    assert e == Add(_, _)
    assert exists e1, e2. e == Add(e1, e2)

   |
30 |     assert e == Add(_, _)
   |                         ^

ex.dfy(30,24): Error: expected either 'by' or a semicolon following the assert expression
   |
31 |     assert exists e1, e2. e == Add(e1, e2)
   |                         ^

ex.dfy(31,24): Error: doublecolon expected
2 parse errors detected in ex.dfy

SCORE
None
['    assert exists e1, e2. e == Add(e1, e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant, variable, or addition of 0, then the optimization does not change the result.
  if e == Const(0) || e == Var(_) || e == Add(Const(0), _) || e == Add(_, Const(0)) {
  } else {
    // Recursive case: if e is an addition, optimize both sub-expressions.
    assert e == Add(_, _)
    assert exists e1, e2. e == Add(e1, e2)
    OptimizePreservesEval(e1, env)

   |
30 |     assert e == Add(_, _)
   |                         ^

ex.dfy(30,24): Error: expected either 'by' or a semicolon following the assert expression
   |
31 |     assert exists e1, e2. e == Add(e1, e2)
   |                         ^

ex.dfy(31,24): Error: doublecolon expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    OptimizePreservesEval(e1, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true

SCORE
1.0
['  requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);

   |
28 |   case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);

   |
29 |   case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                                ^

ex.dfy(29,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>

   |
30 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(30,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {

   |
31 |     {
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);

   |
32 |       OptimizePreservesEval(e1, env);
   |                                      ^

ex.dfy(32,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);

   |
33 |       OptimizePreservesEval(e2, env);
   |                                      ^

ex.dfy(33,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);

   |
34 |       assert Eval(Optimize(e1), env) == Eval(e1, env);
   |                                                       ^

ex.dfy(34,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Optimize(e1), env) == Eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);

   |
35 |       assert Eval(Optimize(e2), env) == Eval(e2, env);
   |                                                       ^

ex.dfy(35,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Optimize(e2), env) == Eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);
      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);

   |
36 |       assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);
   |                                                                         ^

ex.dfy(36,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);
      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);
      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);
      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);
    }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  requires true
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(e1, e2) =>
    {
      OptimizePreservesEval(e1, env);
      OptimizePreservesEval(e2, env);
      assert Eval(Optimize(e1), env) == Eval(e1, env);
      assert Eval(Optimize(e2), env) == Eval(e2, env);
      assert Eval(Optimize(Add(e1, e2)), env) == Eval(Add(e1, e2), env);
    }
}
```


STATS

number of nodes: 39
number of gen nodes: 20 (including leaves: 4)
number of back nodes: 19 (including leaves: 16)

expansion count: 27 (including failed: 8)

cache stats {'hit': 7, 'miss': 85}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215]

Trial calls: [36, 42, 34, 92]


Time Statistics:

  Min: 86.00 sec, Max: 215.00 sec, Average: 120.50 sec, Standard Deviation: 54.65 sec

Call Statistics:

  Min: 34 calls, Max: 92 calls, Average: 51.00 calls, Standard Deviation: 23.85 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215]

Trial calls: [36, 42, 34, 92]


Time Statistics:

  Min: 86.00 sec, Max: 215.00 sec, Average: 120.50 sec, Standard Deviation: 54.65 sec

Call Statistics:

  Min: 34 calls, Max: 92 calls, Average: 51.00 calls, Standard Deviation: 23.85 calls

Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)

SCORE
1.0
['  | Const(value: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value

  |
9 |   case Const(value) => value
  |                             ^

ex.dfy(9,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(value) => value\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
11 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(11,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
17 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
18 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(18,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
19 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(19,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
26 |   match e
   |          ^

ex.dfy(26,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>

   |
27 |   case Const(value) =>
   |                       ^

ex.dfy(27,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(value) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>

   |
28 |   case Var(name) =>
   |                    ^

ex.dfy(28,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>

   |
29 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(29,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);

   |
30 |     OptimizePreservesSemantics(e1, env);
   |                                         ^

ex.dfy(30,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);

   |
31 |     OptimizePreservesSemantics(e2, env);
   |                                         ^

ex.dfy(31,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e
  case Const(value) =>
  case Var(name) =>
  case Add(e1, e2) =>
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 14 (including failed: 0)

cache stats {'hit': 0, 'miss': 33}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88]

Trial calls: [36, 42, 34, 92, 33]


Time Statistics:

  Min: 86.00 sec, Max: 215.00 sec, Average: 114.00 sec, Standard Deviation: 50.58 sec

Call Statistics:

  Min: 33 calls, Max: 92 calls, Average: 47.40 calls, Standard Deviation: 22.52 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88]

Trial calls: [36, 42, 34, 92, 33]


Time Statistics:

  Min: 86.00 sec, Max: 215.00 sec, Average: 114.00 sec, Standard Deviation: 50.58 sec

Call Statistics:

  Min: 33 calls, Max: 92 calls, Average: 47.40 calls, Standard Deviation: 22.52 calls

Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
3 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(3,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
{

  |
3 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(3,32): Error: invalid TypeAndToken
  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
{
    match e

  |
3 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(3,32): Error: invalid TypeAndToken
  |
5 |     match e
  |            ^

ex.dfy(5,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e

  |
5 |   match e
  |          ^

ex.dfy(5,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i

  |
6 |   case Const(i) => i
  |                     ^

ex.dfy(6,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)

  |
7 |   case Var(name) => env(name)
  |                              ^

ex.dfy(7,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

  |
8 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  |                                                    ^

ex.dfy(8,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
12 | {
   |  ^

ex.dfy(12,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
13 |   match e
   |          ^

ex.dfy(13,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
14 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(14,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
15 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(15,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
16 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(16,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
17 |   case _ => e
   |              ^

ex.dfy(17,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['  ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e

   |
23 |   match e
   |          ^

ex.dfy(23,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;

   |
24 |   case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
   |                                                                                 ^

ex.dfy(24,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);

   |
25 |   case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
   |                                                                                                  ^

ex.dfy(25,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);

   |
27 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);

   |
28 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);

   |
29 |     assert Eval(e1, env) == Eval(Optimize(e1), env);
   |                                                     ^

ex.dfy(29,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e1, env) == Eval(Optimize(e1), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);
    assert Eval(e2, env) == Eval(Optimize(e2), env);

   |
30 |     assert Eval(e2, env) == Eval(Optimize(e2), env);
   |                                                     ^

ex.dfy(30,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e2, env) == Eval(Optimize(e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);
    assert Eval(e2, env) == Eval(Optimize(e2), env);
    assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);

   |
31 |     assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);
   |                                                                              ^

ex.dfy(31,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);
    assert Eval(e2, env) == Eval(Optimize(e2), env);
    assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);
    assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);

   |
32 |     assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);
   |                                                                                                            ^

ex.dfy(32,107): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);
    assert Eval(e2, env) == Eval(Optimize(e2), env);
    assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);
    assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);
}

ex.dfy(32,11): Error: assertion might not hold
   |
32 |     assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(i) => assert Eval(e, env) == i; assert Eval(Optimize(e), env) == i;
  case Var(name) => assert Eval(e, env) == env(name); assert Eval(Optimize(e), env) == env(name);
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(e1, env) == Eval(Optimize(e1), env);
    assert Eval(e2, env) == Eval(Optimize(e2), env);
    assert Eval(e, env) == Eval(Optimize(e1), env) + Eval(Optimize(e2), env);
    assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);
}
```

ex.dfy(32,11): Error: assertion might not hold
   |
32 |     assert Eval(Optimize(e), env) == Eval(Optimize(Optimize(e1)), env) + Eval(Optimize(Optimize(e2)), env);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['```\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases

   |
23 |   // Base cases
   |                ^

ex.dfy(23,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {

   |
24 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(24,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {

   |
25 |   } else if e == Add(Const(0), _) {
   |                                    ^

ex.dfy(25,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Add(Const(0), _) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {
    assert e == Add(Const(0), e2);

   |
26 |     assert e == Add(Const(0), e2);
   |                                   ^

ex.dfy(26,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(Const(0), e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {
    assert e == Add(Const(0), e2);
    assert Optimize(e) == Optimize(e2);

   |
27 |     assert Optimize(e) == Optimize(e2);
   |                                        ^

ex.dfy(27,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == Optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {
    assert e == Add(Const(0), e2);
    assert Optimize(e) == Optimize(e2);
    lemma OptimizePreservesEval(e2, env);

   |
28 |     lemma OptimizePreservesEval(e2, env);
   |     ^

ex.dfy(28,4): Error: rbrace expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                   ^

ex.dfy(28,34): Error: colon expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                        ^

ex.dfy(28,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
None
['    lemma OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {
    assert e == Add(Const(0), e2);
    assert Optimize(e) == Optimize(e2);
    lemma OptimizePreservesEval(e2, env);
  } else if e == Add(_, Const(0)) {

   |
28 |     lemma OptimizePreservesEval(e2, env);
   |     ^

ex.dfy(28,4): Error: rbrace expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                   ^

ex.dfy(28,34): Error: colon expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                        ^

ex.dfy(28,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Add(_, Const(0)) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {
  } else if e == Add(Const(0), _) {
    assert e == Add(Const(0), e2);
    assert Optimize(e) == Optimize(e2);
    lemma OptimizePreservesEval(e2, env);
  } else if e == Add(_, Const(0)) {
    assert e == Add(e1, Const(0));

   |
28 |     lemma OptimizePreservesEval(e2, env);
   |     ^

ex.dfy(28,4): Error: rbrace expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                   ^

ex.dfy(28,34): Error: colon expected
   |
28 |     lemma OptimizePreservesEval(e2, env);
   |                                        ^

ex.dfy(28,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    assert e == Add(e1, Const(0));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
23 |   match e
   |          ^

ex.dfy(23,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => () // Base case

   |
24 |   case Const(_) => () // Base case
   |                                   ^

ex.dfy(24,34): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) => () // Base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => () // Base case
  case Var(_) => () // Base case

   |
25 |   case Var(_) => () // Base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => () // Base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
25 |   case Var(_) => () // Base case
   |                                 ^

ex.dfy(25,32): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) => () // Base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => () // Base case
  case Var(_) => () // Base case
  case Add(e1, e2) =>

   |
25 |   case Var(_) => () // Base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => () // Base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(_) => () // Base case
   |                  ^

ex.dfy(25,17): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => () // Base case
  case Var(_) => () // Base case
  case Add(e1, e2) =>
    // Recursive case

   |
25 |   case Var(_) => () // Base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => () // Base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(_) => () // Base case
   |                  ^

ex.dfy(25,17): Error: missing semicolon at end of statement
   |
27 |     // Recursive case
   |                      ^

ex.dfy(27,21): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['    // Recursive case\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);

   |
24 |   case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                                  ^

ex.dfy(24,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);

   |
25 |   case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                                ^

ex.dfy(25,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);

   |
27 |     assert Eval(Optimize(e), env) == Eval(e2, env);
   |                                                    ^

ex.dfy(27,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);

   |
28 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);

   |
29 |     assert Eval(Optimize(e), env) == Eval(e2, env);
   |                                                    ^

ex.dfy(29,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 

   |
30 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);

   |
31 |     assert Eval(Optimize(e), env) == Eval(e1, env);
   |                                                    ^

ex.dfy(31,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);

   |
32 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(32,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);

   |
33 |     assert Eval(Optimize(e), env) == Eval(e1, env);
   |                                                    ^

ex.dfy(33,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 

   |
34 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(34,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 
    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);

   |
35 |     assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);
   |                                                                                 ^

ex.dfy(35,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 
    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);
    OptimizePreservesEval(e1, env);

   |
36 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 
    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);

   |
37 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 
    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(Add(e1, e2), env);

   |
38 |     assert Eval(Optimize(e), env) == Eval(Add(e1, e2), env);
   |                                                             ^

ex.dfy(38,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Var(_) => assert Eval(Optimize(e), env) == Eval(e, env);
  case Add(Const(0), e2) => 
    assert Eval(Optimize(e), env) == Eval(e2, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(e2, env);
  case Add(e1, Const(0)) => 
    assert Eval(Optimize(e), env) == Eval(e1, env);
    OptimizePreservesEval(e1, env);
    assert Eval(Optimize(e), env) == Eval(e1, env);
  case Add(e1, e2) => 
    assert Eval(Optimize(e), env) == Eval(Add(Optimize(e1), Optimize(e2)), env);
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e), env) == Eval(Add(e1, e2), env);
}

ex.dfy(26,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4690,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant, variable, or addition with a constant 0,

   |
23 |   // Base case: If e is a constant, variable, or addition with a constant 0,
   |                                                                             ^

ex.dfy(23,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If e is a constant, variable, or addition with a constant 0,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant, variable, or addition with a constant 0,
  // the result of optimization is the same as the original expression.

   |
24 |   // the result of optimization is the same as the original expression.
   |                                                                        ^

ex.dfy(24,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the result of optimization is the same as the original expression.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant, variable, or addition with a constant 0,
  // the result of optimization is the same as the original expression.
  if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {

   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                         ^^

ex.dfy(25,40): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                                          ^^

ex.dfy(25,57): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                                                          ^

ex.dfy(25,73): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant, variable, or addition with a constant 0,
  // the result of optimization is the same as the original expression.
  if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
    // In this case, optimization does not change the expression,

   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                         ^^

ex.dfy(25,40): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                                          ^^

ex.dfy(25,57): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
26 |     // In this case, optimization does not change the expression,
   |                                                                  ^

ex.dfy(26,65): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    // In this case, optimization does not change the expression,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant, variable, or addition with a constant 0,
  // the result of optimization is the same as the original expression.
  if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
    // In this case, optimization does not change the expression,
    // so the evaluation results are the same.

   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                         ^^

ex.dfy(25,40): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
25 |   if e is Const || e is Var || e is Add && e.e2 is Const && e.e2.i == 0 {
   |                                                          ^^

ex.dfy(25,57): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
27 |     // so the evaluation results are the same.
   |                                               ^

ex.dfy(27,46): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    // so the evaluation results are the same.\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>

   |
24 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(24,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {

   |
25 |   {
   |    ^

ex.dfy(25,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;

   |
26 |     assert Optimize(e) == e2;
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == e2;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);

   |
27 |     assert Eval(e2, env) == Eval(e, env);
   |                                          ^

ex.dfy(27,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e2, env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }

   |
28 |   }
   |    ^

ex.dfy(28,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>

   |
29 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {

   |
30 |   {
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;

   |
31 |     assert Optimize(e) == e1;
   |                              ^

ex.dfy(31,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == e1;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);

   |
32 |     assert Eval(e1, env) == Eval(e, env);
   |                                          ^

ex.dfy(32,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e1, env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>

   |
34 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(34,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {

   |
35 |   {
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);

   |
36 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);

   |
37 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);

   |
38 |     assert Eval(Optimize(e1), env) == Eval(e1, env);
   |                                                     ^

ex.dfy(38,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e1), env) == Eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);

   |
39 |     assert Eval(Optimize(e2), env) == Eval(e2, env);
   |                                                     ^

ex.dfy(39,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e2), env) == Eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);

   |
40 |     assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
   |                                                                                 ^

ex.dfy(40,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);

   |
41 |     assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                   ^

ex.dfy(41,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }

   |
42 |   }
   |    ^

ex.dfy(42,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>

   |
43 |   case _ =>
   |            ^

ex.dfy(43,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>
  {

   |
44 |   {
   |    ^

ex.dfy(44,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>
  {
    assert Optimize(e) == e;

   |
45 |     assert Optimize(e) == e;
   |                             ^

ex.dfy(45,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) == e;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>
  {
    assert Optimize(e) == e;
    assert Eval(e, env) == Eval(Optimize(e), env);

   |
46 |     assert Eval(e, env) == Eval(Optimize(e), env);
   |                                                   ^

ex.dfy(46,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(e, env) == Eval(Optimize(e), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>
  {
    assert Optimize(e) == e;
    assert Eval(e, env) == Eval(Optimize(e), env);
  }

   |
47 |   }
   |    ^

ex.dfy(47,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  {
    assert Optimize(e) == e2;
    assert Eval(e2, env) == Eval(e, env);
  }
  case Add(e1, Const(0)) =>
  {
    assert Optimize(e) == e1;
    assert Eval(e1, env) == Eval(e, env);
  }
  case Add(e1, e2) =>
  {
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
    assert Eval(Optimize(e1), env) == Eval(e1, env);
    assert Eval(Optimize(e2), env) == Eval(e2, env);
    assert Eval(Add(Optimize(e1), Optimize(e2)), env) == Eval(Add(e1, e2), env);
    assert Eval(Optimize(e), env) == Eval(e, env);
  }
  case _ =>
  {
    assert Optimize(e) == e;
    assert Eval(e, env) == Eval(Optimize(e), env);
  }
}

ex.dfy(24,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4709,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(_) => ()

   |
24 |   case Const(_) => ()
   |                      ^

ex.dfy(24,21): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(_) => ()
  case Var(_) => ()

   |
25 |   case Var(_) => ()
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => ()
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
25 |   case Var(_) => ()
   |                    ^

ex.dfy(25,19): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(_) => ()
  case Var(_) => ()
  case Add(e1, e2) =>

   |
25 |   case Var(_) => ()
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => ()
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(_) => ()
   |                  ^

ex.dfy(25,17): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)
{
  match e
  case Const(_) => ()
  case Var(_) => ()
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);

   |
25 |   case Var(_) => ()
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(_) => ()
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, e2) =>
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(_) => ()
   |                  ^

ex.dfy(25,17): Error: missing semicolon at end of statement
   |
27 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['    OptimizePreservesEval(e1, env);\n']
['\n']
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the property is trivially true.

   |
23 |   // Base case: If e is a constant or variable, the property is trivially true.
   |                                                                                ^

ex.dfy(23,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If e is a constant or variable, the property is trivially true.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the property is trivially true.
  if e matches Const(i) || e matches Var(name) {

   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^

ex.dfy(24,7): Error: lbrace expected
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^^^^^^^

ex.dfy(24,7): Error: missing semicolon at end of statement
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |                         ^

ex.dfy(24,24): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
None
['  if e matches Const(i) || e matches Var(name) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the property is trivially true.
  if e matches Const(i) || e matches Var(name) {
  }

   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^

ex.dfy(24,7): Error: lbrace expected
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^^^^^^^

ex.dfy(24,7): Error: missing semicolon at end of statement
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |                         ^

ex.dfy(24,24): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: If e is a constant or variable, the property is trivially true.
  if e matches Const(i) || e matches Var(name) {
  }
  // Case: If e is an addition with 0 on the left, the optimization removes it.

   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^

ex.dfy(24,7): Error: lbrace expected
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |        ^^^^^^^

ex.dfy(24,7): Error: missing semicolon at end of statement
   |
24 |   if e matches Const(i) || e matches Var(name) {
   |                         ^

ex.dfy(24,24): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
-1.0
['  // Case: If e is an addition with 0 on the left, the optimization removes it.\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => () // base case

   |
24 |   case Const(i) => () // base case
   |                                   ^

ex.dfy(24,34): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(i) => () // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => () // base case
  case Var(name) => () // base case

   |
25 |   case Var(name) => () // base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(i) => () // base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
25 |   case Var(name) => () // base case
   |                                    ^

ex.dfy(25,35): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => () // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => () // base case
  case Var(name) => () // base case
  case Add(Const(0), e2) => () // recursive case

   |
25 |   case Var(name) => () // base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(i) => () // base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(Const(0), e2) => () // recursive case
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(name) => () // base case
   |                     ^

ex.dfy(25,20): Error: missing semicolon at end of statement
   |
26 |   case Add(Const(0), e2) => () // recursive case
   |                                                 ^

ex.dfy(26,48): Error: invalid Suffix
5 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => () // recursive case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => () // base case
  case Var(name) => () // base case
  case Add(Const(0), e2) => () // recursive case
  case Add(e1, Const(0)) => () // recursive case

   |
25 |   case Var(name) => () // base case
   |   ^

ex.dfy(25,2): Error: invalid Suffix
   |
24 |   case Const(i) => () // base case
   |                    ^

ex.dfy(24,19): Error: missing semicolon at end of statement
   |
26 |   case Add(Const(0), e2) => () // recursive case
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |   case Var(name) => () // base case
   |                     ^

ex.dfy(25,20): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => () // recursive case
   |   ^

ex.dfy(27,2): Error: invalid Suffix
   |
26 |   case Add(Const(0), e2) => () // recursive case
   |                             ^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => () // recursive case
   |                                                 ^

ex.dfy(27,48): Error: invalid Suffix
7 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, Const(0)) => () // recursive case\n']
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
25 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);

   |
27 |     OptimizePreservesEval(e1, env);
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);

   |
28 |     OptimizePreservesEval(e2, env);
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
  case _ =>

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
  case _ =>
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
  case _ =>
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(i) => i
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizePreservesEval(e1, env);
    OptimizePreservesEval(e2, env);
  case _ =>
}
```


STATS

number of nodes: 39
number of gen nodes: 20 (including leaves: 5)
number of back nodes: 19 (including leaves: 15)

expansion count: 29 (including failed: 10)

cache stats {'hit': 20, 'miss': 117}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347]

Trial calls: [36, 42, 34, 92, 33, 137]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 152.83 sec, Standard Deviation: 98.35 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 62.33 calls, Standard Deviation: 39.21 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347]

Trial calls: [36, 42, 34, 92, 33, 137]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 152.83 sec, Standard Deviation: 98.35 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 62.33 calls, Standard Deviation: 39.21 calls

Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

SCORE
1.0
['              | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)

   |
10 |     case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
   |                                                                        ^

ex.dfy(10,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>

   |
16 |     case Add(left, right) =>
   |                             ^

ex.dfy(16,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(left, right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);

   |
17 |         var opt_left := Optimize(left);
   |                                        ^

ex.dfy(17,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var opt_left := Optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);

   |
18 |         var opt_right := Optimize(right);
   |                                          ^

ex.dfy(18,41): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var opt_right := Optimize(right);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then

   |
19 |         if opt_left == Const(0) then
   |                                     ^

ex.dfy(19,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        if opt_left == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right

   |
20 |             opt_right
   |                      ^

ex.dfy(20,21): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            opt_right\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then

   |
21 |         else if opt_right == Const(0) then
   |                                           ^

ex.dfy(21,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else if opt_right == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left

   |
22 |             opt_left
   |                     ^

ex.dfy(22,20): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            opt_left\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else

   |
23 |         else
   |             ^

ex.dfy(23,12): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)

   |
24 |             Add(opt_left, opt_right)
   |                                     ^

ex.dfy(24,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            Add(opt_left, opt_right)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e

   |
25 |     case _ => e
   |                ^

ex.dfy(25,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base cases

   |
32 |     // Base cases
   |                  ^

ex.dfy(32,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base cases
    if e == Const(0) then

   |
33 |     if e == Const(0) then
   |                      ^

ex.dfy(33,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base cases
    if e == Const(0) then
        assert Evaluate(e, env) == 0;

   |
33 |     if e == Const(0) then
   |                      ^

ex.dfy(33,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Evaluate(e, env) == 0;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base cases
    if e == Const(0) then
        assert Evaluate(e, env) == 0;
        assert Evaluate(Optimize(e), env) == 0;

   |
33 |     if e == Const(0) then
   |                      ^

ex.dfy(33,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        assert Evaluate(Optimize(e), env) == 0;\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base case

   |
32 |     // Base case
   |                 ^

ex.dfy(32,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_) then

   |
33 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(0) || e == Var(_) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_) then
        // nothing to prove

   |
33 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // nothing to prove\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_) then
        // nothing to prove
    else

   |
33 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e

   |
32 |     match e
   |            ^

ex.dfy(32,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>

   |
33 |     case Const(_) =>
   |                     ^

ex.dfy(33,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>

   |
34 |     case Var(_) =>
   |                   ^

ex.dfy(34,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>

   |
35 |     case Add(left, right) =>
   |                             ^

ex.dfy(35,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(left, right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);

   |
36 |         var opt_left := Optimize(left);
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var opt_left := Optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);

   |
37 |         var opt_right := Optimize(right);
   |                                          ^

ex.dfy(37,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var opt_right := Optimize(right);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        OptimizerPreservesSemantics(left, env);

   |
38 |         OptimizerPreservesSemantics(left, env);
   |                                                ^

ex.dfy(38,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        OptimizerPreservesSemantics(left, env);
        OptimizerPreservesSemantics(right, env);

   |
39 |         OptimizerPreservesSemantics(right, env);
   |                                                 ^

ex.dfy(39,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        OptimizerPreservesSemantics(left, env);
        OptimizerPreservesSemantics(right, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        OptimizerPreservesSemantics(left, env);
        OptimizerPreservesSemantics(right, env);
}
``` package com.example.android.miwok;

SCORE
1.0
['``` package com.example.android.miwok;\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        if opt_left == Const(0) then
            opt_right
        else if opt_right == Const(0) then
            opt_left
        else
            Add(opt_left, opt_right)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(left, right) =>
        var opt_left := Optimize(left);
        var opt_right := Optimize(right);
        OptimizerPreservesSemantics(left, env);
        OptimizerPreservesSemantics(right, env);
}
``` package com.example.android.miwok;


STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 2)
number of back nodes: 16 (including leaves: 15)

expansion count: 18 (including failed: 2)

cache stats {'hit': 1, 'miss': 51}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126]

Trial calls: [36, 42, 34, 92, 33, 137, 52]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 149.00 sec, Standard Deviation: 91.53 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 60.86 calls, Standard Deviation: 36.48 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126]

Trial calls: [36, 42, 34, 92, 33, 137, 52]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 149.00 sec, Standard Deviation: 91.53 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 60.86 calls, Standard Deviation: 36.48 calls

Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)

SCORE
1.0
['  | Const(value: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

SCORE
1.0
['  | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null

  |
7 |   requires e != null && env != null
  |                 ^^^^

ex.dfy(7,16): Error: type of 'null' is a reference type, but it is used as Expr
  |
7 |   requires e != null && env != null
  |                                ^^^^

ex.dfy(7,31): Error: type of 'null' is a reference type, but it is used as string -> int
2 resolution/type errors detected in ex.dfy

SCORE
None
['  requires e != null && env != null\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{
  match e

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{
  match e
  case Const(value) => value

   |
10 |   case Const(value) => value
   |                             ^

ex.dfy(10,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(value) => value\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{
  match e
  case Const(value) => value
  case Var(name) => env(name)

   |
11 |   case Var(name) => env(name)
   |                              ^

ex.dfy(11,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)

   |
12 |   case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
   |                                                                      ^

ex.dfy(12,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
  requires e != null && env != null
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

  |
7 |   requires e != null && env != null
  |                 ^^^^

ex.dfy(7,16): Error: type of 'null' is a reference type, but it is used as Expr
  |
7 |   requires e != null && env != null
  |                                ^^^^

ex.dfy(7,31): Error: type of 'null' is a reference type, but it is used as string -> int
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value

  |
9 |   case Const(value) => value
  |                             ^

ex.dfy(9,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(value) => value\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)

   |
11 |   case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
   |                                                                      ^

ex.dfy(11,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right

   |
17 |   case Add(Const(0), right) => right
   |                                     ^

ex.dfy(17,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), right) => right\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left

   |
18 |   case Add(left, Const(0)) => left
   |                                   ^

ex.dfy(18,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, Const(0)) => left\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))

   |
19 |   case Add(left, right) => Add(Optimize(left), Optimize(right))
   |                                                                ^

ex.dfy(19,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Add(Optimize(left), Optimize(right))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)
}

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)
}
```

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>

   |
28 |   case Add(Const(0), right) =>
   |                               ^

ex.dfy(28,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>

   |
29 |   case Add(left, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>

   |
30 |   case Add(left, right) =>
   |                           ^

ex.dfy(30,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);

   |
31 |     OptimizePreservesSemantics(left, env);
   |                                           ^

ex.dfy(31,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);
    OptimizePreservesSemantics(right, env);

   |
32 |     OptimizePreservesSemantics(right, env);
   |                                            ^

ex.dfy(32,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);
    OptimizePreservesSemantics(right, env);
  case _ =>

   |
33 |   case _ =>
   |            ^

ex.dfy(33,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);
    OptimizePreservesSemantics(right, env);
  case _ =>
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);
    OptimizePreservesSemantics(right, env);
  case _ =>
}
``` import { Component, OnInit } from '@angular/core';

SCORE
1.0
["``` import { Component, OnInit } from '@angular/core';\n"]
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(value) => value
  case Var(name) => env(name)
  case Add(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right
  case Add(left, Const(0)) => left
  case Add(left, right) => Add(Optimize(left), Optimize(right))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Add(Const(0), right) =>
  case Add(left, Const(0)) =>
  case Add(left, right) =>
    OptimizePreservesSemantics(left, env);
    OptimizePreservesSemantics(right, env);
  case _ =>
}
``` import { Component, OnInit } from '@angular/core';


STATS

number of nodes: 31
number of gen nodes: 16 (including leaves: 1)
number of back nodes: 15 (including leaves: 15)

expansion count: 17 (including failed: 2)

cache stats {'hit': 0, 'miss': 46}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 144.88 sec, Standard Deviation: 86.31 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 59.00 calls, Standard Deviation: 34.48 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 144.88 sec, Standard Deviation: 86.31 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 59.00 calls, Standard Deviation: 34.48 calls

Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

  |
8 |   case Const(val) => val
  |                         ^

ex.dfy(8,24): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
10 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(10,59): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['function method Evaluate(e: Expr, env: string -> int): int\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
10 |     case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                              ^

ex.dfy(10,61): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string => int): int

  |
5 | function method Eval(e: Expr, env: string => int): int
  |                                           ^

ex.dfy(5,42): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: string => int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string => int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string => int): int
{

  |
5 | function method Eval(e: Expr, env: string => int): int
  |                                           ^

ex.dfy(5,42): Error: closeparen expected
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string => int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string => int): int
{
    match e

  |
5 | function method Eval(e: Expr, env: string => int): int
  |                                           ^

ex.dfy(5,42): Error: closeparen expected
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string => int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  |                                                         ^

ex.dfy(5,56): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e

  |
6 |   match e
  |          ^

ex.dfy(6,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val

  |
7 |   case Const(val) => val
  |                         ^

ex.dfy(7,24): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
8 |   case Var(name) => env(name)
  |                              ^

ex.dfy(8,29): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

  |
9 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  |                                                    ^

ex.dfy(9,51): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['              | Add(e1: Expr, e2: Expr)\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

  |
8 |   case Const(val) => val
  |                         ^

ex.dfy(8,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
10 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(10,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2

   |
16 |   case Add(Const(0), e2) => e2
   |                               ^

ex.dfy(16,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1

   |
17 |   case Add(e1, Const(0)) => e1
   |                               ^

ex.dfy(17,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
18 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>

   |
26 |   case Const(_) =>
   |                   ^

ex.dfy(26,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>

   |
27 |   case Var(_) =>
   |                 ^

ex.dfy(27,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);

   |
29 |     OptimizerPreservesSemantics(e1, env);
   |                                          ^

ex.dfy(29,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);

   |
30 |     OptimizerPreservesSemantics(e2, env);
   |                                          ^

ex.dfy(30,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2
  case Add(e1, Const(0)) => e1
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
}
```


STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 3)
number of back nodes: 17 (including leaves: 15)

expansion count: 21 (including failed: 4)

cache stats {'hit': 5, 'miss': 53}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116, 134]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46, 58]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 143.67 sec, Standard Deviation: 81.45 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 58.89 calls, Standard Deviation: 32.51 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116, 134]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46, 58]


Time Statistics:

  Min: 86.00 sec, Max: 347.00 sec, Average: 143.67 sec, Standard Deviation: 81.45 sec

Call Statistics:

  Min: 33 calls, Max: 137 calls, Average: 58.89 calls, Standard Deviation: 32.51 calls

Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
{

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
{
    match e

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: func (string) returns (int)): int

  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                             ^

ex.dfy(5,44): Error: closeparen expected
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                                      ^

ex.dfy(5,53): Error: this symbol not expected in FunctionSpec
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
['function method Evaluate(e: Expr, env: func (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: func (string) returns (int)): int
{

  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                             ^

ex.dfy(5,44): Error: closeparen expected
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                                      ^

ex.dfy(5,53): Error: this symbol not expected in FunctionSpec
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: func (string) returns (int)): int
{
  match e

  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                             ^

ex.dfy(5,44): Error: closeparen expected
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  |                                                      ^

ex.dfy(5,53): Error: this symbol not expected in FunctionSpec
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
  |
5 | function method Evaluate(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

  |
8 |   case Const(val) => val
  |                         ^

ex.dfy(8,24): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
10 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(10,51): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['function method Eval(e: Expr, env: function (string) returns (int)): int\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
{
  match e

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
['             | Add(e1: Expr, e2: Expr)\n']
['\n']
['function method Eval(e: Expr, env: string -> int): int\n']
['{\n']
['  match e\n']
['  case Const(val) => val\n']
['  case Var(name) => env(name)\n']
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
['}\n']
['function method Eval(e: Expr, env: string -> int): int\n']
['{\n']
['  match e\n']
['  case Const(val) => val\n']
['  case Var(name) => env(name)\n']
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
['}\n']
['function method Eval(e: Expr, env: string -> int): int\n']
['{\n']
['  match e\n']
['  case Const(val) => val\n']
['  case Var(name) => env(name)\n']
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
['}\n']
['             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['             | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
10 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                          ^

ex.dfy(10,57): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
10 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                          ^

ex.dfy(10,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 

   |
16 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(16,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then

   |
17 |         if Eval(lhs, (x) => 0) == 0 then
   |                                         ^

ex.dfy(17,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)

   |
18 |             Optimize(rhs)
   |                          ^

ex.dfy(18,25): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then

   |
19 |         else if Eval(rhs, (x) => 0) == 0 then
   |                                              ^

ex.dfy(19,45): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else if Eval(rhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)

   |
20 |             Optimize(lhs)
   |                          ^

ex.dfy(20,25): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else

   |
21 |         else
   |             ^

ex.dfy(21,12): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))

   |
22 |             Add(Optimize(lhs), Optimize(rhs))
   |                                              ^

ex.dfy(22,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e

   |
23 |     case _ => e
   |                ^

ex.dfy(23,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)

SCORE
1.0
['ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e

   |
30 |     match e
   |            ^

ex.dfy(30,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);

   |
31 |     case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
   |                                                                              ^

ex.dfy(31,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);

   |
32 |     case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
   |                                                                            ^

ex.dfy(32,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Add(lhs, rhs) => 

   |
33 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Add(lhs, rhs) => 
        OptimizePreservesSemantics(lhs);

   |
34 |         OptimizePreservesSemantics(lhs);
   |                                         ^

ex.dfy(34,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Add(lhs, rhs) => 
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);

   |
35 |         OptimizePreservesSemantics(rhs);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Add(lhs, rhs) => 
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);
        assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);

   |
36 |         assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
   |                                                                 ^

ex.dfy(36,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Const(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Var(_) => assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
    case Add(lhs, rhs) => 
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);
        assert Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0);
}


SCORE
-1.0
['}\n']
['{\n']
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Add(lhs, rhs) => 

   |
31 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(31,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            OptimizePreservesSemantics(rhs)

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
   |
33 |             OptimizePreservesSemantics(rhs)
   |                                            ^

ex.dfy(33,43): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            OptimizePreservesSemantics(rhs)
        else if Eval(rhs, (x) => 0) == 0 then

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
   |
34 |         else if Eval(rhs, (x) => 0) == 0 then
   |         ^

ex.dfy(34,8): Error: invalid UpdateStmt
   |
34 |         else if Eval(rhs, (x) => 0) == 0 then
   |                                          ^

ex.dfy(34,41): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if Eval(rhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)

SCORE
1.0
['ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.

   |
30 |     // Base case: e is not an addition.
   |                                        ^

ex.dfy(30,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: e is not an addition.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {

   |
31 |     if e is Const || e is Var {
   |                                ^

ex.dfy(31,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)

   |
33 |     else // e is Add(lhs, rhs)
   |                               ^

ex.dfy(33,30): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['    else // e is Add(lhs, rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)
    {

   |
34 |     {
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)
    {
        OptimizePreservesSemantics(lhs);

   |
35 |         OptimizePreservesSemantics(lhs);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)
    {
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);

   |
36 |         OptimizePreservesSemantics(rhs);
   |                                         ^

ex.dfy(36,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)
    {
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    // Base case: e is not an addition.
    if e is Const || e is Var {
    }
    else // e is Add(lhs, rhs)
    {
        OptimizePreservesSemantics(lhs);
        OptimizePreservesSemantics(rhs);
    }
}

   |
31 |     if e is Const || e is Var {
   |             ^^^^^

ex.dfy(31,12): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
31 |     if e is Const || e is Var {
   |                           ^^^

ex.dfy(31,26): Error: Type or type parameter is not declared in this scope: Var (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
35 |         OptimizePreservesSemantics(lhs);
   |                                    ^^^

ex.dfy(35,35): Error: unresolved identifier: lhs
   |
36 |         OptimizePreservesSemantics(rhs);
   |                                    ^^^

ex.dfy(36,35): Error: unresolved identifier: rhs
   |
31 |     if e is Const || e is Var {
   |          ^^

ex.dfy(31,9): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
   |
31 |     if e is Const || e is Var {
   |                        ^^

ex.dfy(31,23): Error: type test for type 'Var' must be from an expression assignable to it (got 'Expr')
6 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    if e is Const then

   |
30 |     if e is Const then
   |                   ^

ex.dfy(30,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    if e is Const then
        // Base case: Constants are unaffected by optimization.

   |
30 |     if e is Const then
   |                   ^

ex.dfy(30,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Base case: Constants are unaffected by optimization.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(Optimize(e), (x) => 0) == Eval(e, (x) => 0)
{
    if e is Const then
        // Base case: Constants are unaffected by optimization.
    else if e is Var then

   |
30 |     if e is Const then
   |                   ^

ex.dfy(30,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else if e is Var then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
{
    Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)

   |
28 |     Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
   |                       ^

ex.dfy(28,22): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
{
    Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
}

   |
28 |     Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
   |                       ^

ex.dfy(28,22): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
{
    Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
}
```

   |
28 |     Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
   |                       ^

ex.dfy(28,22): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['    ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>

   |
30 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);

   |
31 |         assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
   |                                                                                                       ^

ex.dfy(31,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);

   |
32 |         OptimizePreservesEval(lhs, env);
   |                                         ^

ex.dfy(32,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);

   |
33 |         OptimizePreservesEval(rhs, env);
   |                                         ^

ex.dfy(33,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>

   |
34 |     case _ =>
   |              ^

ex.dfy(34,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>
}


SCORE
-1.0
['}\n']
['{\n']
['    match e\n']
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
   |
32 |         {
   |          ^

ex.dfy(32,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {
            OptimizePreservesEval(rhs, env);

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
   |
33 |             OptimizePreservesEval(rhs, env);
   |                                             ^

ex.dfy(33,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['            OptimizePreservesEval(rhs, env);\n']
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,

   |
30 |     // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
   |                                                                                              ^

ex.dfy(30,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.

   |
31 |     // the result of optimization is the same as the original expression.
   |                                                                          ^

ex.dfy(31,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // the result of optimization is the same as the original expression.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

   |
32 |     // This is because the optimizer removes additions by 0.
   |                                                             ^

ex.dfy(32,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // This is because the optimizer removes additions by 0.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.


   |
32 |     // This is because the optimizer removes additions by 0.
   |                                                             ^

ex.dfy(32,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,

   |
34 |     // Inductive case: If e is an addition with non-0 subexpressions,
   |                                                                      ^

ex.dfy(34,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: If e is an addition with non-0 subexpressions,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.

   |
35 |     // we recursively apply the lemma on the subexpressions.
   |                                                             ^

ex.dfy(35,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // we recursively apply the lemma on the subexpressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.


   |
35 |     // we recursively apply the lemma on the subexpressions.
   |                                                             ^

ex.dfy(35,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.

    // This lemma is proved by structural induction on e.

   |
37 |     // This lemma is proved by structural induction on e.
   |                                                          ^

ex.dfy(37,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // This lemma is proved by structural induction on e.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.

    // This lemma is proved by structural induction on e.
    // The base case is trivial, and for the inductive case,

   |
38 |     // The base case is trivial, and for the inductive case,
   |                                                             ^

ex.dfy(38,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // The base case is trivial, and for the inductive case,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.

    // This lemma is proved by structural induction on e.
    // The base case is trivial, and for the inductive case,
    // we call the lemma recursively on the subexpressions.

   |
39 |     // we call the lemma recursively on the subexpressions.
   |                                                            ^

ex.dfy(39,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // we call the lemma recursively on the subexpressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr)
requires true
ensures Eval(e, (x) => 0) == Eval(Optimize(e), (x) => 0)
{
    // Base case: if e is a constant, variable or addition with at least one 0 subexpression,
    // the result of optimization is the same as the original expression.
    // This is because the optimizer removes additions by 0.

    // Inductive case: If e is an addition with non-0 subexpressions,
    // we recursively apply the lemma on the subexpressions.

    // This lemma is proved by structural induction on e.
    // The base case is trivial, and for the inductive case,
    // we call the lemma recursively on the subexpressions.
}


SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['    ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>

   |
30 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
   |
32 |         {
   |          ^

ex.dfy(32,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {
            lemma lemma1()

   |
31 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(31,36): Error: lbrace expected
   |
33 |             lemma lemma1()
   |             ^

ex.dfy(33,12): Error: rbrace expected
   |
33 |             lemma lemma1()
   |                           ^

ex.dfy(33,26): Error: invalid UpdateStmt
3 parse errors detected in ex.dfy

SCORE
-1.0
['            lemma lemma1()\n']
['{\n']
['    match e\n']
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;

   |
31 |         assert Eval(lhs, (x) => 0) == 0;
   |                                         ^

ex.dfy(31,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(lhs, (x) => 0) == 0;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;
        assert Eval(rhs, (x) => 0) == 0;

   |
32 |         assert Eval(rhs, (x) => 0) == 0;
   |                                         ^

ex.dfy(32,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(rhs, (x) => 0) == 0;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;
        assert Eval(rhs, (x) => 0) == 0;
        OptimizerPreservesSemantics(lhs, env);

   |
33 |         OptimizerPreservesSemantics(lhs, env);
   |                                               ^

ex.dfy(33,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;
        assert Eval(rhs, (x) => 0) == 0;
        OptimizerPreservesSemantics(lhs, env);
        OptimizerPreservesSemantics(rhs, env);

   |
34 |         OptimizerPreservesSemantics(rhs, env);
   |                                               ^

ex.dfy(34,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;
        assert Eval(rhs, (x) => 0) == 0;
        OptimizerPreservesSemantics(lhs, env);
        OptimizerPreservesSemantics(rhs, env);
    case _ =>

   |
35 |     case _ =>
   |              ^

ex.dfy(35,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e
    case Add(lhs, rhs) =>
        assert Eval(lhs, (x) => 0) == 0;
        assert Eval(rhs, (x) => 0) == 0;
        OptimizerPreservesSemantics(lhs, env);
        OptimizerPreservesSemantics(rhs, env);
    case _ =>
}


SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['    ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>

   |
30 |     case Const(val) =>
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>
    case Var(name) =>

   |
31 |     case Var(name) =>
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>
    case Var(name) =>
    case Add(lhs, rhs) =>

   |
32 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(32,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>
    case Var(name) =>
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then

   |
33 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>
    case Var(name) =>
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
            OptimizerPreservesSemantics(rhs, env)

   |
33 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
   |
34 |             OptimizerPreservesSemantics(rhs, env)
   |                                                  ^

ex.dfy(34,49): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) =>
    case Var(name) =>
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
            OptimizerPreservesSemantics(rhs, env)
        else if Eval(rhs, (x) => 0) == 0 then

   |
33 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(33,36): Error: lbrace expected
   |
35 |         else if Eval(rhs, (x) => 0) == 0 then
   |         ^

ex.dfy(35,8): Error: invalid UpdateStmt
   |
35 |         else if Eval(rhs, (x) => 0) == 0 then
   |                                          ^

ex.dfy(35,41): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if Eval(rhs, (x) => 0) == 0 then\n']
['{\n']
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>

   |
30 |     case Const(_) =>
   |                     ^

ex.dfy(30,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>
    case Var(_) =>

   |
31 |     case Var(_) =>
   |                   ^

ex.dfy(31,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(lhs, rhs) =>

   |
32 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(32,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(lhs, rhs) =>
        OptimizerPreservesSemantics(lhs, env);

   |
33 |         OptimizerPreservesSemantics(lhs, env);
   |                                               ^

ex.dfy(33,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(lhs, rhs) =>
        OptimizerPreservesSemantics(lhs, env);
        OptimizerPreservesSemantics(rhs, env);

   |
34 |         OptimizerPreservesSemantics(rhs, env);
   |                                               ^

ex.dfy(34,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(lhs, rhs) =>
        OptimizerPreservesSemantics(lhs, env);
        OptimizerPreservesSemantics(rhs, env);
}

ex.dfy(32,4): Error: a postcondition could not be proved on this return path
   |
32 |     case Add(lhs, rhs) =>
   |     ^^^^

ex.dfy(27,12): Related location: this is the postcondition that could not be proved
   |
27 |     ensures Eval(e, env) == Eval(Optimize(e), env)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true

SCORE
1.0
['    requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['    ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
30 |     match e
   |            ^

ex.dfy(30,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 

   |
31 |     case Const(val) =>
   |                       ^

ex.dfy(31,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 
    case Var(name) => 

   |
32 |     case Var(name) =>
   |                      ^

ex.dfy(32,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 
    case Var(name) => 
    case Add(lhs, rhs) =>

   |
33 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 
    case Var(name) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEval(lhs, env);

   |
34 |         OptimizePreservesEval(lhs, env);
   |                                         ^

ex.dfy(34,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 
    case Var(name) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);

   |
35 |         OptimizePreservesEval(rhs, env);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Const(val) => 
    case Var(name) => 
    case Add(lhs, rhs) =>
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
}

ex.dfy(33,4): Error: a postcondition could not be proved on this return path
   |
33 |     case Add(lhs, rhs) =>
   |     ^^^^

ex.dfy(28,12): Related location: this is the postcondition that could not be proved
   |
28 |     ensures Eval(e, env) == Eval(Optimize(e), env)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>

   |
31 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(31,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if Eval(lhs, (x) => 0) == 0 then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
   |
33 |         {
   |          ^

ex.dfy(33,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then
            Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then
            Optimize(lhs)
        else
            Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    requires true
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, rhs) =>
        if Eval(lhs, (x) => 0) == 0 then
        {
            OptimizePreservesEval(rhs, env);

   |
32 |         if Eval(lhs, (x) => 0) == 0 then
   |                                     ^

ex.dfy(32,36): Error: lbrace expected
   |
34 |             OptimizePreservesEval(rhs, env);
   |                                             ^

ex.dfy(34,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['            OptimizePreservesEval(rhs, env);\n']
['{\n']
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |     case Add(lhs, Const(0)) => Optimize(lhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, Const(0)) => Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)

   |
17 |     case Add(Const(0), rhs) => Optimize(rhs)
   |                                             ^

ex.dfy(17,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))

   |
18 |     case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
   |                                                            ^

ex.dfy(18,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['    ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
25 |     match e
   |            ^

ex.dfy(25,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 

   |
26 |     case Add(lhs, Const(0)) =>
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);

   |
27 |         assert Eval(e, env) == Eval(lhs, env);
   |                                               ^

ex.dfy(27,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(e, env) == Eval(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);

   |
28 |         assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
   |                                                                   ^

ex.dfy(28,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);

   |
29 |         OptimizePreservesEval(lhs, env);
   |                                         ^

ex.dfy(29,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 

   |
30 |     case Add(Const(0), rhs) =>
   |                               ^

ex.dfy(30,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);

   |
31 |         assert Eval(e, env) == Eval(rhs, env);
   |                                               ^

ex.dfy(31,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(e, env) == Eval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);

   |
32 |         assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
   |                                                                   ^

ex.dfy(32,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);

   |
33 |         OptimizePreservesEval(rhs, env);
   |                                         ^

ex.dfy(33,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 

   |
34 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(34,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);

   |
35 |         assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
   |                                                                ^

ex.dfy(35,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);

   |
36 |         assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
   |                                                                                              ^

ex.dfy(36,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);

   |
37 |         OptimizePreservesEval(lhs, env);
   |                                         ^

ex.dfy(37,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);

   |
38 |         OptimizePreservesEval(rhs, env);
   |                                         ^

ex.dfy(38,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesEval(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>

   |
39 |     case _ =>
   |              ^

ex.dfy(39,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>
}
``` import { Injectable } from '@angular/core';

SCORE
1.0
["``` import { Injectable } from '@angular/core';\n"]
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)
    case Add(Const(0), rhs) => Optimize(rhs)
    case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e
    case Add(lhs, Const(0)) => 
        assert Eval(e, env) == Eval(lhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env);
        OptimizePreservesEval(lhs, env);
    case Add(Const(0), rhs) => 
        assert Eval(e, env) == Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(rhs), env);
        OptimizePreservesEval(rhs, env);
    case Add(lhs, rhs) => 
        assert Eval(e, env) == Eval(lhs, env) + Eval(rhs, env);
        assert Eval(Optimize(e), env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
        OptimizePreservesEval(lhs, env);
        OptimizePreservesEval(rhs, env);
    case _ =>
}
``` import { Injectable } from '@angular/core';


STATS

number of nodes: 69
number of gen nodes: 35 (including leaves: 10)
number of back nodes: 34 (including leaves: 25)

expansion count: 56 (including failed: 22)

cache stats {'hit': 44, 'miss': 175}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116, 134, 529]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46, 58, 219]


Time Statistics:

  Min: 86.00 sec, Max: 529.00 sec, Average: 182.20 sec, Standard Deviation: 139.05 sec

Call Statistics:

  Min: 33 calls, Max: 219 calls, Average: 74.90 calls, Standard Deviation: 57.08 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [87, 94, 86, 215, 88, 347, 126, 116, 134, 529]

Trial calls: [36, 42, 34, 92, 33, 137, 52, 46, 58, 219]


Time Statistics:

  Min: 86.00 sec, Max: 529.00 sec, Average: 182.20 sec, Standard Deviation: 139.05 sec

Call Statistics:

  Min: 33 calls, Max: 219 calls, Average: 74.90 calls, Standard Deviation: 57.08 calls

To complete all experiments, 31 minutes and 7 seconds elapsed.


