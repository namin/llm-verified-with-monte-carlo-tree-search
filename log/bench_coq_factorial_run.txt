

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 6 --language Coq --seed 42 


Trial  1
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.
File "./ex.v", line 4, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.
File "./ex.v", line 5, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.
File "./ex.v", line 5, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.
File "./ex.v", line 18, characters 19-20:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive AExp :=\n| AConst (n : Z)\n| AVar (x : string)\n| AAdd (e1 e2 : AExp).\n\nFixpoint eval (e : AExp) (env : string -> Z) : Z :=\n  match e with\n  | AConst n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2

File "./ex.v", line 30, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AConst _ => e\n  | AVar _ => e\n  | AAdd e1 e2 =>\n    match optimize e1, optimize e2 with\n    | AConst 0, e2 => e2\n    | e1, AConst 0 => e1\n    | e1, e2 => AAdd e1 e2\n']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.
SCORE
1.0
['    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nLemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),\n  eval e env = eval (optimize e) env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHa1.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n    rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHa1.
    rewrite IHa2.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite IHa2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 41, characters 4-19:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 11-26:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct IHexp1; destruct IHexp2; try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 40, characters 13-19:
Error: The variable IHexp1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct IHexp1; destruct IHexp2; try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite IHa1.']
['\n    rewrite IHa2.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 39, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 39, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n    rewrite IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; try simpl.
File "./ex.v", line 37, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; try simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 41, characters 4-19:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 11-26:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - destruct (optimize e0); simpl; try reflexivity.
File "./ex.v", line 38, characters 23-25:
Error: The variable e0 was not found in the current environment.


SCORE
-1.0
['\n  - destruct (optimize e0); simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - eauto.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - eauto.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - destruct n; try reflexivity.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct n; try reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1
File "./ex.v", line 31, characters 30-31:
Error:
Syntax error: '|' or ',' or ')' expected after [term level 200] (in [term]).


SCORE
None
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AConst _ => e\n  | AVar _ => e\n  | AAdd e1 e2 =>\n    match optimize e1 with\n    | AConst 0 => optimize e2\n    | _ =>\n      match optimize e2 with\n      | AConst 0 => optimize e1\n      | _ => AAdd (optimize e1']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.
SCORE
1.0
[') (optimize e2)\n      end\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x e1 e2 | e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 42, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
[' reflexivity.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 43, characters 39-43:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 45, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 42, characters 19-23:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite IHe1.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import StringNotations.
File "./ex.v", line 7, characters 7-22:
Error: Cannot find module StringNotations


SCORE
-1.0
['\nImport StringNotations.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 169
number of gen nodes: 85 (including leaves: 26)
number of back nodes: 84 (including leaves: 59)

expansion count: 151 (including failed: 67)

cache stats {'hit': 77, 'miss': 105}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360]

Trial calls: [182]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 182 calls, Average: 182.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360]

Trial calls: [182]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 182 calls, Average: 182.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.
SCORE
1.0
['PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.
SCORE
1.0
['\n\nInductive aexp :=\n  | ANum (n : nat)\n  | AVar (x : string)\n  | AAdd (e1 e2 : aexp)\n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.
File "./ex.v", line 15, characters 23-24:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint aval (env : string -> nat) (e : aexp) : nat :=\n  match e with\n    | ANum n => n\n    | AVar x => env x\n    | AAdd e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.
SCORE
1.0
['add (aval env e1) (aval env e2)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n    | AAdd (ANum 0) e2 => optimize e2\n    | AAdd e1 (ANum 0) => optimize e1\n    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n    | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),\n  aval env (optimize e) = aval env e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHa1.
File "./ex.v", line 33, characters 22-26:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
[' rewrite <- IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHa1. rewrite <- IHa2.
File "./ex.v", line 33, characters 22-26:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHa2.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 30, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp)
.

Fixpoint aval (env : string -> nat) (e : aexp) : nat :=
  match e with
    | ANum n => n
    | AVar x => env x
    | AAdd e1 e2 => Nat.add (aval env e1) (aval env e2)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
    | AAdd (ANum 0) e2 => optimize e2
    | AAdd e1 (ANum 0) => optimize e1
    | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall (e : aexp) (env : string -> nat),
  aval env (optimize e) = aval env e.
Proof.
  intros e env.
  induction e as [| n x e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 30, characters 17-40:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2 IHe1 IHe2].\n  - reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 179
number of gen nodes: 90 (including leaves: 31)
number of back nodes: 89 (including leaves: 59)

expansion count: 155 (including failed: 66)

cache stats {'hit': 146, 'miss': 69}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361]

Trial calls: [182, 215]


Time Statistics:

  Min: 360.00 sec, Max: 361.00 sec, Average: 360.50 sec, Standard Deviation: 0.50 sec

Call Statistics:

  Min: 182 calls, Max: 215 calls, Average: 198.50 calls, Standard Deviation: 16.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361]

Trial calls: [215]


Time Statistics:

  Min: 361.00 sec, Max: 361.00 sec, Average: 361.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 215 calls, Max: 215 calls, Average: 215.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360]

Trial calls: [182]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 182 calls, Average: 182.00 calls, Standard Deviation: 0.00 calls

Trial  3
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.
SCORE
1.0
['\n\nInductive Exp :=\n| Const (n : Z)\n| Var (x : string)\n| Add (e1 e2 : Exp)\n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 19, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Exp) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Exp) : Exp :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Const n *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Var x *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  (* We need to add a case for Const 0 (n0) and Const n (n) *)
  - (* Const 0 *)
    simpl.
File "./ex.v", line 43, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  (* We need to add a case for Const 0 (n0) and Const n (n) *)\n  - (* Const 0 *)\n    simpl.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  Qed.
File "./ex.v", line 43, characters 2-6:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\n  Qed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - (* Add (Const 0) e2 *)
    simpl.
File "./ex.v", line 43, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - (* Add (Const 0) e2 *)\n    simpl.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Var x *)\n    simpl.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  Qed.
File "./ex.v", line 42, characters 2-6:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\n  Qed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Var x *)\n    simpl.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n  - (* Add (Const 0) e2 *)\n    simpl.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.
File "./ex.v", line 43, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.Nat.
File "./ex.v", line 43, characters 16-26:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 43, characters 16-34:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
['add_0_r.']
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Const n *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Var x *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - (* Add e1 e2 *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.
File "./ex.v", line 39, characters 97-103:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.
File "./ex.v", line 39, characters 97-107:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 39, characters 97-115:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
Import Nat.

Inductive Exp :=
| Const (n : Z)
| Var (x : string)
| Add (e1 e2 : Exp)
.

Fixpoint eval (e : Exp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Exp) : Exp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_eval : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *) simpl. reflexivity.
  - (* Var x *) simpl. reflexivity.
  - (* Add e1 e2 *) simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 181
number of gen nodes: 91 (including leaves: 28)
number of back nodes: 90 (including leaves: 63)

expansion count: 151 (including failed: 61)

cache stats {'hit': 128, 'miss': 68}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360]

Trial calls: [182, 215, 196]


Time Statistics:

  Min: 360.00 sec, Max: 361.00 sec, Average: 360.33 sec, Standard Deviation: 0.47 sec

Call Statistics:

  Min: 182 calls, Max: 215 calls, Average: 197.67 calls, Standard Deviation: 13.52 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361]

Trial calls: [215]


Time Statistics:

  Min: 361.00 sec, Max: 361.00 sec, Average: 361.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 215 calls, Max: 215 calls, Average: 215.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360]

Trial calls: [182, 196]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 196 calls, Average: 189.00 calls, Standard Deviation: 7.00 calls

Trial  4
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['\n\nFixpoint evaluate (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall (e : Expr) (env : string -> nat),\n    evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x e1 e2 | e1 e2].\n  - (* Const *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl.
    rewrite <- IHe1.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl.
    rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 34, characters 32-36:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl. rewrite <- IHe1.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 33, characters 49-53:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n  - (* Add *) simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' reflexivity.']
['\n  - (* Add *) simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - (* Var *) simpl.']
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add (Const 0) e2 *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl. rewrite <- IHe1.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 33, characters 62-66:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add 0 e2 *) simpl.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add 0 e2 *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add 0 e2 *) simpl. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 33, characters 37-41:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add 0 e2 *) simpl. rewrite <- IHe1.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add 0 e2 *) simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 33, characters 54-58:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n  - (* Var *) simpl.']
[' reflexivity.']
['\n  - (* Add (Const 0) e2 *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl.
    rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 34, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl.
    rewrite <- IHe1.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 35, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n  - (* Add *) simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - (* Const *) simpl. reflexivity.
  - (* Var *) simpl. reflexivity.
  - (* Add (Const 0) e2 *) simpl.
    rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 30, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 34, characters 32-36:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-28:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 | e1 e2]; simpl.
File "./ex.v", line 30, characters 17-38:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x | e1 e2 | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; simpl; try reflexivity.
File "./ex.v", line 30, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl; try reflexivity.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : Expr) (env : string -> nat),
    evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; try now eauto.
File "./ex.v", line 30, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; try now eauto.']
['\n  - (* Add (Const 0) e2 *) simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2]; simpl.
File "./ex.v", line 29, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; simpl.']
['\n  induction e as [| n x e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - simpl.
File "./ex.v", line 29, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 36, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 34, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 34, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint evaluate (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
File "./ex.v", line 14, characters 17-21:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['\n\nDefinition eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.List.
File "./ex.v", line 6, characters 7-16:
Error: Cannot find module List.List


SCORE
-1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
Import Nat.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.
SCORE
1.0
['\n\nInductive aexp : Type :=\n| Const : nat -> aexp\n| Var : string -> aexp\n| Add : aexp -> aexp -> aexp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
Import Nat.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 18, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : aexp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
Import Nat.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import List.
Import Nat.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add e1 (Const 0) => optimize e1\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 163
number of gen nodes: 82 (including leaves: 28)
number of back nodes: 81 (including leaves: 54)

expansion count: 143 (including failed: 62)

cache stats {'hit': 64, 'miss': 104}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366]

Trial calls: [182, 215, 196, 168]


Time Statistics:

  Min: 360.00 sec, Max: 366.00 sec, Average: 361.75 sec, Standard Deviation: 2.49 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 190.25 calls, Standard Deviation: 17.38 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366]

Trial calls: [215, 168]


Time Statistics:

  Min: 361.00 sec, Max: 366.00 sec, Average: 363.50 sec, Standard Deviation: 2.50 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 191.50 calls, Standard Deviation: 23.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360]

Trial calls: [182, 196]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 196 calls, Average: 189.00 calls, Standard Deviation: 7.00 calls

Trial  5
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.
File "./ex.v", line 14, characters 19-23:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['\n\nDefinition eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2].
  - simpl.
File "./ex.v", line 28, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Var x *)\n    reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - (* Add (Const 0) e2 *)
    simpl.
File "./ex.v", line 37, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - (* Add (Const 0) e2 *)\n    simpl.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 28, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 167
number of gen nodes: 84 (including leaves: 28)
number of back nodes: 83 (including leaves: 56)

expansion count: 143 (including failed: 60)

cache stats {'hit': 123, 'miss': 78}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361]

Trial calls: [182, 215, 196, 168, 201]


Time Statistics:

  Min: 360.00 sec, Max: 366.00 sec, Average: 361.60 sec, Standard Deviation: 2.24 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 192.40 calls, Standard Deviation: 16.13 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361]

Trial calls: [215, 168, 201]


Time Statistics:

  Min: 361.00 sec, Max: 366.00 sec, Average: 362.67 sec, Standard Deviation: 2.36 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 194.67 calls, Standard Deviation: 19.70 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360]

Trial calls: [182, 196]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 196 calls, Average: 189.00 calls, Standard Deviation: 7.00 calls

Trial  6
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 16, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; simpl.
File "./ex.v", line 35, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 He1 He2]; simpl.
File "./ex.v", line 35, characters 17-37:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 He1 He2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 44, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 46, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 46, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 47, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - (* Add *)\n    simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const *)
    reflexivity.
  - (* Var *)
    reflexivity.
  - (* Add *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Var *)\n    reflexivity.']
['\n  - (* Add *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 35, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.
File "./ex.v", line 35, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.']
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 167
number of gen nodes: 84 (including leaves: 28)
number of back nodes: 83 (including leaves: 56)

expansion count: 142 (including failed: 59)

cache stats {'hit': 108, 'miss': 91}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361, 367]

Trial calls: [182, 215, 196, 168, 201, 199]


Time Statistics:

  Min: 360.00 sec, Max: 367.00 sec, Average: 362.50 sec, Standard Deviation: 2.87 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 193.50 calls, Standard Deviation: 14.93 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361, 367]

Trial calls: [215, 168, 201, 199]


Time Statistics:

  Min: 361.00 sec, Max: 367.00 sec, Average: 363.75 sec, Standard Deviation: 2.77 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 195.75 calls, Standard Deviation: 17.17 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360]

Trial calls: [182, 196]


Time Statistics:

  Min: 360.00 sec, Max: 360.00 sec, Average: 360.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 182 calls, Max: 196 calls, Average: 189.00 calls, Standard Deviation: 7.00 calls

Trial  7
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.
SCORE
1.0
['\n\nInductive aexp : Type :=\n  | Const : nat -> aexp\n  | Var : string -> aexp\n  | Add : aexp -> aexp -> aexp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : aexp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, e2 => e2\n    | e1, Const 0 => e1\n    | e1, e2 => Add e1 e2\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall (e : aexp) (env : string -> nat),\n    eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2).
    - destruct n.
File "./ex.v", line 41, characters 4-5:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n    destruct (optimize e1); destruct (optimize e2).\n    - destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This Coq script defines an arithmetic expression ADT, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the evaluation function.
SCORE
1.0
['\n```\n\nThis Coq script defines an arithmetic expression ADT, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the evaluation function.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive aexp : Type :=
  | Const : nat -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, e2 => e2
    | e1, Const 0 => e1
    | e1, e2 => Add e1 e2
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This Coq script defines an arithmetic expression ADT, an evaluator, an optimizer, and a proof that the optimizer preserves the semantics of the evaluation function.

STATS

number of nodes: 39
number of gen nodes: 20 (including leaves: 1)
number of back nodes: 19 (including leaves: 19)

expansion count: 20 (including failed: 1)

cache stats {'hit': 0, 'miss': 25}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361, 367, 72]

Trial calls: [182, 215, 196, 168, 201, 199, 25]


Time Statistics:

  Min: 72.00 sec, Max: 367.00 sec, Average: 321.00 sec, Standard Deviation: 101.69 sec

Call Statistics:

  Min: 25 calls, Max: 215 calls, Average: 169.43 calls, Standard Deviation: 60.56 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361, 367]

Trial calls: [215, 168, 201, 199]


Time Statistics:

  Min: 361.00 sec, Max: 367.00 sec, Average: 363.75 sec, Standard Deviation: 2.77 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 195.75 calls, Standard Deviation: 17.17 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360, 72]

Trial calls: [182, 196, 25]


Time Statistics:

  Min: 72.00 sec, Max: 360.00 sec, Average: 264.00 sec, Standard Deviation: 135.76 sec

Call Statistics:

  Min: 25 calls, Max: 196 calls, Average: 134.33 calls, Standard Deviation: 77.52 calls

Trial  8
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.
SCORE
1.0
['\n\nInductive aexp : Type :=\n| Const : nat -> aexp\n| Var : string -> aexp\n| Add : aexp -> aexp -> aexp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 15, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : aexp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-27:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 30, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 34, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  induction e as [|n x e1 e2]; simpl.']
['\nProof.']
['\n  intros e env.']
['\n  induction e.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive aexp : Type :=
| Const : nat -> aexp
| Var : string -> aexp
| Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 177
number of gen nodes: 89 (including leaves: 27)
number of back nodes: 88 (including leaves: 62)

expansion count: 148 (including failed: 60)

cache stats {'hit': 119, 'miss': 86}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361, 367, 72, 363]

Trial calls: [182, 215, 196, 168, 201, 199, 25, 205]


Time Statistics:

  Min: 72.00 sec, Max: 367.00 sec, Average: 326.25 sec, Standard Deviation: 96.13 sec

Call Statistics:

  Min: 25 calls, Max: 215 calls, Average: 173.88 calls, Standard Deviation: 57.86 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361, 367, 363]

Trial calls: [215, 168, 201, 199, 205]


Time Statistics:

  Min: 361.00 sec, Max: 367.00 sec, Average: 363.60 sec, Standard Deviation: 2.50 sec

Call Statistics:

  Min: 168 calls, Max: 215 calls, Average: 197.60 calls, Standard Deviation: 15.79 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360, 72]

Trial calls: [182, 196, 25]


Time Statistics:

  Min: 72.00 sec, Max: 360.00 sec, Average: 264.00 sec, Standard Deviation: 135.76 sec

Call Statistics:

  Min: 25 calls, Max: 196 calls, Average: 134.33 calls, Standard Deviation: 77.52 calls

Trial  9
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n    | Add (Const 0) e2 => optimize e2\n    | Add e1 (Const 0) => optimize e1\n    | Add e1 e2 => Add (optimize e1) (optimize e2)\n    | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 31, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 31, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 32, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 32, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 32, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 33, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 33, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 32, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 185
number of gen nodes: 93 (including leaves: 32)
number of back nodes: 92 (including leaves: 61)

expansion count: 161 (including failed: 69)

cache stats {'hit': 169, 'miss': 58}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361, 367, 72, 363, 361]

Trial calls: [182, 215, 196, 168, 201, 199, 25, 205, 227]


Time Statistics:

  Min: 72.00 sec, Max: 367.00 sec, Average: 330.11 sec, Standard Deviation: 91.29 sec

Call Statistics:

  Min: 25 calls, Max: 227 calls, Average: 179.78 calls, Standard Deviation: 57.05 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361, 367, 363, 361]

Trial calls: [215, 168, 201, 199, 205, 227]


Time Statistics:

  Min: 361.00 sec, Max: 367.00 sec, Average: 363.17 sec, Standard Deviation: 2.48 sec

Call Statistics:

  Min: 168 calls, Max: 227 calls, Average: 202.50 calls, Standard Deviation: 18.11 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360, 72]

Trial calls: [182, 196, 25]


Time Statistics:

  Min: 72.00 sec, Max: 360.00 sec, Average: 264.00 sec, Standard Deviation: 135.76 sec

Call Statistics:

  Min: 25 calls, Max: 196 calls, Average: 134.33 calls, Standard Deviation: 77.52 calls

Trial  10
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.
File "./ex.v", line 4, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.
SCORE
1.0
['ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e
File "./ex.v", line 17, characters 28-29:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | AVar (x : string)\n  | AAdd (e1 e2 : aexp).\n\nFixpoint evaluate (e : aexp) (env : string -> nat) : nat :=\n  match e with\n  | ANum n => n\n  | AVar x => env x\n  | AAdd e1 e2 => evaluate e']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHa1.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n  - rewrite <- IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHa1.
    rewrite <- IHa2.
File "./ex.v", line 35, characters 15-19:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHa2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2 He1 He2].
  - simpl.
File "./ex.v", line 32, characters 17-37:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2 He1 He2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.
Import List.ListNotations.

Inductive aexp : Type :=
  | ANum (n : nat)
  | AVar (x : string)
  | AAdd (e1 e2 : aexp).

Fixpoint evaluate (e : aexp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2]; simpl.
File "./ex.v", line 32, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; simpl.']
['\n  intros e env.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 173
number of gen nodes: 87 (including leaves: 31)
number of back nodes: 86 (including leaves: 56)

expansion count: 150 (including failed: 64)

cache stats {'hit': 115, 'miss': 101}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 361, 360, 366, 361, 367, 72, 363, 361, 360]

Trial calls: [182, 215, 196, 168, 201, 199, 25, 205, 227, 216]


Time Statistics:

  Min: 72.00 sec, Max: 367.00 sec, Average: 333.10 sec, Standard Deviation: 87.07 sec

Call Statistics:

  Min: 25 calls, Max: 227 calls, Average: 183.40 calls, Standard Deviation: 55.20 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [361, 366, 361, 367, 363, 361]

Trial calls: [215, 168, 201, 199, 205, 227]


Time Statistics:

  Min: 361.00 sec, Max: 367.00 sec, Average: 363.17 sec, Standard Deviation: 2.48 sec

Call Statistics:

  Min: 168 calls, Max: 227 calls, Average: 202.50 calls, Standard Deviation: 18.11 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [360, 360, 72, 360]

Trial calls: [182, 196, 25, 216]


Time Statistics:

  Min: 72.00 sec, Max: 360.00 sec, Average: 288.00 sec, Standard Deviation: 124.71 sec

Call Statistics:

  Min: 25 calls, Max: 216 calls, Average: 154.75 calls, Standard Deviation: 75.88 calls

To complete all experiments, 56 minutes and 25 seconds elapsed.


