

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_opt0 --remove_hints True --seed 42 --base_model_name ./my_dpo_model 


[2024-01-13 00:37:33,361] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)

SCORE
1.0
['  | Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
8 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(8,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {

  |
9 |   match e {
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n

   |
10 |     case Const(n) => n
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)

   |
11 |     case Var(name) => env(name)
   |                                ^

ex.dfy(11,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
12 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
17 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(17,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {

   |
18 |   match e {
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 

   |
19 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(19,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);

   |
20 |       var o1 := optimize(e1);
   |                              ^

ex.dfy(20,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var o1 := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);

   |
21 |       var o2 := optimize(e2);
   |                              ^

ex.dfy(21,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var o2 := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2

   |
22 |       if o1 == Const(0) then o2
   |                                ^

ex.dfy(22,31): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if o1 == Const(0) then o2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1

   |
23 |       else if o2 == Const(0) then o1
   |                                     ^

ex.dfy(23,36): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if o2 == Const(0) then o1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)

   |
24 |       else Add(o1, o2)
   |                       ^

ex.dfy(24,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else Add(o1, o2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e

   |
25 |     case _ => e
   |                ^

ex.dfy(25,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }

   |
26 |   }
   |    ^

ex.dfy(26,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics

SCORE
1.0
['// Lemma: the optimizer preserves the semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
32 | {
   |  ^

ex.dfy(32,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
33 |   match e {
   |            ^

ex.dfy(33,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 

   |
34 |     case Const(_) =>
   |                     ^

ex.dfy(34,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 

   |
35 |     case Var(_) =>
   |                   ^

ex.dfy(35,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>

   |
36 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(36,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(e) := optimize(Add(e1, e2));

   |
37 |       optimize(e) := optimize(Add(e1, e2));
   |                                            ^

ex.dfy(37,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      optimize(e) := optimize(Add(e1, e2));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(e) := optimize(Add(e1, e2));
      OptimizerSemantics(e1, env);

   |
38 |       OptimizerSemantics(e1, env);
   |                                   ^

ex.dfy(38,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(e) := optimize(Add(e1, e2));
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);

   |
39 |       OptimizerSemantics(e2, env);
   |                                   ^

ex.dfy(39,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(e) := optimize(Add(e1, e2));
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }

   |
40 |   }
   |    ^

ex.dfy(40,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(e) := optimize(Add(e1, e2));
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
}

   |
37 |       optimize(e) := optimize(Add(e1, e2));
   |       ^^^^^^^^

ex.dfy(37,6): Error: LHS of assignment must denote a mutable variable or field
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions

   |
34 |     case Const(_) => () // Base case: constants have no sub-expressions
   |                                                                        ^

ex.dfy(34,71): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => () // Base case: constants have no sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions
    case Var(_) => () // Base case: variables have no sub-expressions

   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |     ^

ex.dfy(35,4): Error: invalid Suffix
   |
34 |     case Const(_) => () // Base case: constants have no sub-expressions
   |                      ^

ex.dfy(34,21): Error: missing semicolon at end of statement
   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |                                                                      ^

ex.dfy(35,69): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => () // Base case: variables have no sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions
    case Var(_) => () // Base case: variables have no sub-expressions
    case Add(e1, e2) => 

   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |     ^

ex.dfy(35,4): Error: invalid Suffix
   |
34 |     case Const(_) => () // Base case: constants have no sub-expressions
   |                      ^

ex.dfy(34,21): Error: missing semicolon at end of statement
   |
36 |     case Add(e1, e2) =>
   |     ^

ex.dfy(36,4): Error: invalid Suffix
   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |                    ^

ex.dfy(35,19): Error: missing semicolon at end of statement
   |
36 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(36,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions
    case Var(_) => () // Base case: variables have no sub-expressions
    case Add(e1, e2) => 
      // Recursive case: optimize the sub-expressions and prove the lemma by induction

   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |     ^

ex.dfy(35,4): Error: invalid Suffix
   |
34 |     case Const(_) => () // Base case: constants have no sub-expressions
   |                      ^

ex.dfy(34,21): Error: missing semicolon at end of statement
   |
36 |     case Add(e1, e2) => 
   |     ^

ex.dfy(36,4): Error: invalid Suffix
   |
35 |     case Var(_) => () // Base case: variables have no sub-expressions
   |                    ^

ex.dfy(35,19): Error: missing semicolon at end of statement
   |
37 |       // Recursive case: optimize the sub-expressions and prove the lemma by induction
   |                                                                                       ^

ex.dfy(37,86): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      // Recursive case: optimize the sub-expressions and prove the lemma by induction\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => \n']
['    case Var(_) => \n']
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);

   |
37 |       OptimizerSemantics(e1, env);
   |                                   ^

ex.dfy(37,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);

   |
38 |       OptimizerSemantics(e2, env);
   |                                   ^

ex.dfy(38,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }

   |
39 |   }
   |    ^

ex.dfy(39,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
  // Base case: if e is an addition, then it must have been recursively checked

   |
40 |   // Base case: if e is an addition, then it must have been recursively checked
   |                                                                                ^

ex.dfy(40,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if e is an addition, then it must have been recursively checked\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
  // Base case: if e is an addition, then it must have been recursively checked
  // Inductive case: if e is a constant or a variable, then the proof is trivial

   |
41 |   // Inductive case: if e is a constant or a variable, then the proof is trivial
   |                                                                                 ^

ex.dfy(41,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: if e is a constant or a variable, then the proof is trivial\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
  // Base case: if e is an addition, then it must have been recursively checked
  // Inductive case: if e is a constant or a variable, then the proof is trivial
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
  // Base case: if e is an addition, then it must have been recursively checked
  // Inductive case: if e is a constant or a variable, then the proof is trivial
}
``` using System;

SCORE
1.0
['``` \ufeffusing System;\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var o1 := optimize(e1);
      var o2 := optimize(e2);
      if o1 == Const(0) then o2
      else if o2 == Const(0) then o1
      else Add(o1, o2)
    case _ => e
  }
}

// Lemma: the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerSemantics(e1, env);
      OptimizerSemantics(e2, env);
  }
  // Base case: if e is an addition, then it must have been recursively checked
  // Inductive case: if e is a constant or a variable, then the proof is trivial
}
``` using System;


STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 2)
number of back nodes: 17 (including leaves: 16)

expansion count: 19 (including failed: 2)

cache stats {'hit': 8, 'miss': 52}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127]

Trial calls: [60]


Time Statistics:

  Min: 127.00 sec, Max: 127.00 sec, Average: 127.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 60 calls, Max: 60 calls, Average: 60.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127]

Trial calls: [60]


Time Statistics:

  Min: 127.00 sec, Max: 127.00 sec, Average: 127.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 60 calls, Max: 60 calls, Average: 60.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)

SCORE
1.0
['    Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

SCORE
1.0
['  | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: func(string) returns (int)): int

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
2 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: func(string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: func(string) returns (int)): int
{

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: func(string) returns (int)): int
{
    match e

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {

  |
8 | function evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(8,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {

  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val,

   |
10 |         Const(val) => val,
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Const(val) => val,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val,
        Var(name) => env(name),

   |
10 |         Const(val) => val,
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Var(name) => env(name),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val,
        Var(name) => env(name),
        Add(left, right) => evaluate(left, env) + evaluate(right, env),

   |
10 |         Const(val) => val,
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        Add(left, right) => evaluate(left, env) + evaluate(right, env),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions

SCORE
1.0
['// Evaluator for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int {

  |
8 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(8,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int {
    match e {

  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)
        Add(left, right) => eval(left, env) + eval(right, env)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        Add(left, right) => eval(left, env) + eval(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string => int): int

  |
8 | function eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string => int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string => int): int
{

  |
8 | function eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string => int): int
{
  match e

  |
8 | function eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
   |
10 |   match e
   |          ^

ex.dfy(10,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
['\n']
['// Evaluator for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string -> int): int {

  |
8 | function evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(8,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string -> int): int {
    match e {

  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)
        Add(left, right) => evaluate(left, env) + evaluate(right, env)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        Add(left, right) => evaluate(left, env) + evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: func(string) returns (int)): int {

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                                                   ^

ex.dfy(8,66): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: func(string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: func(string) returns (int)): int {
    match e {

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: func(string) returns (int)): int {
    match e {
        case Const(val) => val

  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                     ^

ex.dfy(8,36): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: func(string) returns (int)): int {
  |                                              ^

ex.dfy(8,45): Error: this symbol not expected in FunctionSpec
   |
10 |         case Const(val) => val
   |                               ^

ex.dfy(10,30): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        case Const(val) => val\n']
['function evaluate(e: Expr, env: string -> int): int {\n']
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
    match e {
        Const(val) => val
        Var(name) => env(name)
        Add(left, right) => evaluate(left, env) + evaluate(right, env)

   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        Add(left, right) => evaluate(left, env) + evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int {

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                                                ^

ex.dfy(8,63): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: func (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int {
    match e {

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int {
    match e {
        Const(val) => val

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int {
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
   |
10 |         Const(val) => val
   |         ^

ex.dfy(10,8): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
2 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: func (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int
{

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func (string) returns (int)): int
{
  match e

  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                  ^

ex.dfy(8,33): Error: closeparen expected
  |
8 | function eval(e: Expr, env: func (string) returns (int)): int
  |                                           ^

ex.dfy(8,42): Error: this symbol not expected in FunctionSpec
   |
10 |   match e
   |          ^

ex.dfy(10,9): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions

SCORE
1.0
['// Evaluator for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int

SCORE
1.0
['function eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e

   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

   |
11 |     case Const(val) => val
   |                           ^

ex.dfy(11,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

   |
12 |     case Var(name) => env(name)
   |                                ^

ex.dfy(12,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
13 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(13,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions

SCORE
1.0
['// Optimizer for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr

SCORE
1.0
['function optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e

   |
19 |     match e
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>

   |
20 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(20,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);

   |
21 |         var e1_opt := optimize(e1);
   |                                    ^

ex.dfy(21,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

   |
22 |         var e2_opt := optimize(e2);
   |                                    ^

ex.dfy(22,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt

   |
23 |         if e1_opt == Const(0) then e2_opt
   |                                          ^

ex.dfy(23,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt

   |
24 |         else if e2_opt == Const(0) then e1_opt
   |                                               ^

ex.dfy(24,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)

   |
25 |         else Add(e1_opt, e2_opt)
   |                                 ^

ex.dfy(25,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e

   |
26 |     case _ => e
   |                ^

ex.dfy(26,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics as defined by the evaluation function.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['    ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{

   |
32 | {
   |  ^

ex.dfy(32,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e

   |
33 |     match e
   |            ^

ex.dfy(33,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>

   |
34 |     case Const(_) =>
   |                     ^

ex.dfy(34,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>

   |
35 |     case Var(_) =>
   |                   ^

ex.dfy(35,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
36 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(36,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2

   |
37 |         // Optimize e1 and e2
   |                              ^

ex.dfy(37,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Optimize e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);

   |
38 |         var e1_opt := optimize(e1);
   |                                    ^

ex.dfy(38,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

   |
39 |         var e2_opt := optimize(e2);
   |                                    ^

ex.dfy(39,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);


   |
39 |         var e2_opt := optimize(e2);
   |                                    ^

ex.dfy(39,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2

   |
41 |         // Recursively prove the lemma for e1 and e2
   |                                                     ^

ex.dfy(41,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursively prove the lemma for e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);

   |
42 |         OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(42,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

   |
43 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(43,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);


   |
43 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(43,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Prove that the optimized addition preserves the semantics

   |
45 |         // Prove that the optimized addition preserves the semantics
   |                                                                     ^

ex.dfy(45,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Prove that the optimized addition preserves the semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Prove that the optimized addition preserves the semantics
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);

   |
46 |         assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
   |                                                                         ^

ex.dfy(46,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Prove that the optimized addition preserves the semantics
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
        if e1_opt == Const(0) then

   |
47 |         if e1_opt == Const(0) then
   |                               ^

ex.dfy(47,30): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if e1_opt == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Prove that the optimized addition preserves the semantics
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
        if e1_opt == Const(0) then
            assert eval(e2_opt, env) == eval(e2, env)

   |
47 |         if e1_opt == Const(0) then
   |                               ^

ex.dfy(47,30): Error: lbrace expected
   |
48 |             assert eval(e2_opt, env) == eval(e2, env)
   |                                                      ^

ex.dfy(48,53): Error: invalid AssertStmt
2 parse errors detected in ex.dfy

SCORE
None
['            assert eval(e2_opt, env) == eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize e1 and e2
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Recursively prove the lemma for e1 and e2
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Prove that the optimized addition preserves the semantics
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
        if e1_opt == Const(0) then
            assert eval(e2_opt, env) == eval(e2, env)
        else if e2_opt == Const(0) then

   |
47 |         if e1_opt == Const(0) then
   |                               ^

ex.dfy(47,30): Error: lbrace expected
   |
49 |         else if e2_opt == Const(0) then
   |         ^

ex.dfy(49,8): Error: invalid AssertStmt
   |
49 |         else if e2_opt == Const(0) then
   |                                    ^

ex.dfy(49,35): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if e2_opt == Const(0) then\n']
['{\n']
['    match e\n']
['    case Const(_) =>\n']
['    case Var(_) =>\n']
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions

   |
37 |         // Optimize sub-expressions
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Optimize sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);

   |
38 |         var e1_opt := optimize(e1);
   |                                    ^

ex.dfy(38,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

   |
39 |         var e2_opt := optimize(e2);
   |                                    ^

ex.dfy(39,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);


   |
39 |         var e2_opt := optimize(e2);
   |                                    ^

ex.dfy(39,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions

   |
41 |         // Preserve semantics for sub-expressions
   |                                                  ^

ex.dfy(41,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Preserve semantics for sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);

   |
42 |         OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(42,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

   |
43 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(43,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);


   |
43 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(43,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Preserve semantics for addition

   |
45 |         // Preserve semantics for addition
   |                                           ^

ex.dfy(45,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Preserve semantics for addition\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Preserve semantics for addition
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);

   |
46 |         assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
   |                                                                         ^

ex.dfy(46,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Preserve semantics for addition
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Preserve semantics for addition
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
    Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

// Optimizer for arithmetic expressions
function optimize(e: Expr): Expr
{
    match e
    case Add(e1, e2) =>
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);
        if e1_opt == Const(0) then e2_opt
        else if e2_opt == Const(0) then e1_opt
        else Add(e1_opt, e2_opt)
    case _ => e
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
        // Optimize sub-expressions
        var e1_opt := optimize(e1);
        var e2_opt := optimize(e2);

        // Preserve semantics for sub-expressions
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

        // Preserve semantics for addition
        assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
}
```


STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 5)
number of back nodes: 25 (including leaves: 21)

expansion count: 35 (including failed: 10)

cache stats {'hit': 9, 'miss': 99}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218]

Trial calls: [60, 108]


Time Statistics:

  Min: 127.00 sec, Max: 218.00 sec, Average: 172.50 sec, Standard Deviation: 45.50 sec

Call Statistics:

  Min: 60 calls, Max: 108 calls, Average: 84.00 calls, Standard Deviation: 24.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218]

Trial calls: [60, 108]


Time Statistics:

  Min: 127.00 sec, Max: 218.00 sec, Average: 172.50 sec, Standard Deviation: 45.50 sec

Call Statistics:

  Min: 60 calls, Max: 108 calls, Average: 84.00 calls, Standard Deviation: 24.00 calls

Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT

SCORE
1.0
['// Arithmetic expressions ADT\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
2 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: func (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int
{

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int
{
  match e

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
7 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(7,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {

  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val

  |
9 |         case Const(val) => val
  |                               ^

ex.dfy(9,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)

   |
10 |         case Var(name) => env(name)
   |                                    ^

ex.dfy(10,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
11 |         case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                          ^

ex.dfy(11,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
16 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {

   |
17 |     match e {
   |              ^

ex.dfy(17,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 

   |
18 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(18,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);

   |
19 |             var e1_opt := optimize(e1);
   |                                        ^

ex.dfy(19,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

   |
20 |             var e2_opt := optimize(e2);
   |                                        ^

ex.dfy(20,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt

   |
21 |             if e1_opt == Const(0) then e2_opt
   |                                              ^

ex.dfy(21,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt

   |
22 |             else if e2_opt == Const(0) then e1_opt
   |                                                   ^

ex.dfy(22,50): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)

   |
23 |             else Add(e1_opt, e2_opt)
   |                                     ^

ex.dfy(23,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e

   |
24 |         case _ => e
   |                    ^

ex.dfy(24,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }

   |
25 |     }
   |      ^

ex.dfy(25,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics as defined by the evaluation function.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['    ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {

   |
32 |     match e {
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>

   |
33 |         case Const(_) =>
   |                         ^

ex.dfy(33,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>

   |
34 |         case Var(_) =>
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>

   |
35 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);

   |
36 |             var e1_opt := optimize(e1);
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

   |
37 |             var e2_opt := optimize(e2);
   |                                        ^

ex.dfy(37,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);

   |
38 |             OptimizerSemantics(e1, env);
   |                                         ^

ex.dfy(38,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);

   |
39 |             OptimizerSemantics(e2, env);
   |                                         ^

ex.dfy(39,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);

   |
40 |             assert eval(e1_opt, env) == eval(e1, env);
   |                                                       ^

ex.dfy(40,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert eval(e1_opt, env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);
            assert eval(e2_opt, env) == eval(e2, env);

   |
41 |             assert eval(e2_opt, env) == eval(e2, env);
   |                                                       ^

ex.dfy(41,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert eval(e2_opt, env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);
            assert eval(e2_opt, env) == eval(e2, env);
    }

   |
42 |     }
   |      ^

ex.dfy(42,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);
            assert eval(e2_opt, env) == eval(e2, env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);
            assert eval(e2_opt, env) == eval(e2, env);
    }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Arithmetic expressions ADT
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
            assert eval(e1_opt, env) == eval(e1, env);
            assert eval(e2_opt, env) == eval(e2, env);
    }
}
```


STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 1)
number of back nodes: 16 (including leaves: 16)

expansion count: 17 (including failed: 1)

cache stats {'hit': 0, 'miss': 47}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108]

Trial calls: [60, 108, 47]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 151.00 sec, Standard Deviation: 48.01 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 71.67 calls, Standard Deviation: 26.23 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108]

Trial calls: [60, 108, 47]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 151.00 sec, Standard Deviation: 48.01 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 71.67 calls, Standard Deviation: 26.23 calls

Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)

SCORE
1.0
['datatype Expr = Const(v: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)

SCORE
1.0
['              | Var(n: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr);

  |
4 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(4,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['              | Add(e1: Expr, e2: Expr);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr);


  |
4 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(4,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr);

// Evaluator

  |
4 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(4,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
-1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int {

  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                 ^

ex.dfy(7,32): Error: closeparen expected
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                          ^

ex.dfy(7,41): Error: this symbol not expected in FunctionSpec
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                                               ^

ex.dfy(7,62): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: func(string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int {
    match e {

  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                 ^

ex.dfy(7,32): Error: closeparen expected
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                          ^

ex.dfy(7,41): Error: this symbol not expected in FunctionSpec
  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int {
    match e {
        case Const(v) => v

  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                 ^

ex.dfy(7,32): Error: closeparen expected
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                          ^

ex.dfy(7,41): Error: this symbol not expected in FunctionSpec
  |
9 |         case Const(v) => v
  |                           ^

ex.dfy(9,26): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        case Const(v) => v\n']
['function eval(e: Expr, env: func(string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int {
  match e {

  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                 ^

ex.dfy(7,32): Error: closeparen expected
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                          ^

ex.dfy(7,41): Error: this symbol not expected in FunctionSpec
  |
8 |   match e {
  |            ^

ex.dfy(8,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int {
  match e {
    case Const(v) => v

  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                 ^

ex.dfy(7,32): Error: closeparen expected
  |
7 | function eval(e: Expr, env: func(string) returns (int)): int {
  |                                          ^

ex.dfy(7,41): Error: this symbol not expected in FunctionSpec
  |
9 |     case Const(v) => v
  |                       ^

ex.dfy(9,22): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(v) => v\n']
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
7 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(7,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {

  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v

  |
9 |         case Const(v) => v
  |                           ^

ex.dfy(9,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)

   |
10 |         case Var(n) => env(n)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(n) => env(n)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
11 |         case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                          ^

ex.dfy(11,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
16 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {

   |
17 |     match e {
   |              ^

ex.dfy(17,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 

   |
18 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(18,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);

   |
19 |             var e1_opt := optimize(e1);
   |                                        ^

ex.dfy(19,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

   |
20 |             var e2_opt := optimize(e2);
   |                                        ^

ex.dfy(20,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt

   |
21 |             if e1_opt == Const(0) then e2_opt
   |                                              ^

ex.dfy(21,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt

   |
22 |             else if e2_opt == Const(0) then e1_opt
   |                                                   ^

ex.dfy(22,50): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)

   |
23 |             else Add(e1_opt, e2_opt)
   |                                     ^

ex.dfy(23,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e

   |
24 |         case _ => e
   |                    ^

ex.dfy(24,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }

   |
25 |     }
   |      ^

ex.dfy(25,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics of the evaluation function.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['    ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {

   |
32 |     match e {
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>

   |
33 |         case Const(_) =>
   |                         ^

ex.dfy(33,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>

   |
34 |         case Var(_) =>
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>

   |
35 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2

   |
36 |             // Optimize e1 and e2
   |                                  ^

ex.dfy(36,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            // Optimize e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);

   |
37 |             var e1_opt := optimize(e1);
   |                                        ^

ex.dfy(37,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

   |
38 |             var e2_opt := optimize(e2);
   |                                        ^

ex.dfy(38,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);


   |
38 |             var e2_opt := optimize(e2);
   |                                        ^

ex.dfy(38,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2

   |
40 |             // Recursive call on e1 and e2
   |                                           ^

ex.dfy(40,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            // Recursive call on e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);

   |
41 |             OptimizerPreservesSemantics(e1, env);
   |                                                  ^

ex.dfy(41,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

   |
42 |             OptimizerPreservesSemantics(e2, env);
   |                                                  ^

ex.dfy(42,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);


   |
42 |             OptimizerPreservesSemantics(e2, env);
   |                                                  ^

ex.dfy(42,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition

   |
44 |             // Preserve the semantics of addition
   |                                                  ^

ex.dfy(44,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            // Preserve the semantics of addition\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition
            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);

   |
45 |             assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
   |                                                                             ^

ex.dfy(45,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition
            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
    }

   |
46 |     }
   |      ^

ex.dfy(46,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition
            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition
            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
    }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(v) => v
        case Var(n) => env(n)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

// Lemma: The optimizer preserves the semantics of the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            // Optimize e1 and e2
            var e1_opt := optimize(e1);
            var e2_opt := optimize(e2);

            // Recursive call on e1 and e2
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

            // Preserve the semantics of addition
            assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
    }
}
```


STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 2)
number of back nodes: 17 (including leaves: 16)

expansion count: 20 (including failed: 3)

cache stats {'hit': 2, 'miss': 56}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125]

Trial calls: [60, 108, 47, 58]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 144.50 sec, Standard Deviation: 43.07 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 68.25 calls, Standard Deviation: 23.48 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125]

Trial calls: [60, 108, 47, 58]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 144.50 sec, Standard Deviation: 43.07 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 68.25 calls, Standard Deviation: 23.48 calls

Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)

SCORE
1.0
['  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int

SCORE
1.0
['function eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

   |
10 |   case Const(val) => val
   |                         ^

ex.dfy(10,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

   |
11 |   case Var(name) => env(name)
   |                              ^

ex.dfy(11,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
12 |   case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                    ^

ex.dfy(12,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr

SCORE
1.0
['function optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e

   |
18 |   match e
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>

   |
19 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(19,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);

   |
20 |     var e1_opt := optimize(e1);
   |                                ^

ex.dfy(20,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);

   |
21 |     var e2_opt := optimize(e2);
   |                                ^

ex.dfy(21,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt

   |
22 |     if e1_opt == Const(0) then e2_opt
   |                                      ^

ex.dfy(22,37): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt

   |
23 |     else if e2_opt == Const(0) then e1_opt
   |                                           ^

ex.dfy(23,42): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)

   |
24 |     else Add(e1_opt, e2_opt)
   |                             ^

ex.dfy(24,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e

   |
25 |   case _ => e
   |              ^

ex.dfy(25,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e

   |
32 |   match e
   |          ^

ex.dfy(32,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>

   |
33 |   case Const(_) =>
   |                   ^

ex.dfy(33,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>

   |
34 |   case Var(_) =>
   |                 ^

ex.dfy(34,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>

   |
35 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(35,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {

   |
36 |     {
   |      ^

ex.dfy(36,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);

   |
37 |       var e1_opt := optimize(e1);
   |                                  ^

ex.dfy(37,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);

   |
38 |       var e2_opt := optimize(e2);
   |                                  ^

ex.dfy(38,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);

   |
39 |       assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
   |                                                                       ^

ex.dfy(39,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);

   |
40 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(40,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
41 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(41,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    }

   |
42 |     }
   |      ^

ex.dfy(42,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    }
}
``` import { Component, OnInit, OnDestroy } from '@angular/core';

SCORE
1.0
["``` import { Component, OnInit, OnDestroy } from '@angular/core';\n"]
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)
```

```dafny
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}
```

```dafny
function optimize(e: Expr): Expr
{
  match e
  case Add(e1, e2) =>
    var e1_opt := optimize(e1);
    var e2_opt := optimize(e2);
    if e1_opt == Const(0) then e2_opt
    else if e2_opt == Const(0) then e1_opt
    else Add(e1_opt, e2_opt)
  case _ => e
}
```

```dafny
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e
  case Const(_) =>
  case Var(_) =>
  case Add(e1, e2) =>
    {
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      assert eval(Add(e1_opt, e2_opt), env) == eval(Add(e1, e2), env);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    }
}
``` import { Component, OnInit, OnDestroy } from '@angular/core';


STATS

number of nodes: 41
number of gen nodes: 21 (including leaves: 1)
number of back nodes: 20 (including leaves: 20)

expansion count: 20 (including failed: 0)

cache stats {'hit': 0, 'miss': 47}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114]

Trial calls: [60, 108, 47, 58, 47]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 138.40 sec, Standard Deviation: 40.41 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 64.00 calls, Standard Deviation: 22.65 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114]

Trial calls: [60, 108, 47, 58, 47]


Time Statistics:

  Min: 108.00 sec, Max: 218.00 sec, Average: 138.40 sec, Standard Deviation: 40.41 sec

Call Statistics:

  Min: 47 calls, Max: 108 calls, Average: 64.00 calls, Standard Deviation: 22.65 calls

Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 

SCORE
1.0
['  | Const(i: int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 

SCORE
1.0
['  | Var(name: string) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
6 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(6,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i

  |
8 |     case Const(i) => i
  |                       ^

ex.dfy(8,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
10 |     case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                      ^

ex.dfy(10,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }

   |
11 |   }
   |    ^

ex.dfy(11,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {

   |
14 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 

   |
16 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(16,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);

   |
17 |       var e1_opt := Optimize(e1);
   |                                  ^

ex.dfy(17,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var e1_opt := Optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);

   |
18 |       var e2_opt := Optimize(e2);
   |                                  ^

ex.dfy(18,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var e2_opt := Optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt

   |
19 |       if e1_opt == Const(0) then e2_opt
   |                                        ^

ex.dfy(19,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt

   |
20 |       else if e2_opt == Const(0) then e1_opt
   |                                             ^

ex.dfy(20,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)

   |
21 |       else Add(e1_opt, e2_opt)
   |                               ^

ex.dfy(21,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e

   |
22 |     case _ => e
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }

   |
23 |   }
   |    ^

ex.dfy(23,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {

   |
29 |   match e {
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 

   |
30 |     case Const(_) =>
   |                     ^

ex.dfy(30,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 

   |
31 |     case Var(_) =>
   |                   ^

ex.dfy(31,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>

   |
32 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(32,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
33 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(33,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);

   |
34 |       OptimizePreservesSemantics(e2, env);
   |                                           ^

ex.dfy(34,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }

   |
35 |   }
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
  // Add additional proof steps as needed

   |
36 |   // Add additional proof steps as needed
   |                                          ^

ex.dfy(36,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Add additional proof steps as needed\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
  // Add additional proof steps as needed
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
  // Add additional proof steps as needed
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = 
  | Const(i: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := Optimize(e1);
      var e2_opt := Optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
  // Add additional proof steps as needed
}
```


STATS

number of nodes: 25
number of gen nodes: 13 (including leaves: 1)
number of back nodes: 12 (including leaves: 12)

expansion count: 12 (including failed: 0)

cache stats {'hit': 0, 'miss': 38}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86]

Trial calls: [60, 108, 47, 58, 47, 38]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 129.67 sec, Standard Deviation: 41.74 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 59.67 calls, Standard Deviation: 22.84 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86]

Trial calls: [60, 108, 47, 58, 47, 38]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 129.67 sec, Standard Deviation: 41.74 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 59.67 calls, Standard Deviation: 22.84 calls

Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr = Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)

SCORE
1.0
['              | Var(x: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function int Evaluate(e: Expr, env: func(string) returns (int)): int

  |
5 | function int Evaluate(e: Expr, env: func(string) returns (int)): int
  |          ^

ex.dfy(5,9): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['function int Evaluate(e: Expr, env: func(string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function int Evaluate(e: Expr, env: func(string) returns (int)): int
{

  |
5 | function int Evaluate(e: Expr, env: func(string) returns (int)): int
  |          ^

ex.dfy(5,9): Error: invalid NoUSIdentOrDigits
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function int Evaluate(e: Expr, env: func(string) returns (int)): int
{
    match e

  |
5 | function int Evaluate(e: Expr, env: func(string) returns (int)): int
  |          ^

ex.dfy(5,9): Error: invalid NoUSIdentOrDigits
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {

  |
6 |     match e {
  |              ^

ex.dfy(6,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n

  |
7 |         case Const(n) => n
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)

  |
8 |         case Var(x) => env(x)
  |                              ^

ex.dfy(8,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(x) => env(x)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

  |
9 |         case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  |                                                          ^

ex.dfy(9,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }

   |
10 |     }
   |      ^

ex.dfy(10,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {

   |
14 |     match e {
   |              ^

ex.dfy(14,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>

   |
15 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(15,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);

   |
16 |             var e1_opt := Optimize(e1);
   |                                        ^

ex.dfy(16,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e1_opt := Optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);

   |
17 |             var e2_opt := Optimize(e2);
   |                                        ^

ex.dfy(17,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var e2_opt := Optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt

   |
18 |             if e1_opt == Const(0) then e2_opt
   |                                              ^

ex.dfy(18,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt

   |
19 |             else if e2_opt == Const(0) then e1_opt
   |                                                   ^

ex.dfy(19,50): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)

   |
20 |             else Add(e1_opt, e2_opt)
   |                                     ^

ex.dfy(20,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e

   |
21 |         case _ => e
   |                    ^

ex.dfy(21,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }

   |
22 |     }
   |      ^

ex.dfy(22,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['    ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {

   |
28 |     match e {
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>

   |
29 |         case Const(_) =>
   |                         ^

ex.dfy(29,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>

   |
30 |         case Var(_) =>
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>

   |
31 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);

   |
32 |             OptimizePreservesSemantics(e1, env);
   |                                                 ^

ex.dfy(32,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);

   |
33 |             OptimizePreservesSemantics(e2, env);
   |                                                 ^

ex.dfy(33,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }
    // base case

   |
35 |     // base case
   |                 ^

ex.dfy(35,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }
    // base case
    assert Eval(Optimize(e), env) == Eval(e, env);

   |
36 |     assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                   ^

ex.dfy(36,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }
    // base case
    assert Eval(Optimize(e), env) == Eval(e, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }
    // base case
    assert Eval(Optimize(e), env) == Eval(e, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e {
        case Const(n) => n
        case Var(x) => env(x)
        case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
    }
}

function Optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) =>
            var e1_opt := Optimize(e1);
            var e2_opt := Optimize(e2);
            if e1_opt == Const(0) then e2_opt
            else if e2_opt == Const(0) then e1_opt
            else Add(e1_opt, e2_opt)
        case _ => e
    }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizePreservesSemantics(e1, env);
            OptimizePreservesSemantics(e2, env);
    }
    // base case
    assert Eval(Optimize(e), env) == Eval(e, env);
}
```


STATS

number of nodes: 25
number of gen nodes: 13 (including leaves: 1)
number of back nodes: 12 (including leaves: 12)

expansion count: 13 (including failed: 1)

cache stats {'hit': 0, 'miss': 41}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92]

Trial calls: [60, 108, 47, 58, 47, 38, 41]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 124.29 sec, Standard Deviation: 40.83 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 57.00 calls, Standard Deviation: 22.13 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92]

Trial calls: [60, 108, 47, 58, 47, 38, 41]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 124.29 sec, Standard Deviation: 40.83 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 57.00 calls, Standard Deviation: 22.13 calls

Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int

  |
7 | function evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(7,39): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string => int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int
{

  |
7 | function evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(7,39): Error: closeparen expected
  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int
{
    match e

  |
7 | function evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(7,39): Error: closeparen expected
  |
9 |     match e
  |            ^

ex.dfy(9,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int {

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                                                    ^

ex.dfy(7,67): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: func (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int {
    match e {

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: func (string) returns (int)): int {
    match e {
        case Const(val) => val

  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                      ^

ex.dfy(7,37): Error: closeparen expected
  |
7 | function evaluate(e: Expr, env: func (string) returns (int)): int {
  |                                               ^

ex.dfy(7,46): Error: this symbol not expected in FunctionSpec
  |
9 |         case Const(val) => val
  |                               ^

ex.dfy(9,30): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        case Const(val) => val\n']
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
7 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(7,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {

  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val

  |
9 |         case Const(val) => val
  |                               ^

ex.dfy(9,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)

   |
10 |         case Var(name) => env(name)
   |                                    ^

ex.dfy(10,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
11 |         case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                          ^

ex.dfy(11,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
16 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {

   |
17 |     match e {
   |              ^

ex.dfy(17,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 

   |
18 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(18,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);

   |
19 |             var o1 := optimize(e1);
   |                                    ^

ex.dfy(19,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var o1 := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);

   |
20 |             var o2 := optimize(e2);
   |                                    ^

ex.dfy(20,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            var o2 := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2

   |
21 |             if o1 == Const(0) then o2
   |                                      ^

ex.dfy(21,37): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if o1 == Const(0) then o2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1

   |
22 |             else if o2 == Const(0) then o1
   |                                           ^

ex.dfy(22,42): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if o2 == Const(0) then o1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)

   |
23 |             else Add(o1, o2)
   |                             ^

ex.dfy(23,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else Add(o1, o2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e

   |
24 |         case _ => e
   |                    ^

ex.dfy(24,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }

   |
25 |     }
   |      ^

ex.dfy(25,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics

SCORE
1.0
['// Lemma to prove that the optimizer preserves semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['    ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {

   |
32 |     match e {
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>

   |
33 |         case Const(_) =>
   |                         ^

ex.dfy(33,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>

   |
34 |         case Var(_) =>
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>

   |
35 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);

   |
36 |             var o1 := optimize(e1);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var o1 := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);

   |
37 |             var o2 := optimize(e2);
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var o2 := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);

   |
38 |             OptimizerPreservesSemantics(e1, env);
   |                                                  ^

ex.dfy(38,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

   |
39 |             OptimizerPreservesSemantics(e2, env);
   |                                                  ^

ex.dfy(39,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases

   |
41 |     // base cases
   |                  ^

ex.dfy(41,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;

   |
42 |     assert eval(Const(0), env) == 0;
   |                                     ^

ex.dfy(42,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert eval(Const(0), env) == 0;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;
    assert forall x :: eval(Var(x), env) == env(x);

   |
43 |     assert forall x :: eval(Var(x), env) == env(x);
   |                                                    ^

ex.dfy(43,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert forall x :: eval(Var(x), env) == env(x);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;
    assert forall x :: eval(Var(x), env) == env(x);
    // induction step

   |
44 |     // induction step
   |                      ^

ex.dfy(44,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // induction step\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;
    assert forall x :: eval(Var(x), env) == env(x);
    // induction step
    assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);

   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                                                             ^

ex.dfy(45,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;
    assert forall x :: eval(Var(x), env) == env(x);
    // induction step
    assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
}

   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                     ^^

ex.dfy(45,20): Error: unresolved identifier: o1
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                         ^^

ex.dfy(45,24): Error: unresolved identifier: o2
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                                               ^^

ex.dfy(45,46): Error: unresolved identifier: e1
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                                                   ^^

ex.dfy(45,50): Error: unresolved identifier: e2
4 resolution/type errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
    // base cases
    assert eval(Const(0), env) == 0;
    assert forall x :: eval(Var(x), env) == env(x);
    // induction step
    assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
}
```

   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                     ^^

ex.dfy(45,20): Error: unresolved identifier: o1
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                         ^^

ex.dfy(45,24): Error: unresolved identifier: o2
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                                               ^^

ex.dfy(45,46): Error: unresolved identifier: e1
   |
45 |     assert eval(Add(o1, o2), env) == eval(Add(e1, e2), env);
   |                                                   ^^

ex.dfy(45,50): Error: unresolved identifier: e2
4 resolution/type errors detected in ex.dfy

SCORE
-1.0
['```\n']
['{\n']
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 

   |
33 |         case Const(_) =>
   |                         ^

ex.dfy(33,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 

   |
34 |         case Var(_) =>
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>

   |
35 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);

   |
36 |             var o1 := optimize(e1);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var o1 := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);

   |
37 |             var o2 := optimize(e2);
   |                                    ^

ex.dfy(37,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            var o2 := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);

   |
38 |             OptimizerPreservesSemantics(e1, env);
   |                                                  ^

ex.dfy(38,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);

   |
39 |             OptimizerPreservesSemantics(e2, env);
   |                                                  ^

ex.dfy(39,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(e1, e2) => 
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            if o1 == Const(0) then o2
            else if o2 == Const(0) then o1
            else Add(o1, o2)
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) => 
        case Var(_) => 
        case Add(e1, e2) =>
            var o1 := optimize(e1);
            var o2 := optimize(e2);
            OptimizerPreservesSemantics(e1, env);
            OptimizerPreservesSemantics(e2, env);
    }
}
```


STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 2)
number of back nodes: 17 (including leaves: 16)

expansion count: 20 (including failed: 3)

cache stats {'hit': 3, 'miss': 63}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 125.88 sec, Standard Deviation: 38.42 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.12 calls, Standard Deviation: 20.91 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 125.88 sec, Standard Deviation: 38.42 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.12 calls, Standard Deviation: 20.91 calls

Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {

  |
5 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val

  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

  |
9 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  |                                                      ^

ex.dfy(9,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {

   |
13 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 

   |
15 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(15,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);

   |
16 |       var e1_opt := optimize(e1);
   |                                  ^

ex.dfy(16,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);

   |
17 |       var e2_opt := optimize(e2);
   |                                  ^

ex.dfy(17,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt

   |
18 |       if e1_opt == Const(0) then e2_opt
   |                                        ^

ex.dfy(18,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if e1_opt == Const(0) then e2_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt

   |
19 |       else if e2_opt == Const(0) then e1_opt
   |                                             ^

ex.dfy(19,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if e2_opt == Const(0) then e1_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)

   |
20 |       else Add(e1_opt, e2_opt)
   |                               ^

ex.dfy(20,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else Add(e1_opt, e2_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e

   |
21 |     case _ => e
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }

   |
22 |   }
   |    ^

ex.dfy(22,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
28 |   match e {
   |            ^

ex.dfy(28,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants preserve semantics

   |
29 |     case Const(_) => () // Base case: Constants preserve semantics
   |                                                                   ^

ex.dfy(29,66): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => () // Base case: Constants preserve semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants preserve semantics
    case Var(_) => () // Base case: Variables preserve semantics

   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |     ^

ex.dfy(30,4): Error: invalid Suffix
   |
29 |     case Const(_) => () // Base case: Constants preserve semantics
   |                      ^

ex.dfy(29,21): Error: missing semicolon at end of statement
   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |                                                                 ^

ex.dfy(30,64): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => () // Base case: Variables preserve semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants preserve semantics
    case Var(_) => () // Base case: Variables preserve semantics
    case Add(e1, e2) =>

   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |     ^

ex.dfy(30,4): Error: invalid Suffix
   |
29 |     case Const(_) => () // Base case: Constants preserve semantics
   |                      ^

ex.dfy(29,21): Error: missing semicolon at end of statement
   |
31 |     case Add(e1, e2) =>
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |                    ^

ex.dfy(30,19): Error: missing semicolon at end of statement
   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants preserve semantics
    case Var(_) => () // Base case: Variables preserve semantics
    case Add(e1, e2) =>
      // Recursive case: Optimize the subexpressions

   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |     ^

ex.dfy(30,4): Error: invalid Suffix
   |
29 |     case Const(_) => () // Base case: Constants preserve semantics
   |                      ^

ex.dfy(29,21): Error: missing semicolon at end of statement
   |
31 |     case Add(e1, e2) =>
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Var(_) => () // Base case: Variables preserve semantics
   |                    ^

ex.dfy(30,19): Error: missing semicolon at end of statement
   |
32 |       // Recursive case: Optimize the subexpressions
   |                                                     ^

ex.dfy(32,52): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      // Recursive case: Optimize the subexpressions\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 

   |
29 |     case Const(_) =>
   |                     ^

ex.dfy(29,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 

   |
30 |     case Var(_) =>
   |                   ^

ex.dfy(30,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);

   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                             ^

ex.dfy(32,28): Error: invalid UpdateStmt
   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                                             ^

ex.dfy(32,44): Error: invalid UpdateStmt
   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                                                            ^

ex.dfy(32,59): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['      optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
      OptimizerPreservesSemantics(e1, env);

   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                             ^

ex.dfy(32,28): Error: invalid UpdateStmt
   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                                             ^

ex.dfy(32,44): Error: invalid UpdateStmt
   |
33 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(33,43): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                             ^

ex.dfy(32,28): Error: invalid UpdateStmt
   |
32 |       optimize(Add(e1, e2)) == optimize(e1) + optimize(e2);
   |                                             ^

ex.dfy(32,44): Error: invalid UpdateStmt
   |
34 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e2, env);\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => \n']
['    case Var(_) => \n']
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);

   |
32 |       var e1_opt := optimize(e1);
   |                                  ^

ex.dfy(32,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      var e1_opt := optimize(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);

   |
33 |       var e2_opt := optimize(e2);
   |                                  ^

ex.dfy(33,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then

   |
34 |       if e1_opt == Const(0) then
   |                             ^

ex.dfy(34,28): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if e1_opt == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then
        OptimizerPreservesSemantics(e2, env);

   |
34 |       if e1_opt == Const(0) then
   |                             ^

ex.dfy(34,28): Error: lbrace expected
   |
35 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(35,45): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then
        OptimizerPreservesSemantics(e2, env);
      else if e2_opt == Const(0) then

   |
34 |       if e1_opt == Const(0) then
   |                             ^

ex.dfy(34,28): Error: lbrace expected
   |
36 |       else if e2_opt == Const(0) then
   |       ^

ex.dfy(36,6): Error: this symbol not expected in CaseStmt
   |
36 |       else if e2_opt == Const(0) then
   |                                  ^

ex.dfy(36,33): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else if e2_opt == Const(0) then\n']
['{\n']
['  match e {\n']
['    case Const(_) => \n']
['    case Var(_) => \n']
['    case Add(e1, e2) =>\n']
['      var e1_opt := optimize(e1);\n']
['      var e2_opt := optimize(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);

   |
34 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
35 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
36 |   }
   |    ^

ex.dfy(36,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
  assert eval(optimize(e), env) == eval(e, env);

   |
37 |   assert eval(optimize(e), env) == eval(e, env);
   |                                                 ^

ex.dfy(37,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
  assert eval(optimize(e), env) == eval(e, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
  assert eval(optimize(e), env) == eval(e, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(e1, e2) => 
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      if e1_opt == Const(0) then e2_opt
      else if e2_opt == Const(0) then e1_opt
      else Add(e1_opt, e2_opt)
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      var e1_opt := optimize(e1);
      var e2_opt := optimize(e2);
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
  assert eval(optimize(e), env) == eval(e, env);
}
```


STATS

number of nodes: 27
number of gen nodes: 14 (including leaves: 2)
number of back nodes: 13 (including leaves: 12)

expansion count: 16 (including failed: 3)

cache stats {'hit': 15, 'miss': 49}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137, 127]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66, 64]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 126.00 sec, Standard Deviation: 36.23 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.78 calls, Standard Deviation: 19.80 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137, 127]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66, 64]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 126.00 sec, Standard Deviation: 36.23 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.78 calls, Standard Deviation: 19.80 calls

Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions

SCORE
1.0
['// Define the ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)

SCORE
1.0
['  | Constant(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)

SCORE
1.0
['  | Variable(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)

SCORE
1.0
['  | Addition(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function

SCORE
1.0
['// Define the evaluator function\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e

   |
11 |   match e
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val

   |
12 |   case Constant(val) => val
   |                            ^

ex.dfy(12,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Constant(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)

   |
13 |   case Variable(name) => env(name)
   |                                   ^

ex.dfy(13,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Variable(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)

   |
14 |   case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
   |                                                                           ^

ex.dfy(14,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function

SCORE
1.0
['// Define the optimizer function\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e

   |
21 |   match e
   |          ^

ex.dfy(21,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>

   |
22 |   case Addition(left, right) =>
   |                                ^

ex.dfy(22,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Addition(left, right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);

   |
23 |     var newLeft := Optimize(left);
   |                                   ^

ex.dfy(23,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var newLeft := Optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);

   |
24 |     var newRight := Optimize(right);
   |                                     ^

ex.dfy(24,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var newRight := Optimize(right);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight

   |
25 |     if newLeft == Constant(0) then newRight
   |                                            ^

ex.dfy(25,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if newLeft == Constant(0) then newRight\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft

   |
26 |     else if newRight == Constant(0) then newLeft
   |                                                 ^

ex.dfy(26,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if newRight == Constant(0) then newLeft\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)

   |
27 |     else Addition(newLeft, newRight)
   |                                     ^

ex.dfy(27,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else Addition(newLeft, newRight)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e

   |
28 |   case _ => e
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics

SCORE
1.0
['// Lemma to prove that the optimizer preserves the semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env);

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env);
{

   |
34 |   ensures Evaluate(e, env) == Evaluate(Optimize(e), env);
   |                                                         ^

ex.dfy(34,56): Warning: deprecated style: a semi-colon is not needed here
   |
35 | {
   |  ^

ex.dfy(35,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env);
{
  match e

   |
34 |   ensures Evaluate(e, env) == Evaluate(Optimize(e), env);
   |                                                         ^

ex.dfy(34,56): Warning: deprecated style: a semi-colon is not needed here
   |
36 |   match e
   |          ^

ex.dfy(36,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
36 |   match e
   |          ^

ex.dfy(36,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>

   |
37 |   case Constant(_) =>
   |                      ^

ex.dfy(37,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Constant(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>

   |
38 |   case Variable(_) =>
   |                      ^

ex.dfy(38,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Variable(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>

   |
39 |   case Addition(left, right) =>
   |                                ^

ex.dfy(39,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Addition(left, right) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);

   |
40 |     OptimizerPreservesSemantics(left, env);
   |                                            ^

ex.dfy(40,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);

   |
41 |     OptimizerPreservesSemantics(right, env);
   |                                             ^

ex.dfy(41,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
    assert Evaluate(Optimize(left), env) == Evaluate(left, env);

   |
42 |     assert Evaluate(Optimize(left), env) == Evaluate(left, env);
   |                                                                 ^

ex.dfy(42,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Evaluate(Optimize(left), env) == Evaluate(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
    assert Evaluate(Optimize(left), env) == Evaluate(left, env);
    assert Evaluate(Optimize(right), env) == Evaluate(right, env);

   |
43 |     assert Evaluate(Optimize(right), env) == Evaluate(right, env);
   |                                                                   ^

ex.dfy(43,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Evaluate(Optimize(right), env) == Evaluate(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
    assert Evaluate(Optimize(left), env) == Evaluate(left, env);
    assert Evaluate(Optimize(right), env) == Evaluate(right, env);
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
    assert Evaluate(Optimize(left), env) == Evaluate(left, env);
    assert Evaluate(Optimize(right), env) == Evaluate(right, env);
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// Define the ADT for arithmetic expressions
datatype Expr =
  | Constant(val: int)
  | Variable(name: string)
  | Addition(left: Expr, right: Expr)
```

```dafny
// Define the evaluator function
function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Constant(val) => val
  case Variable(name) => env(name)
  case Addition(left, right) => Evaluate(left, env) + Evaluate(right, env)
}
```

```dafny
// Define the optimizer function
function Optimize(e: Expr): Expr
{
  match e
  case Addition(left, right) =>
    var newLeft := Optimize(left);
    var newRight := Optimize(right);
    if newLeft == Constant(0) then newRight
    else if newRight == Constant(0) then newLeft
    else Addition(newLeft, newRight)
  case _ => e
}
```

```dafny
// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e
  case Constant(_) =>
  case Variable(_) =>
  case Addition(left, right) =>
    OptimizerPreservesSemantics(left, env);
    OptimizerPreservesSemantics(right, env);
    assert Evaluate(Optimize(left), env) == Evaluate(left, env);
    assert Evaluate(Optimize(right), env) == Evaluate(right, env);
}
```


STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 2)
number of back nodes: 25 (including leaves: 24)

expansion count: 27 (including failed: 2)

cache stats {'hit': 2, 'miss': 51}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137, 127, 127]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66, 64, 53]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 126.10 sec, Standard Deviation: 34.37 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.20 calls, Standard Deviation: 18.87 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [127, 218, 108, 125, 114, 86, 92, 137, 127, 127]

Trial calls: [60, 108, 47, 58, 47, 38, 41, 66, 64, 53]


Time Statistics:

  Min: 86.00 sec, Max: 218.00 sec, Average: 126.10 sec, Standard Deviation: 34.37 sec

Call Statistics:

  Min: 38 calls, Max: 108 calls, Average: 58.20 calls, Standard Deviation: 18.87 calls

To complete all experiments, 21 minutes and 42 seconds elapsed.


