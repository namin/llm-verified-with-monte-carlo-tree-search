

========
Experiment configuration: python experiments.py --experiment_name run_diversity.py --n_trials 10 --mins_timeout 6 --language Dafny --problem_name problem_opt0 --seed 42 


Trial  0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr = \n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr = Const(n: int)\n', 'datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Constant(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
    | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
    | Const(value: int)

SCORE
1.0
['  | Const(n: int)\n', '  | Constant(v: int)\n', '    | Const(n: int)\n', '  | Const(val: int)\n', '    | Const(value: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)

SCORE
1.0
['  | Var(x: string)\n', '  | Var(x: string)\n', '  | Var(x: string)\n', '  | Var(x: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int \n', 'function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '{\n', '  reads env\n', '  reads env\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e 

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e \n', '  match e \n', '  match e \n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e
  case Const(n) => n

   |
10 |   case Const(n) => n
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e
  case Const(n) => n
  case Var(name) => env(name)

   |
11 |   case Var(name) => env(name)
   |                              ^

ex.dfy(11,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
12 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(12,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
  reads env
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e \n', '  match e \n', '  match e\n', '  match e \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n

  |
9 |   case Const(n) => n
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
11 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(11,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr 

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr \n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr \n', 'function Optimize(e: Expr): Expr \n', 'function Optimize(e: Expr): Expr \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
  reads e

   |
15 |   reads e
   |         ^

ex.dfy(15,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Expr)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '  reads e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e \n', '  match e \n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => e2

   |
17 |   case Add(Const(0), e2) => e2
   |                               ^

ex.dfy(17,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)

   |
17 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => e2\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
18 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(18,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
19 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(19,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'requires true\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'requires true\n', 'requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // base case: if e is a constant or variable

   |
27 |   // base case: if e is a constant or variable
   |                                               ^

ex.dfy(27,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases

   |
27 |   // Base cases
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: if e is a constant or variable\n', '  // Base cases\n', '  // Base cases\n', '  // Base cases\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(_) 

   |
28 |   if e == Const(0) || e == Var(_)
   |                                  ^

ex.dfy(28,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) {

   |
28 |   if e == Const(0) {
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {

   |
28 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))

   |
28 |   if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
   |                                                                                            ^

ex.dfy(28,91): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(_) \n', '  if e == Const(0) {\n', '  if e == Const(0) || e == Var(_) {\n', '  if e == Const(0) || e == Var(_) {\n', '  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {

   |
29 |   {
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  } 

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.

   |
30 |     // In these cases, the optimizer does not change the expression.
   |                                                                     ^

ex.dfy(30,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // By the definition of Evaluate and Optimize

   |
30 |     // By the definition of Evaluate and Optimize
   |                                                  ^

ex.dfy(30,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } \n', '    // In these cases, the optimizer does not change the expression.\n', '  }\n', '  }\n', '    // By the definition of Evaluate and Optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
    // Therefore, it suffices to show that Evaluate(e, env) == Evaluate(e, env).

   |
31 |     // Therefore, it suffices to show that Evaluate(e, env) == Evaluate(e, env).
   |                                                                                 ^

ex.dfy(31,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
    assert Evaluate(e, env) == Evaluate(Optimize(e), env);

   |
31 |     assert Evaluate(e, env) == Evaluate(Optimize(e), env);
   |                                                           ^

ex.dfy(31,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '    // Therefore, it suffices to show that Evaluate(e, env) == Evaluate(e, env).\n', '    assert Evaluate(e, env) == Evaluate(Optimize(e), env);\n', '    assert Evaluate(e, env) == Evaluate(Optimize(e), env);\n', '    assert Evaluate(e, env) == Evaluate(Optimize(e), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else if e == Add(?e1, ?e2)

   |
32 |   else if e == Add(?e1, ?e2)
   |                             ^

ex.dfy(32,28): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 

   |
32 |   else
   |       ^

ex.dfy(32,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(?e1, ?e2)\n', '  else if e == Add(?e1, ?e2)\n', '  else if e == Add(?e1, ?e2)\n', '  else \n', '  else if e == Add(?e1, ?e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {

   |
33 |   {
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add

   |
34 |     // Recursive case for Add
   |                              ^

ex.dfy(34,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive step

   |
34 |     // Recursive step
   |                      ^

ex.dfy(34,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive cases

   |
34 |     // Recursive cases
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case for Add\n', '    // Recursive step\n', '    // Recursive cases\n', '    // Recursive cases\n', '    // Recursive cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add
    assert e == Add(?e1, ?e2);

   |
35 |     assert e == Add(?e1, ?e2);
   |                               ^

ex.dfy(35,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add
    assert e == Add(?e1, ?e2);
    lemma OptimizerPreservesSemantics(e1, env);

   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |     ^

ex.dfy(36,4): Error: rbrace expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                         ^

ex.dfy(36,40): Error: colon expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(36,45): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add
    assert e == Add(?e1, ?e2);
    OptimizerPreservesSemantics(e1, env);

   |
36 |     OptimizerPreservesSemantics(e1, env);
   |                                          ^

ex.dfy(36,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    lemma OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add
    assert e == Add(?e1, ?e2);
    lemma OptimizerPreservesSemantics(e1, env);
    lemma OptimizerPreservesSemantics(e2, env);

   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |     ^

ex.dfy(36,4): Error: rbrace expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                         ^

ex.dfy(36,40): Error: colon expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(36,45): Error: colon expected
   |
37 |     lemma OptimizerPreservesSemantics(e2, env);
   |                                         ^

ex.dfy(37,40): Error: colon expected
   |
37 |     lemma OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(37,45): Error: colon expected
5 parse errors detected in ex.dfy

SCORE
None
['    lemma OptimizerPreservesSemantics(e2, env);\n', '    lemma OptimizerPreservesSemantics(e2, env);\n', '    lemma OptimizerPreservesSemantics(e2, env);\n', '    lemma OptimizerPreservesSemantics(e2, env);\n', '    lemma OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
    // In these cases, the optimizer does not change the expression.
  }
  else 
  {
    // Recursive case for Add
    assert e == Add(?e1, ?e2);
    lemma OptimizerPreservesSemantics(e1, env);
    lemma OptimizerPreservesSemantics(e2, env);
  }

   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |     ^

ex.dfy(36,4): Error: rbrace expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                         ^

ex.dfy(36,40): Error: colon expected
   |
36 |     lemma OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(36,45): Error: colon expected
   |
37 |     lemma OptimizerPreservesSemantics(e2, env);
   |                                         ^

ex.dfy(37,40): Error: colon expected
   |
37 |     lemma OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(37,45): Error: colon expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Const(_) || e == Var(_) {

   |
27 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 

   |
27 |   if e == Optimize(e)
   |                      ^

ex.dfy(27,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e 

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n', '  if e == Const(_) || e == Var(_) {\n', '  // Base cases\n', '  if e == Optimize(e) \n', '  match e \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {

   |
28 |   {
   |    ^

ex.dfy(28,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
  } 

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // base case

   |
29 |     // base case
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form

   |
29 |     // Base case: e is in normal form
   |                                      ^

ex.dfy(29,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } \n', '  } \n', '    // base case\n', '    // Base case: e is in normal form\n', '  } \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
  } 

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate

   |
30 |     // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
   |                                                                                            ^

ex.dfy(30,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    assert Evaluate(e, env) == Evaluate(Optimize(e), env);

   |
30 |     assert Evaluate(e, env) == Evaluate(Optimize(e), env);
   |                                                           ^

ex.dfy(30,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } \n', '  } \n', '  } \n', '    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate\n', '    assert Evaluate(e, env) == Evaluate(Optimize(e), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } \n', '  } \n', '  } \n', '  } \n', '  } \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 

   |
32 |   else
   |       ^

ex.dfy(32,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else \n', '  else \n', '  else \n', '  else \n', '  else \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {

   |
33 |   {
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form

   |
34 |     // Recursive case: e is not in normal form
   |                                               ^

ex.dfy(34,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: e is not in normal form\n', '    // Recursive case: e is not in normal form\n', '    // Recursive case: e is not in normal form\n', '    // Recursive case: e is not in normal form\n', '    // Recursive case: e is not in normal form\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we can pattern match on e to destructure it and recursively call the lemma on the sub-expressions

   |
35 |     // In this case, we can pattern match on e to destructure it and recursively call the lemma on the sub-expressions
   |                                                                                                                       ^

ex.dfy(35,118): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we know from the definition of Optimize that e must be an Add expression

   |
35 |     // In this case, we know from the definition of Optimize that e must be an Add expression
   |                                                                                              ^

ex.dfy(35,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression Optimize(e)

   |
35 |     // In this case, we need to show that the postcondition holds for the optimized expression Optimize(e)
   |                                                                                                           ^

ex.dfy(35,106): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression

   |
35 |     // In this case, we need to show that the postcondition holds for the optimized expression
   |                                                                                               ^

ex.dfy(35,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // By the definition of Optimize, we know that there exists an expression e' such that Optimize(e) == e'

   |
35 |     // By the definition of Optimize, we know that there exists an expression e' such that Optimize(e) == e'
   |                                                                                                             ^

ex.dfy(35,108): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // In this case, we can pattern match on e to destructure it and recursively call the lemma on the sub-expressions\n', '    // In this case, we know from the definition of Optimize that e must be an Add expression\n', '    // In this case, we need to show that the postcondition holds for the optimized expression Optimize(e)\n', '    // In this case, we need to show that the postcondition holds for the optimized expression\n', "    // By the definition of Optimize, we know that there exists an expression e' such that Optimize(e) == e'\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    match e

   |
36 |     match e
   |            ^

ex.dfy(36,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by induction on the structure of e

   |
36 |     // We do this by induction on the structure of e
   |                                                     ^

ex.dfy(36,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    match e 

   |
36 |     match e
   |            ^

ex.dfy(36,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We can do this by pattern matching on the shape of the optimized expression

   |
36 |     // We can do this by pattern matching on the shape of the optimized expression
   |                                                                                   ^

ex.dfy(36,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e

   |
36 |     // We do this by recursively calling the lemma on the sub-expressions of e
   |                                                                               ^

ex.dfy(36,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    // We do this by induction on the structure of e\n', '    match e \n', '    // We can do this by pattern matching on the shape of the optimized expression\n', '    // We do this by recursively calling the lemma on the sub-expressions of e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 

   |
37 |     match e
   |            ^

ex.dfy(37,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match e \n', '    match e \n', '    match e \n', '    match e \n', '    match e \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {

   |
38 |     {
   |      ^

ex.dfy(38,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>

   |
39 |       case Add(e1, e2) =>
   |                          ^

ex.dfy(39,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) => 

   |
39 |       case Add(e1, e2) =>
   |                          ^

ex.dfy(39,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      case Add(e1, e2) =>\n', '      case Add(e1, e2) => \n', '      case Add(e1, e2) =>\n', '      case Add(e1, e2) =>\n', '      case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);

   |
40 |         OptimizerPreservesSemantics(e1, env);
   |                                              ^

ex.dfy(40,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e1, env);\n', '        OptimizerPreservesSemantics(e1, env);\n', '        OptimizerPreservesSemantics(e1, env);\n', '        OptimizerPreservesSemantics(e1, env);\n', '        OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);

   |
41 |         OptimizerPreservesSemantics(e2, env);
   |                                              ^

ex.dfy(41,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizerPreservesSemantics(e2, env);\n', '        OptimizerPreservesSemantics(e2, env);\n', '        OptimizerPreservesSemantics(e2, env);\n', '        OptimizerPreservesSemantics(e2, env);\n', '        OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }

   |
42 |     }
   |      ^

ex.dfy(42,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }

   |
43 |   }
   |    ^

ex.dfy(43,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}
``` package com.github.sarxos.webcam;

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}
``` package org.apache.ignite.internal.processors.cache.persistence.db.file;

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}
```

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}
``` #include "chrome/browser/ui/views/frame/browser_view_layout.h"

SCORE
1.0
['``` package com.github.sarxos.webcam;\n', '``` package org.apache.ignite.internal.processors.cache.persistence.db.file;\n', '```\n', '``` #include "chrome/browser/ui/views/frame/browser_view_layout.h"\n', '```\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int 
{
  match e 
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e 
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e == Optimize(e) 
  {
    // Base case: e is in normal form
    // In this case, Optimize(e) == e and the postcondition holds by definition of Evaluate
  } 
  else 
  {
    // Recursive case: e is not in normal form
    // In this case, we need to show that the postcondition holds for the optimized expression
    // We do this by recursively calling the lemma on the sub-expressions of e
    match e 
    {
      case Add(e1, e2) =>
        OptimizerPreservesSemantics(e1, env);
        OptimizerPreservesSemantics(e2, env);
    }
  }
}
```


STATS

number of nodes: 31
number of gen nodes: 16 (including leaves: 1)
number of back nodes: 15 (including leaves: 15)

expansion count: 17 (including failed: 2)

cache stats {'hit': 210, 'miss': 115}
calls to generate 65
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
['datatype Expr =\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = \n', '// ADT for arithmetic expressions\n', 'datatype Expr = Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    | Const(val: int)

SCORE
1.0
['    Const(val: int)\n', '    Const(n: int)\n', '    Const(n: int)\n', '  | Const(n: int)\n', '    | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(x: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(x: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: func(string) returns (int)): int

  |
6 | function method Eval(e: Expr, env: func(string) returns (int)): int
  |                                        ^

ex.dfy(6,39): Error: closeparen expected
  |
6 | function method Eval(e: Expr, env: func(string) returns (int)): int
  |                                                 ^

ex.dfy(6,48): Error: this symbol not expected in FunctionSpec
  |
6 | function method Eval(e: Expr, env: func(string) returns (int)): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: func(string) returns (int)): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '{\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  decreases e

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {

  |
8 |   {
  |    ^

ex.dfy(8,3): Error: invalid UnaryExpression
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  decreases e\n', '{\n', '{\n', '  {\n', '  decreases e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {
    match e

  |
9 |     match e
  |            ^

ex.dfy(9,11): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {
    match e
    case Const(n) => n

   |
10 |     case Const(n) => n
   |                       ^

ex.dfy(10,22): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {
    match e
    case Const(n) => n
    case Var(name) => env(name)

   |
11 |     case Var(name) => env(name)
   |                                ^

ex.dfy(11,31): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
12 |     case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  {
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }

  |
6 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(6,35): Error: invalid TypeAndToken
  |
6 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
6 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(6,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function Eval(e: Expr, env: string -> int): int {\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '    match e\n', '  match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n

  |
8 |   case Const(n) => n
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
10 |   case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                    ^

ex.dfy(10,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n', 'function Optimize(e: Expr): Expr {\n', 'function Optimize(e: Expr): Expr {\n', 'function Optimize(e: Expr): Expr {\n', 'function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e

   |
14 |   match e
   |          ^

ex.dfy(14,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => e2

   |
15 |   case Add(Const(0), e2) => e2
   |                               ^

ex.dfy(15,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
15 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(15,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => e2\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
16 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(17,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
18 |   case _ => e
   |              ^

ex.dfy(18,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
24 |   match e
   |          ^

ex.dfy(24,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {

   |
24 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(24,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e matches Add(_, _) {

   |
24 |   if e matches Add(_, _) {
   |        ^

ex.dfy(24,7): Error: lbrace expected
   |
24 |   if e matches Add(_, _) {
   |        ^^^^^^^

ex.dfy(24,7): Error: missing semicolon at end of statement
   |
24 |   if e matches Add(_, _) {
   |                ^^^

ex.dfy(24,15): Error: missing semicolon at end of statement
   |
24 |   if e matches Add(_, _) {
   |                           ^

ex.dfy(24,26): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  if e == Const(_) || e == Var(_) {\n', '  match e\n', '  match e\n', '  if e matches Add(_, _) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
  } else if e == Add(_, _) {

   |
25 |   } else if e == Add(_, _) {
   |                             ^

ex.dfy(25,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // Base case: If e is a constant or a variable, the optimization doesn't change the evaluation.

   |
25 |     // Base case: If e is a constant or a variable, the optimization doesn't change the evaluation.
   |                                                                                                    ^

ex.dfy(25,99): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
  } else {

   |
25 |   } else {
   |           ^

ex.dfy(25,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case

   |
25 |     // base case
   |                 ^

ex.dfy(25,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Add(_, _) {\n', "    // Base case: If e is a constant or a variable, the optimization doesn't change the evaluation.\n", '  } else {\n', '  } else {\n', '    // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {

   |
26 |   } else {
   |           ^

ex.dfy(26,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n', '  } else {\n', '  } else {\n', '  } else {\n', '  } else {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);

   |
27 |     assert e == Add(_, _);
   |                           ^

ex.dfy(27,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    match e

   |
27 |     match e
   |            ^

ex.dfy(27,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(_, _);\n', '    match e\n', '    assert e == Add(_, _);\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;

   |
28 |     var e1 := (e as Add).e1;
   |                             ^

ex.dfy(28,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := e.e1;

   |
28 |     var e1 := e.e1;
   |                    ^

ex.dfy(28,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (match e { case Add(e1, _) => e1 });

   |
28 |     var e1 := (match e { case Add(e1, _) => e1 });
   |                                                   ^

ex.dfy(28,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    match e

   |
28 |     match e
   |            ^

ex.dfy(28,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (match e { case Add(x, _) => x });

   |
28 |     var e1 := (match e { case Add(x, _) => x });
   |                                                 ^

ex.dfy(28,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var e1 := (e as Add).e1;\n', '    var e1 := e.e1;\n', '    var e1 := (match e { case Add(e1, _) => e1 });\n', '    match e\n', '    var e1 := (match e { case Add(x, _) => x });\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;
    var e2 := (e as Add).e2;

   |
29 |     var e2 := (e as Add).e2;
   |                             ^

ex.dfy(29,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var e2 := (e as Add).e2;\n', '    var e2 := (e as Add).e2;\n', '    var e2 := (e as Add).e2;\n', '    var e2 := (e as Add).e2;\n', '    var e2 := (e as Add).e2;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;
    var e2 := (e as Add).e2;
    OptimizerPreservesSemantics(e1, env);

   |
30 |     OptimizerPreservesSemantics(e1, env);
   |                                          ^

ex.dfy(30,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n', '    OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;
    var e2 := (e as Add).e2;
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);

   |
31 |     OptimizerPreservesSemantics(e2, env);
   |                                          ^

ex.dfy(31,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(e2, env);\n', '    OptimizerPreservesSemantics(e2, env);\n', '    OptimizerPreservesSemantics(e2, env);\n', '    OptimizerPreservesSemantics(e2, env);\n', '    OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;
    var e2 := (e as Add).e2;
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  }

   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e == Const(_) || e == Var(_) {
    // base case
  } else {
    assert e == Add(_, _);
    var e1 := (e as Add).e1;
    var e2 := (e as Add).e2;
    OptimizerPreservesSemantics(e1, env);
    OptimizerPreservesSemantics(e2, env);
  }
}

   |
24 |   if e == Const(_) || e == Var(_) {
   |                 ^

ex.dfy(24,16): Error: unresolved identifier: _
   |
24 |   if e == Const(_) || e == Var(_) {
   |                                ^

ex.dfy(24,31): Error: unresolved identifier: _
   |
27 |     assert e == Add(_, _);
   |                     ^

ex.dfy(27,20): Error: unresolved identifier: _
   |
27 |     assert e == Add(_, _);
   |                        ^

ex.dfy(27,23): Error: unresolved identifier: _
   |
28 |     var e1 := (e as Add).e1;
   |                     ^^^

ex.dfy(28,20): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
28 |     var e1 := (e as Add).e1;
   |                          ^^

ex.dfy(28,25): Error: type of the receiver is not fully determined at this program point
   |
29 |     var e2 := (e as Add).e2;
   |                     ^^^

ex.dfy(29,20): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
29 |     var e2 := (e as Add).e2;
   |                          ^^

ex.dfy(29,25): Error: type of the receiver is not fully determined at this program point
8 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases

   |
24 |   // Base cases
   |                ^

ex.dfy(24,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  // Base cases\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {

   |
25 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(25,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e is Const || e is Var {

   |
25 |   if e is Const || e is Var {
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e is Const {

   |
25 |   if e is Const {
   |                  ^

ex.dfy(25,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(0) then\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_) {\n', '  if e is Const || e is Var {\n', '  if e is Const {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
  {

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
  else if e == Add(0, 0) then

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
    assert Eval(Optimize(e), env) == Eval(e, env);

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  else if e == Add(0, 0) then\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
    assert Eval(Optimize(e), env) == Eval(e, env);
  else if e == Add(Const(0), Const(0)) then

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
    assert Eval(Optimize(e), env) == Eval(e, env);
  else if e == Add(0, 0) then

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(0) then
    assert Eval(Optimize(e), env) == Eval(e, env);
  else

   |
25 |   if e == Const(0) || e == Var(0) then
   |                                   ^

ex.dfy(25,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else if e == Add(Const(0), Const(0)) then\n', '  else if e == Add(0, 0) then\n', '  else\n', '  else if e == Add(0, 0) then\n', '  else if e == Add(Const(0), Const(0)) then\n']
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.

   |
24 |   // Base case: if e is a constant or variable, the claim is trivially true.
   |                                                                             ^

ex.dfy(24,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  if e is Const || e is Var {

   |
24 |   if e is Const || e is Var {
   |                              ^

ex.dfy(24,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  // Base case: if e is a constant or variable, the claim is trivially true.\n', '  match e\n', '  if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

   |
25 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(25,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {

   |
25 |   if e is Const || e is Var {
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Const || e is Var {}\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, we recursively invoke the lemma on the sub-expressions.

   |
26 |   // Inductive case: if e is an addition, we recursively invoke the lemma on the sub-expressions.
   |                                                                                                  ^

ex.dfy(26,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}


   |
25 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(25,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, we need to reason about the recursive calls.

   |
26 |   // Inductive case: if e is an addition, we need to reason about the recursive calls.
   |                                                                                       ^

ex.dfy(26,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, we recursively call the lemma on the sub-expressions.

   |
26 |   // Inductive case: if e is an addition, we recursively call the lemma on the sub-expressions.
   |                                                                                                ^

ex.dfy(26,95): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: if e is an addition, we recursively invoke the lemma on the sub-expressions.\n', '\n', '  // Inductive case: if e is an addition, we need to reason about the recursive calls.\n', '  // Inductive case: if e is an addition, we recursively call the lemma on the sub-expressions.\n', '  // Inductive case: if e is an addition, we recursively invoke the lemma on the sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim for its sub-expressions.

   |
27 |   // Inductive case: if e is an addition, we recursively prove the claim for its sub-expressions.
   |                                                                                                  ^

ex.dfy(27,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.

   |
27 |   // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.
   |                                                                                             ^

ex.dfy(27,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively invoke the lemma on its sub-expressions.

   |
27 |   // Inductive case: if e is an addition, we recursively invoke the lemma on its sub-expressions.
   |                                                                                                  ^

ex.dfy(27,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the claim for its sub-expressions.

   |
27 |   // Inductive case: if e is an addition, recursively prove the claim for its sub-expressions.
   |                                                                                               ^

ex.dfy(27,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.

   |
27 |   // Inductive case: if e is an addition, we recursively prove the claim.
   |                                                                          ^

ex.dfy(27,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: if e is an addition, we recursively prove the claim for its sub-expressions.\n', '  // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.\n', '  // Inductive case: if e is an addition, we recursively invoke the lemma on its sub-expressions.\n', '  // Inductive case: if e is an addition, recursively prove the claim for its sub-expressions.\n', '  // Inductive case: if e is an addition, we recursively prove the claim.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {

   |
28 |   if e is Add {
   |                ^

ex.dfy(28,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  else if e is Add {

   |
28 |   else if e is Add {
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Add {\n', '  else if e is Add {\n', '  if e is Add {\n', '  if e is Add {\n', '  if e is Add {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.

   |
29 |     // We need to split the induction into two cases, depending on which side of the addition is being optimized.
   |                                                                                                                  ^

ex.dfy(29,113): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    var e1 := e.e1;

   |
29 |     var e1 := e.e1;
   |                    ^

ex.dfy(29,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    assert e == Add(e1, e2);

   |
29 |     assert e == Add(e1, e2);
   |                             ^

ex.dfy(29,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // We need to split the induction into two cases, depending on which side of the addition is being optimized.\n', '    var e1 := e.e1;\n', '    var e1 := e.e1;\n', '    assert e == Add(e1, e2);\n', '    var e1 := e.e1;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {

   |
30 |     if e.e1 is Const && e.e1.n == 0 {
   |                                      ^

ex.dfy(30,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    OptimizerPreservesSemantics(e.e1, env);

   |
30 |     OptimizerPreservesSemantics(e.e1, env);
   |                                            ^

ex.dfy(30,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    assert Optimize(Add(e.e1, e.e2)) == Add(Optimize(e.e1), Optimize(e.e2));

   |
30 |     assert Optimize(Add(e.e1, e.e2)) == Add(Optimize(e.e1), Optimize(e.e2));
   |                                                                             ^

ex.dfy(30,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    var e1 := e.e1;

   |
30 |     var e1 := e.e1;
   |                    ^

ex.dfy(30,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e.e1 is Const && e.e1.n == 0 {\n', '    OptimizerPreservesSemantics(e.e1, env);\n', '    assert Optimize(Add(e.e1, e.e2)) == Add(Optimize(e.e1), Optimize(e.e2));\n', '    OptimizerPreservesSemantics(e.e1, env);\n', '    var e1 := e.e1;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.

   |
31 |       // If the left side is a constant 0, then Optimize(e) is e2.
   |                                                                   ^

ex.dfy(31,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      OptimizerPreservesSemantics(e.e2, env);

   |
31 |       OptimizerPreservesSemantics(e.e2, env);
   |                                              ^

ex.dfy(31,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      assert Optimize(e) == e.e2;

   |
31 |       assert Optimize(e) == e.e2;
   |                                  ^

ex.dfy(31,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      assert Optimize(e.e1) == e.e2;

   |
31 |       assert Optimize(e.e1) == e.e2;
   |                                     ^

ex.dfy(31,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // If the left side is a constant 0, then Optimize(e) is e2.\n', '      OptimizerPreservesSemantics(e.e2, env);\n', '      assert Optimize(e) == e.e2;\n', '      assert Optimize(e.e1) == e.e2;\n', '      OptimizerPreservesSemantics(e.e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;

   |
32 |       assert Optimize(e) == e.e2;
   |                                  ^

ex.dfy(32,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Optimize(e) == e.e2;\n', '      assert Optimize(e) == e.e2;\n', '      assert Optimize(e) == e.e2;\n', '      assert Optimize(e) == e.e2;\n', '      assert Optimize(e) == e.e2;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // By the induction hypothesis, Eval(Optimize(e2), env) == Eval(e2, env).

   |
33 |       // By the induction hypothesis, Eval(Optimize(e2), env) == Eval(e2, env).
   |                                                                                ^

ex.dfy(33,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // In this case, the claim is Eval(e.e2, env) == Eval(e, env).

   |
33 |       // In this case, the claim is Eval(e.e2, env) == Eval(e, env).
   |                                                                     ^

ex.dfy(33,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).

   |
33 |       // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
   |                                                               ^

ex.dfy(33,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // In this case, the claim is equivalent to proving that Eval(e2, env) == Eval(e, env), which is true by definition of Eval.

   |
33 |       // In this case, the claim is equivalent to proving that Eval(e2, env) == Eval(e, env), which is true by definition of Eval.
   |                                                                                                                                   ^

ex.dfy(33,130): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the induction hypothesis, Eval(Optimize(e2), env) == Eval(e2, env).\n', '      // In this case, the claim is Eval(e.e2, env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).\n', '      // In this case, the claim is equivalent to proving that Eval(e2, env) == Eval(e, env), which is true by definition of Eval.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);

   |
34 |       assert Eval(Optimize(e), env) == Eval(e.e2, env);
   |                                                        ^

ex.dfy(34,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Optimize(e), env) == Eval(e.e2, env);\n', '      assert Eval(Optimize(e), env) == Eval(e.e2, env);\n', '      assert Eval(Optimize(e), env) == Eval(e.e2, env);\n', '      assert Eval(Optimize(e), env) == Eval(e.e2, env);\n', '      assert Eval(Optimize(e), env) == Eval(e.e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env).

   |
35 |       // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env).
   |                                                                       ^

ex.dfy(35,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).

   |
35 |       // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
   |                                                                       ^

ex.dfy(35,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env) - e.e1.n.

   |
35 |       // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env) - e.e1.n.
   |                                                                                ^

ex.dfy(35,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env) - 0.

   |
35 |       // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env) - 0.
   |                                                                           ^

ex.dfy(35,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
    } else {

   |
35 |     } else {
   |             ^

ex.dfy(35,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env).\n', '      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).\n', '      // By the inductive hypothesis, Eval(e.e2, env) == Eval(e, env) - e.e1.n.\n', '      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env) - 0.\n', '    } else {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);

   |
36 |       assert Eval(e.e2, env) == Eval(e, env);
   |                                              ^

ex.dfy(36,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(e.e2, env) == Eval(e, env);\n', '      assert Eval(e.e2, env) == Eval(e, env);\n', '      assert Eval(e.e2, env) == Eval(e, env);\n', '      assert Eval(e.e2, env) == Eval(e, env);\n', '      assert Eval(e.e2, env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).

   |
37 |       // Therefore, Eval(Optimize(e), env) == Eval(e, env).
   |                                                            ^

ex.dfy(37,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {

   |
38 |     } else {
   |             ^

ex.dfy(38,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n', '    } else {\n', '    } else {\n', '    } else {\n', '    } else {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).

   |
39 |       // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
   |                                                                                                        ^

ex.dfy(39,103): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e1), Optimize(e2)).

   |
39 |       // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e1), Optimize(e2)).
   |                                                                                                    ^

ex.dfy(39,99): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).\n', '      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e1), Optimize(e2)).\n', '      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).\n', '      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).\n', '      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));

   |
40 |       assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
   |                                                                 ^

ex.dfy(40,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));\n', '      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));\n', '      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));\n', '      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));\n', '      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).

   |
41 |       // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
   |                                                                                              ^

ex.dfy(41,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);

   |
42 |       assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
   |                                                                                       ^

ex.dfy(42,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);\n', '      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);\n', '      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);\n', '      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);\n', '      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).

   |
43 |       // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
   |                                                                                                      ^

ex.dfy(43,101): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(Add(e.e1, e.e2), env).

   |
43 |       // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(Add(e.e1, e.e2), env).
   |                                                                                                                    ^

ex.dfy(43,115): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).\n', '      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(Add(e.e1, e.e2), env).\n', '      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).\n', '      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).\n', '      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);

   |
44 |       assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);
   |                                                                             ^

ex.dfy(44,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);\n', '      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);\n', '      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);\n', '      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);\n', '      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).

   |
45 |       // Therefore, Eval(Optimize(e), env) == Eval(e, env).
   |                                                            ^

ex.dfy(45,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n', '      // Therefore, Eval(Optimize(e), env) == Eval(e, env).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    }

   |
46 |     }
   |      ^

ex.dfy(46,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    }
  }

   |
47 |   }
   |    ^

ex.dfy(47,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: if e is a constant or variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, we recursively prove the claim.
  if e is Add {
    // We need to split the induction into two cases, depending on which side of the addition is being optimized.
    if e.e1 is Const && e.e1.n == 0 {
      // If the left side is a constant 0, then Optimize(e) is e2.
      assert Optimize(e) == e.e2;
      // Therefore, Eval(Optimize(e), env) == Eval(e.e2, env).
      assert Eval(Optimize(e), env) == Eval(e.e2, env);
      // By the induction hypothesis, Eval(e.e2, env) == Eval(e, env).
      assert Eval(e.e2, env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    } else {
      // If the left side is not a constant 0, then Optimize(e) is Add(Optimize(e.e1), Optimize(e.e2)).
      assert Optimize(e) == Add(Optimize(e.e1), Optimize(e.e2));
      // Therefore, Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env).
      assert Eval(Optimize(e), env) == Eval(Add(Optimize(e.e1), Optimize(e.e2)), env);
      // By the induction hypothesis, Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env).
      assert Eval(Add(Optimize(e.e1), Optimize(e.e2)), env) == Eval(e, env);
      // Therefore, Eval(Optimize(e), env) == Eval(e, env).
    }
  }
}

   |
25 |   if e is Const || e is Var {}
   |           ^^^^^

ex.dfy(25,10): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
25 |   if e is Const || e is Var {}
   |                         ^^^

ex.dfy(25,24): Error: Type or type parameter is not declared in this scope: Var (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
28 |   if e is Add {
   |           ^^^

ex.dfy(28,10): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
30 |     if e.e1 is Const && e.e1.n == 0 {
   |                ^^^^^

ex.dfy(30,15): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
25 |   if e is Const || e is Var {}
   |        ^^

ex.dfy(25,7): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
   |
25 |   if e is Const || e is Var {}
   |                      ^^

ex.dfy(25,21): Error: type test for type 'Var' must be from an expression assignable to it (got 'Expr')
   |
28 |   if e is Add {
   |        ^^

ex.dfy(28,7): Error: type test for type 'Add' must be from an expression assignable to it (got 'Expr')
   |
30 |     if e.e1 is Const && e.e1.n == 0 {
   |             ^^

ex.dfy(30,12): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
8 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 23
number of gen nodes: 12 (including leaves: 2)
number of back nodes: 11 (including leaves: 10)

expansion count: 15 (including failed: 4)

cache stats {'hit': 232, 'miss': 133}
calls to generate 73
Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// Abstract Data Type for arithmetic expressions\n', 'datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)\n', '// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr = 

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr =\n', 'datatype Expr = \n', 'datatype Expr = Const(n: int)\n', 'datatype Expr =\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
    | Constant(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
    Constant(val: int),

  |
3 |     Constant(val: int),
  |                       ^

ex.dfy(3,22): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['    | Constant(val: int)\n', '  | Const(val: int)\n', '  | Const(val: int)\n', '  | Const(val: int)\n', '    Constant(val: int),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(left: Expr, right: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)


SCORE
1.0
['```\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator function

SCORE
1.0
['// Evaluator\n', '// Evaluator\n', '// Evaluator function\n', '// Evaluator\n', '// Evaluator function\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
9 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(9,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function evaluate(e: Expr, env: function (string) returns (int)): int

  |
9 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(9,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function method Eval(e: Expr, env: function (string) returns (int)): int {

  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(9,35): Error: invalid TypeAndToken
  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(9,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                           ^

ex.dfy(9,74): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function method Eval(e: Expr, env: function (string) returns (int)): int {
  match e

  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(9,35): Error: invalid TypeAndToken
  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(9,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
   |
10 |   match e
   |          ^

ex.dfy(10,9): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function method Eval(e: Expr, env: function (string) returns (int)): int {
  match e
  case Const(val) => val

  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(9,35): Error: invalid TypeAndToken
  |
9 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(9,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
   |
11 |   case Const(val) => val
   |                         ^

ex.dfy(11,24): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function Eval(e: Expr, env: func (string) returns (int)): int

  |
9 | function Eval(e: Expr, env: func (string) returns (int)): int
  |                                  ^

ex.dfy(9,33): Error: closeparen expected
  |
9 | function Eval(e: Expr, env: func (string) returns (int)): int
  |                                           ^

ex.dfy(9,42): Error: this symbol not expected in FunctionSpec
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: func(string) returns (int)): int

  |
9 | function eval(e: Expr, env: func(string) returns (int)): int
  |                                 ^

ex.dfy(9,32): Error: closeparen expected
  |
9 | function eval(e: Expr, env: func(string) returns (int)): int
  |                                          ^

ex.dfy(9,41): Error: this symbol not expected in FunctionSpec
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function Eval(e: Expr, env: function (string) returns (int)): int

  |
9 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(9,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: func (string) returns (int)): int\n', 'function evaluate(e: Expr, env: string -> int): int\n', 'function eval(e: Expr, env: func(string) returns (int)): int\n', 'function eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env

   |
10 |   reads env
   |         ^^^

ex.dfy(10,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '{\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
{

   |
11 | {
   |  ^

ex.dfy(11,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e

   |
10 |   reads env
   |         ^^^

ex.dfy(10,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
   |
11 |   reads e
   |         ^

ex.dfy(11,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Expr)
2 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '  reads e\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{

   |
12 | {
   |  ^

ex.dfy(12,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{
  match e

   |
13 |   match e
   |          ^

ex.dfy(13,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{
  match e
  case Const(val) => val

   |
14 |   case Const(val) => val
   |                         ^

ex.dfy(14,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

   |
15 |   case Var(name) => env(name)
   |                              ^

ex.dfy(15,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)

   |
16 |   case Add(left, right) => eval(left, env) + eval(right, env)
   |                                                              ^

ex.dfy(16,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
  reads env
  reads e
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}

   |
10 |   reads env
   |         ^^^

ex.dfy(10,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
   |
11 |   reads e
   |         ^

ex.dfy(11,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Expr)
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '  reads env\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e

   |
11 |   match e
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

   |
12 |   case Const(val) => val
   |                         ^

ex.dfy(12,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

   |
13 |   case Var(name) => env(name)
   |                              ^

ex.dfy(13,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)

   |
14 |   case Add(left, right) => eval(left, env) + eval(right, env)
   |                                                              ^

ex.dfy(14,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n', '  case Add(left, right) => eval(left, env) + eval(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer

SCORE
1.0
['// Optimizer\n', '// Optimizer\n', '// Optimizer\n', '// Optimizer\n', '// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr

SCORE
1.0
['function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
  reads e

   |
20 |   reads e
   |         ^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Expr)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '  reads e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e

   |
21 |   match e
   |          ^

ex.dfy(21,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>

   |
22 |   case Add(left, right) =>
   |                           ^

ex.dfy(22,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => optimize(right)

   |
22 |   case Add(Const(0), right) => optimize(right)
   |                                               ^

ex.dfy(22,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), right) => right

   |
22 |   case Add(Const(0), right) => right
   |                                     ^

ex.dfy(22,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, Const(0)) => optimize(left)

   |
22 |   case Add(left, Const(0)) => optimize(left)
   |                                             ^

ex.dfy(22,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) =>\n', '  case Add(Const(0), right) => optimize(right)\n', '  case Add(Const(0), right) => right\n', '  case Add(left, Const(0)) => optimize(left)\n', '  case Add(Const(0), right) => optimize(right)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var opt_left := optimize(left);

   |
23 |     var opt_left := optimize(left);
   |                                    ^

ex.dfy(23,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);

   |
23 |     var optLeft := optimize(left);
   |                                   ^

ex.dfy(23,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var opt_left := optimize(left);\n', '    var opt_left := optimize(left);\n', '    var optLeft := optimize(left);\n', '    var opt_left := optimize(left);\n', '    var opt_left := optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);

   |
24 |     var optRight := optimize(right);
   |                                     ^

ex.dfy(24,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var optRight := optimize(right);\n', '    var optRight := optimize(right);\n', '    var optRight := optimize(right);\n', '    var optRight := optimize(right);\n', '    var optRight := optimize(right);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight

   |
25 |     if optLeft == Const(0) then optRight
   |                                         ^

ex.dfy(25,40): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then

   |
25 |     if optLeft == Const(0) then
   |                                ^

ex.dfy(25,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if optLeft == Const(0) then optRight\n', '    if optLeft == Const(0) then\n', '    if optLeft == Const(0) then\n', '    if optLeft == Const(0) then\n', '    if optLeft == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft

   |
26 |     else if optRight == Const(0) then optLeft
   |                                              ^

ex.dfy(26,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if optRight == Const(0) then optLeft\n', '    else if optRight == Const(0) then optLeft\n', '    else if optRight == Const(0) then optLeft\n', '    else if optRight == Const(0) then optLeft\n', '    else if optRight == Const(0) then optLeft\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)

   |
27 |     else Add(optLeft, optRight)
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else Add(optLeft, optRight)\n', '    else Add(optLeft, optRight)\n', '    else Add(optLeft, optRight)\n', '    else Add(optLeft, optRight)\n', '    else Add(optLeft, optRight)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e

   |
28 |   case _ => e
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma for proving that the optimizer preserves the semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that optimizer preserves semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Preservation lemma

SCORE
1.0
['// Lemma for proving that the optimizer preserves the semantics\n', '// Lemma that optimizer preserves semantics\n', '// Lemma that the optimizer preserves the semantics\n', '// Lemma that optimizer preserves semantics\n', '// Preservation lemma\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  requires true;

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  requires true;\n', '{\n', '  ensures eval(optimize(e), env) == eval(e, env)\n', '  ensures eval(optimize(e), env) == eval(e, env)\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
{
  assert eval(optimize(e), env) == eval(e, env);

   |
35 |   assert eval(optimize(e), env) == eval(e, env);
   |                                                 ^

ex.dfy(35,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  assert eval(optimize(e), env) == eval(e, env);\n', '  assert eval(optimize(e), env) == eval(e, env);\n', '  assert eval(optimize(e), env) == eval(e, env);\n', '  assert eval(optimize(e), env) == eval(e, env);\n', '  assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
{
  assert eval(optimize(e), env) == eval(e, env);
}

ex.dfy(35,9): Error: assertion might not hold
   |
35 |   assert eval(optimize(e), env) == eval(e, env);
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
{
  assert eval(optimize(e), env) == eval(e, env);
}
```

ex.dfy(35,9): Error: assertion might not hold
   |
35 |   assert eval(optimize(e), env) == eval(e, env);
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
['{\n', '  ensures eval(optimize(e), env) == eval(e, env)\n', '  ensures eval(optimize(e), env) == eval(e, env)\n', '{\n', '  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or variable, the lemma is trivially true

   |
36 |   // Base case: if e is a constant or variable, the lemma is trivially true
   |                                                                            ^

ex.dfy(36,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e

   |
36 |   match e
   |          ^

ex.dfy(36,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial

   |
36 |   // Base case: if e is a constant or a variable, the lemma is trivial
   |                                                                       ^

ex.dfy(36,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if e is a constant or variable, the lemma is trivially true\n', '  match e\n', '  match e\n', '  // Base case: if e is a constant or a variable, the lemma is trivial\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)

   |
37 |   if e == Const(0) || e == Var(?)
   |                                  ^

ex.dfy(37,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(?val) || e == Var(?name) {

   |
37 |   if e == Const(?val) || e == Var(?name) {
   |                                           ^

ex.dfy(37,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e is Const || e is Var {}

   |
37 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(_)

   |
37 |   if e == Const(0) || e == Var(_)
   |                                  ^

ex.dfy(37,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(?)\n', '  if e == Const(?val) || e == Var(?name) {\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {}\n', '  if e == Const(0) || e == Var(_)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  else if e == Add(Const(0), right)

   |
38 |   else if e == Add(Const(0), right)
   |   ^

ex.dfy(38,2): Error: lbrace expected
   |
38 |   else if e == Add(Const(0), right)
   |                                    ^

ex.dfy(38,35): Error: lbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  else if e == Add(left, right)

   |
38 |   else if e == Add(left, right)
   |   ^

ex.dfy(38,2): Error: lbrace expected
   |
38 |   else if e == Add(left, right)
   |                                ^

ex.dfy(38,31): Error: lbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {

   |
38 |   {
   |    ^

ex.dfy(38,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  else if e == Add(?, ?)

   |
38 |   else if e == Add(?, ?)
   |   ^

ex.dfy(38,2): Error: lbrace expected
   |
38 |   else if e == Add(?, ?)
   |                         ^

ex.dfy(38,24): Error: lbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(Const(0), right)\n', '  else if e == Add(left, right)\n', '  {\n', '  else if e == Add(?, ?)\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }

   |
39 |   }
   |    ^

ex.dfy(39,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else if e == Add(left, right)

   |
40 |   else if e == Add(left, right)
   |                                ^

ex.dfy(40,31): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else if e == Add(Const(0), right)

   |
40 |   else if e == Add(Const(0), right)
   |                                    ^

ex.dfy(40,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else

   |
40 |   else
   |       ^

ex.dfy(40,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(left, right)\n', '  else if e == Add(Const(0), right)\n', '  else if e == Add(Const(0), right)\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {

   |
41 |   {
   |    ^

ex.dfy(41,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: if e is an addition, recursively apply the lemma to the sub-expressions

   |
42 |     // Inductive case: if e is an addition, recursively apply the lemma to the sub-expressions
   |                                                                                               ^

ex.dfy(42,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Recursive case: e is an addition

   |
42 |     // Recursive case: e is an addition
   |                                        ^

ex.dfy(42,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition

   |
42 |     // Inductive case: e is an addition
   |                                        ^

ex.dfy(42,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: if e is an addition, recursively apply the lemma to the sub-expressions\n', '    // Recursive case: e is an addition\n', '    // Inductive case: e is an addition\n', '    // Inductive case: e is an addition\n', '    // Recursive case: e is an addition\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    match e

   |
43 |     match e
   |            ^

ex.dfy(43,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?left, ?right);

   |
43 |     assert e == Add(?left, ?right);
   |                                    ^

ex.dfy(43,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);

   |
43 |     assert e == Add(?, ?);
   |                           ^

ex.dfy(43,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    assert e == Add(?left, ?right);\n', '    assert e == Add(?, ?);\n', '    assert e == Add(?left, ?right);\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively prove the lemma for the sub-expressions

   |
44 |     // Recursively prove the lemma for the sub-expressions
   |                                                           ^

ex.dfy(44,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    var left := eval(optimize(e.left), env);

   |
44 |     var left := eval(optimize(e.left), env);
   |                                             ^

ex.dfy(44,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    var left := eval(optimize(Add(?left, ?right)), env);

   |
44 |     var left := eval(optimize(Add(?left, ?right)), env);
   |                                                         ^

ex.dfy(44,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively apply the lemma to the sub-expressions

   |
44 |     // Recursively apply the lemma to the sub-expressions
   |                                                          ^

ex.dfy(44,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively prove the lemma for the sub-expressions\n', '    var left := eval(optimize(e.left), env);\n', '    var left := eval(optimize(Add(?left, ?right)), env);\n', '    var left := eval(optimize(Add(?left, ?right)), env);\n', '    // Recursively apply the lemma to the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively apply the lemma to the sub-expressions
    OptimizerSemantics(?, env);

   |
45 |     OptimizerSemantics(?, env);
   |                                ^

ex.dfy(45,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively apply the lemma to the sub-expressions
    OptimizerSemantics(?, env);
    OptimizerSemantics(?, env);

   |
46 |     OptimizerSemantics(?, env);
   |                                ^

ex.dfy(46,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n', '    OptimizerSemantics(?, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively apply the lemma to the sub-expressions
    OptimizerSemantics(?, env);
    OptimizerSemantics(?, env);
  }

   |
47 |   }
   |    ^

ex.dfy(47,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: if e is a constant or a variable, the lemma is trivial
  if e == Const(0) || e == Var(?)
  {
  }
  else
  {
    // Inductive case: e is an addition
    assert e == Add(?, ?);
    // Recursively apply the lemma to the sub-expressions
    OptimizerSemantics(?, env);
    OptimizerSemantics(?, env);
  }
}

   |
37 |   if e == Const(0) || e == Var(?)
   |                                ^

ex.dfy(37,31): Error: unresolved identifier: ?
   |
43 |     assert e == Add(?, ?);
   |                     ^

ex.dfy(43,20): Error: unresolved identifier: ?
   |
43 |     assert e == Add(?, ?);
   |                        ^

ex.dfy(43,23): Error: unresolved identifier: ?
   |
45 |     OptimizerSemantics(?, env);
   |                        ^

ex.dfy(45,23): Error: unresolved identifier: ?
   |
46 |     OptimizerSemantics(?, env);
   |                        ^

ex.dfy(46,23): Error: unresolved identifier: ?
5 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.

   |
36 |   // Base case: If e is a constant or a variable, the claim is trivially true.
   |                                                                               ^

ex.dfy(36,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const

   |
36 |   // Base case: Const
   |                      ^

ex.dfy(36,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  // Base case: If e is a constant or a variable, the claim is trivially true.\n', '  // Base case: Const\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(_) {

   |
37 |   if e == Const(_) {
   |                     ^

ex.dfy(37,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {

   |
37 |   if e == Const(0) {
   |                     ^

ex.dfy(37,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}

   |
37 |   if e == Const(0) {}
   |                      ^

ex.dfy(37,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(_) {\n', '  if e == Const(0) {\n', '  if e == Const(_) {\n', '  if e == Const(0) {\n', '  if e == Const(0) {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  else if e == Const(_) {}

   |
38 |   else if e == Const(_) {}
   |                           ^

ex.dfy(38,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var

   |
38 |   // Base case: Var
   |                    ^

ex.dfy(38,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  else if e == Const(?val) {}

   |
38 |   else if e == Const(?val) {}
   |                              ^

ex.dfy(38,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Const(_) {}\n', '  // Base case: Var\n', '  else if e == Const(?val) {}\n', '  else if e == Const(_) {}\n', '  else if e == Const(?val) {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(_) {}

   |
39 |   else if e == Var(_) {}
   |                         ^

ex.dfy(39,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}

   |
39 |   else if e == Var(0) {}
   |                         ^

ex.dfy(39,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Var(_) {}\n', '  else if e == Var(_) {}\n', '  else if e == Var(0) {}\n', '  else if e == Var(_) {}\n', '  else if e == Var(_) {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add

   |
40 |   // Base case: Add
   |                    ^

ex.dfy(40,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add with 0 on the left

   |
40 |   // Base case: Add with 0 on the left
   |                                       ^

ex.dfy(40,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: Add\n', '  // Base case: Add\n', '  // Base case: Add with 0 on the left\n', '  // Base case: Add\n', '  // Base case: Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(0, 0) {}

   |
41 |   else if e == Add(0, 0) {}
   |                            ^

ex.dfy(41,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {

   |
41 |   else if e == Add(Const(0), right) {
   |                                      ^

ex.dfy(41,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(0, 0) {}\n', '  else if e == Add(0, 0) {}\n', '  else if e == Add(Const(0), right) {\n', '  else if e == Add(Const(0), right) {\n', '  else if e == Add(0, 0) {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);

   |
42 |     OptimizerSemantics(right, env);
   |                                    ^

ex.dfy(42,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    assert Const(0) == Const(0);

   |
42 |     assert Const(0) == Const(0);
   |                                 ^

ex.dfy(42,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    assert Const(0) == optimize(Const(0));

   |
42 |     assert Const(0) == optimize(Const(0));
   |                                           ^

ex.dfy(42,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(right, env);\n', '    assert Const(0) == Const(0);\n', '    OptimizerSemantics(right, env);\n', '    OptimizerSemantics(right, env);\n', '    assert Const(0) == optimize(Const(0));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }

   |
43 |   }
   |    ^

ex.dfy(43,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {

   |
44 |   else if e == Add(left, Const(0)) {
   |                                     ^

ex.dfy(44,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(left, Const(0)) {\n', '  else if e == Add(left, Const(0)) {\n', '  else if e == Add(left, Const(0)) {\n', '  else if e == Add(left, Const(0)) {\n', '  else if e == Add(left, Const(0)) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);

   |
45 |     OptimizerSemantics(left, env);
   |                                   ^

ex.dfy(45,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }

   |
46 |   }
   |    ^

ex.dfy(46,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else if e == Add(left, right) {

   |
47 |   else if e == Add(left, right) {
   |                                  ^

ex.dfy(47,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {

   |
47 |   else {
   |         ^

ex.dfy(47,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  // Inductive case: Add

   |
47 |   // Inductive case: Add
   |                         ^

ex.dfy(47,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(left, right) {\n', '  else if e == Add(left, right) {\n', '  else {\n', '  else if e == Add(left, right) {\n', '  // Inductive case: Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Recursive case: left and right sub-expressions

   |
48 |     // Recursive case: left and right sub-expressions
   |                                                      ^

ex.dfy(48,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case

   |
48 |     // Inductive case
   |                      ^

ex.dfy(48,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    var optLeft := optimize(left);

   |
48 |     var optLeft := optimize(left);
   |                                   ^

ex.dfy(48,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: left and right sub-expressions\n', '    // Inductive case\n', '    // Recursive case: left and right sub-expressions\n', '    var optLeft := optimize(left);\n', '    // Recursive case: left and right sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optLeft := optimize(left);

   |
49 |     var optLeft := optimize(left);
   |                                   ^

ex.dfy(49,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    assert e == Add(left, right);

   |
49 |     assert e == Add(left, right);
   |                                  ^

ex.dfy(49,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);

   |
49 |     var optE := optimize(e);
   |                             ^

ex.dfy(49,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var optLeft := optimize(left);\n', '    assert e == Add(left, right);\n', '    var optE := optimize(e);\n', '    assert e == Add(left, right);\n', '    var optLeft := optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    assert optE == e;

   |
50 |     assert optE == e;
   |                      ^

ex.dfy(50,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };

   |
50 |     var left := match e { case Add(l, r) => l };
   |                                                 ^

ex.dfy(50,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var optLeft := optimize(left);

   |
50 |     var optLeft := optimize(left);
   |                                   ^

ex.dfy(50,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    match e

   |
50 |     match e
   |            ^

ex.dfy(50,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    assert optE == e;\n', '    var left := match e { case Add(l, r) => l };\n', '    var optLeft := optimize(left);\n', '    match e\n', '    var optLeft := optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };

   |
51 |     var right := match e { case Add(l, r) => r };
   |                                                  ^

ex.dfy(51,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var right := match e { case Add(l, r) => r };\n', '    var right := match e { case Add(l, r) => r };\n', '    var right := match e { case Add(l, r) => r };\n', '    var right := match e { case Add(l, r) => r };\n', '    var right := match e { case Add(l, r) => r };\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };

   |
52 |     var optLeft := match optE { case Add(l, r) => l };
   |                                                       ^

ex.dfy(52,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := optimize(left);

   |
52 |     var optLeft := optimize(left);
   |                                   ^

ex.dfy(52,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var optLeft := match optE { case Add(l, r) => l };\n', '    var optLeft := optimize(left);\n', '    var optLeft := optimize(left);\n', '    var optLeft := optimize(left);\n', '    var optLeft := optimize(left);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };

   |
53 |     var optRight := match optE { case Add(l, r) => r };
   |                                                        ^

ex.dfy(53,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var optRight := match optE { case Add(l, r) => r };\n', '    var optRight := match optE { case Add(l, r) => r };\n', '    var optRight := match optE { case Add(l, r) => r };\n', '    var optRight := match optE { case Add(l, r) => r };\n', '    var optRight := match optE { case Add(l, r) => r };\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);

   |
54 |     assert optE == Add(optLeft, optRight);
   |                                           ^

ex.dfy(54,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    OptimizerSemantics(left, env);

   |
54 |     OptimizerSemantics(left, env);
   |                                   ^

ex.dfy(54,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert optE == Add(optLeft, optRight);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    assert optE == Add(optLeft, optRight);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);

   |
55 |     OptimizerSemantics(left, env);
   |                                   ^

ex.dfy(55,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n', '    OptimizerSemantics(left, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);

   |
56 |     OptimizerSemantics(right, env);
   |                                    ^

ex.dfy(56,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(right, env);\n', '    OptimizerSemantics(right, env);\n', '    OptimizerSemantics(right, env);\n', '    OptimizerSemantics(right, env);\n', '    OptimizerSemantics(right, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);
  }

   |
57 |   }
   |    ^

ex.dfy(57,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);
    OptimizerSemantics(optLeft, env);

   |
57 |     OptimizerSemantics(optLeft, env);
   |                                      ^

ex.dfy(57,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '    OptimizerSemantics(optLeft, env);\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);
    OptimizerSemantics(optLeft, env);
    OptimizerSemantics(optRight, env);

   |
58 |     OptimizerSemantics(optRight, env);
   |                                       ^

ex.dfy(58,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerSemantics(optRight, env);\n', '    OptimizerSemantics(optRight, env);\n', '    OptimizerSemantics(optRight, env);\n', '    OptimizerSemantics(optRight, env);\n', '    OptimizerSemantics(optRight, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);
    OptimizerSemantics(optLeft, env);
    OptimizerSemantics(optRight, env);
  }

   |
59 |   }
   |    ^

ex.dfy(59,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(left: Expr, right: Expr)
```

```dafny
// Evaluator
function eval(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => eval(left, env) + eval(right, env)
}
```

```dafny
// Optimizer
function optimize(e: Expr): Expr
{
  match e
  case Add(left, right) =>
    var optLeft := optimize(left);
    var optRight := optimize(right);
    if optLeft == Const(0) then optRight
    else if optRight == Const(0) then optLeft
    else Add(optLeft, optRight)
  case _ => e
}
```

```dafny
// Lemma that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  // Base case: Const
  if e == Const(0) {}
  // Base case: Var
  else if e == Var(0) {}
  // Base case: Add
  else if e == Add(Const(0), right) {
    OptimizerSemantics(right, env);
  }
  else if e == Add(left, Const(0)) {
    OptimizerSemantics(left, env);
  }
  else {
    // Inductive case
    var optE := optimize(e);
    var left := match e { case Add(l, r) => l };
    var right := match e { case Add(l, r) => r };
    var optLeft := match optE { case Add(l, r) => l };
    var optRight := match optE { case Add(l, r) => r };
    assert optE == Add(optLeft, optRight);
    OptimizerSemantics(left, env);
    OptimizerSemantics(right, env);
    OptimizerSemantics(optLeft, env);
    OptimizerSemantics(optRight, env);
  }
}

   |
41 |   else if e == Add(Const(0), right) {
   |                              ^^^^^

ex.dfy(41,29): Error: unresolved identifier: right
   |
42 |     OptimizerSemantics(right, env);
   |                        ^^^^^

ex.dfy(42,23): Error: unresolved identifier: right
   |
44 |   else if e == Add(left, Const(0)) {
   |                    ^^^^

ex.dfy(44,19): Error: unresolved identifier: left
   |
45 |     OptimizerSemantics(left, env);
   |                        ^^^^

ex.dfy(45,23): Error: unresolved identifier: left
   |
39 |   else if e == Var(0) {}
   |                ^^^

ex.dfy(39,15): Error: incorrect argument type for datatype constructor parameter 'name' (expected string, found int)
5 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 45
number of gen nodes: 23 (including leaves: 1)
number of back nodes: 22 (including leaves: 22)

expansion count: 27 (including failed: 5)

cache stats {'hit': 301, 'miss': 159}
calls to generate 92
Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Define the ADT for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Arithmetic expressions

SCORE
1.0
['datatype Expr =\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', '// Define the ADT for arithmetic expressions\n', '// Arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    | Constant(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    | Const(val: int)

SCORE
1.0
['  | Const(val: int)\n', '    | Constant(n: int)\n', '  | Const(n: int)\n', '  | Const(val: int)\n', '    | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(x: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)

SCORE
1.0
['  | Var(x: string)\n', '  | Var(x: string)\n', '  | Var(x: string)\n', '  | Var(name: string)\n', '  | Var(x: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(l: Expr, r: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(l: Expr, r: Expr)\n', '  | Add(l: Expr, r: Expr)\n', '  | Add(lhs: Expr, rhs: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string => int): int

  |
6 | function method Eval(e: Expr, env: string => int): int
  |                                           ^

ex.dfy(6,42): Error: closeparen expected
  |
6 | function method Eval(e: Expr, env: string => int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function method Eval(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int
  reads env

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '{\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int
  reads env
  modifies env

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
8 |   modifies env
  |   ^

ex.dfy(8,2): Error: this symbol not expected in Dafny
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int
  reads env
  decreases e

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int
  reads env
  modifies nothing

  |
6 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(6,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
8 |   modifies nothing
  |   ^

ex.dfy(8,2): Error: this symbol not expected in Dafny
2 parse errors detected in ex.dfy

SCORE
-1.0
['  modifies env\n', '  decreases e\n', '  modifies env\n', '  decreases e\n', '  modifies nothing\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string => int): int

  |
6 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(6,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
  {

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
  |
7 |   {
  |    ^

ex.dfy(7,3): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
  reads env

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
{

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  reads env\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int
  {
    match e

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
  |
8 |     match e
  |            ^

ex.dfy(8,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string => int): int

  |
6 | function Evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(6,39): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
  reads env

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '{\n', '{\n', '{\n', '  reads env\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n

  |
9 |   case Const(n) => n
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n', '  case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
11 |   case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                        ^

ex.dfy(11,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)

   |
17 |   case Add(Const(0), rhs) => Optimize(rhs)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, Const(0)) => Optimize(lhs)

   |
17 |   case Add(lhs, Const(0)) => Optimize(lhs)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), rhs) => Optimize(rhs)\n', '  case Add(Const(0), rhs) => Optimize(rhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)

   |
18 |   case Add(lhs, Const(0)) => Optimize(lhs)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))

   |
19 |   case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
   |                                                          ^

ex.dfy(19,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n', '  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n', '  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n', '  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n', '  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEval(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(e, env) == Eval(Optimize(e), env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', '  ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases

   |
27 |   // Base cases
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // base cases

   |
27 |   // base cases
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n', '  // Base cases\n', '  // Base cases\n', '  // base cases\n', '  // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) then {

   |
28 |   if e == Const(0) then {
   |                    ^

ex.dfy(28,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {

   |
28 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) {

   |
28 |   if e == Const(0) {
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) then {\n', '  if e == Const(0) || e == Var(_) {\n', '  if e == Const(0) {\n', '  if e == Const(0) {\n', '  if e == Const(0) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) then {
  } else if e == Var(0) then {

   |
28 |   if e == Const(0) then {
   |                    ^

ex.dfy(28,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) then {
  } else if e == Var(_) then {

   |
28 |   if e == Const(0) then {
   |                    ^

ex.dfy(28,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) then {
    assert Eval(Optimize(e), env) == Eval(e, env);

   |
28 |   if e == Const(0) then {
   |                    ^

ex.dfy(28,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Var(0) then {\n', '  } else if e == Var(_) then {\n', '  } else if e == Var(_) then {\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n', '  } else if e == Var(_) then {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base cases
  if e == Const(0) then {
    assert Eval(Optimize(e), env) == Eval(e, env);
  } else if e == Var(_) then {

   |
28 |   if e == Const(0) then {
   |                    ^

ex.dfy(28,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  } else if e == Var(_) then {\n', '  } else if e == Var(_) then {\n', '  } else if e == Var(_) then {\n', '  } else if e == Var(_) then {\n', '  } else if e == Var(_) then {\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case

   |
27 |   // Base case
   |               ^

ex.dfy(27,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // base case

   |
27 |   // base case
   |               ^

ex.dfy(27,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var

   |
27 |   // Base case: Const or Var
   |                             ^

ex.dfy(27,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  // Base case\n', '  // base case\n', '  // Base case: Const or Var\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  if e is Const || e is Var {}

   |
28 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(28,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  if e is Const || e is Var {

   |
28 |   if e is Const || e is Var {
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  if e == Const(_) || e == Var(_) {

   |
28 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add

   |
28 |   // Inductive case: Add
   |                         ^

ex.dfy(28,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n', '  if e == Const(_) || e == Var(_) {\n', '  if e is Const || e is Var {}\n', '  // Inductive case: Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  match e

   |
29 |   match e
   |          ^

ex.dfy(29,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)

   |
29 |   // Recursive call: Optimize(lhs) and Optimize(rhs)
   |                                                     ^

ex.dfy(29,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '  match e\n', '}\n', '  // Recursive call: Optimize(lhs) and Optimize(rhs)\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e

   |
30 |   // Use match e to destructure the input expression e
   |                                                       ^

ex.dfy(30,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
}

SCORE
1.0
['  // Use match e to destructure the input expression e\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e
  match e

   |
31 |   match e
   |          ^

ex.dfy(31,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '  match e\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e
}
``` import React from 'react'

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e
}
```

SCORE
1.0
["``` import React from 'react'\n", '```\n', '```\n', '```\n', '```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)
  | Var(name: string)
  | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e
  case Const(n) => n
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)
  case Add(lhs, Const(0)) => Optimize(lhs)
  case Add(lhs, rhs) => Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
  // Base case: Const or Var
  // Inductive case: Add
  // Recursive call: Optimize(lhs) and Optimize(rhs)
  // Use match e to destructure the input expression e
}
```


STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 2)
number of back nodes: 16 (including leaves: 15)

expansion count: 19 (including failed: 3)

cache stats {'hit': 138, 'miss': 82}
calls to generate 44
Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
['datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr =\n', 'datatype Expr = Const(val: int)\n', '// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n', '             | Var(name: string)\n', '              | Var(name: string)\n', '             | Var(name: string)\n', '              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int {

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  |                                                                               ^

ex.dfy(5,78): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func(string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: func(string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func(string) returns (int)): int
  |                                                 ^

ex.dfy(5,48): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func(string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function method Evaluate(e: Expr, env: function (string) returns (int)): int {\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: func(string) returns (int)): int\n', 'function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int {
    match e

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int {
    match e
    case Const(val) => val

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                           ^

ex.dfy(5,74): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function(string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                                                          ^

ex.dfy(5,73): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  |                                                         ^

ex.dfy(5,56): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int {\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: function(string) returns (int)): int {\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
10 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                          ^

ex.dfy(10,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), rhs) => Optimize(rhs)

   |
16 |     case Add(Const(0), rhs) => Optimize(rhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 

   |
16 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(16,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => Optimize(rhs)\n', '    case Add(Const(0), rhs) => Optimize(rhs)\n', '    case Add(Const(0), rhs) => Optimize(rhs)\n', '    case Add(lhs, rhs) => \n', '    case Add(lhs, rhs) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        var lhs_opt := Optimize(lhs);

   |
17 |         var lhs_opt := Optimize(lhs);
   |                                      ^

ex.dfy(17,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        var l := Optimize(lhs);

   |
17 |         var l := Optimize(lhs);
   |                                ^

ex.dfy(17,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        var newLhs := Optimize(lhs);

   |
17 |         var newLhs := Optimize(lhs);
   |                                     ^

ex.dfy(17,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)

   |
17 |         if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
   |                                                       ^

ex.dfy(17,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        var lhs_opt := Optimize(lhs);\n', '        var l := Optimize(lhs);\n', '        var newLhs := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)

   |
18 |         else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
   |                                                            ^

ex.dfy(18,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)\n', '        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)\n', '        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)\n', '        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)\n', '        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))

   |
19 |         else Add(Optimize(lhs), Optimize(rhs))
   |                                               ^

ex.dfy(19,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else Add(Optimize(lhs), Optimize(rhs))\n', '        else Add(Optimize(lhs), Optimize(rhs))\n', '        else Add(Optimize(lhs), Optimize(rhs))\n', '        else Add(Optimize(lhs), Optimize(rhs))\n', '        else Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesEval(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr)\n', 'lemma OptimizePreservesEval(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['{\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'requires Eval(e, env) == Eval(Optimize(e), env)\n', 'requires true\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    if e is Const || e is Var {

   |
27 |     if e is Const || e is Var {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a constant or variable, the claim is trivially true.

   |
27 |     // Base case: if e is a constant or variable, the claim is trivially true.
   |                                                                               ^

ex.dfy(27,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e

   |
27 |     match e
   |            ^

ex.dfy(27,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.

   |
27 |     // Base case: if e is a leaf (Const or Var), the property holds.
   |                                                                     ^

ex.dfy(27,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const || e is Var {\n', '    // Base case: if e is a constant or variable, the claim is trivially true.\n', '    match e\n', '    // Base case: if e is a leaf (Const or Var), the property holds.\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    if e is Const || e is Var {

   |
28 |     if e is Const || e is Var {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version

   |
28 |     // Inductive case: if e is an Add, we need to prove that the optimized version
   |                                                                                   ^

ex.dfy(28,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    if e is Const || e is Var {}

   |
28 |     if e is Const || e is Var {}
   |                                 ^

ex.dfy(28,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    if e == Const(_) || e == Var(_) {

   |
28 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(28,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const || e is Var {\n', '    // Inductive case: if e is an Add, we need to prove that the optimized version\n', '    if e is Const || e is Var {}\n', '    if e is Const || e is Var {\n', '    if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // has the same effect as the original one.

   |
29 |     // has the same effect as the original one.
   |                                                ^

ex.dfy(29,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original

   |
29 |     // of the left-hand side and the right-hand side combined with the original
   |                                                                                ^

ex.dfy(29,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the evaluation is the same as the original one.

   |
29 |     // of the evaluation is the same as the original one.
   |                                                          ^

ex.dfy(29,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // still gives the same result as the original version.

   |
29 |     // still gives the same result as the original version.
   |                                                            ^

ex.dfy(29,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // still evaluates to the same value as the original one.

   |
29 |     // still evaluates to the same value as the original one.
   |                                                              ^

ex.dfy(29,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // has the same effect as the original one.\n', '    // of the left-hand side and the right-hand side combined with the original\n', '    // of the evaluation is the same as the original one.\n', '    // still gives the same result as the original version.\n', '    // still evaluates to the same value as the original one.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as evaluating e directly.

   |
30 |     // environment gives the same result as evaluating e directly.
   |                                                                   ^

ex.dfy(30,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with

   |
30 |     // environment gives the same result as the original expression combined with
   |                                                                                  ^

ex.dfy(30,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // right-hand side evaluates to the same result as the original expression.

   |
30 |     // right-hand side evaluates to the same result as the original expression.
   |                                                                                ^

ex.dfy(30,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // environment gives the same result as evaluating e directly.\n', '    // environment gives the same result as the original expression combined with\n', '    // environment gives the same result as the original expression combined with\n', '    // right-hand side evaluates to the same result as the original expression.\n', '    // environment gives the same result as the original expression combined with\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized environment.

   |
31 |     // the optimized environment.
   |                                  ^

ex.dfy(31,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment.

   |
31 |     // the optimized version of the environment.
   |                                                 ^

ex.dfy(31,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively

   |
31 |     // the optimized version of the environment. We do this by recursively
   |                                                                           ^

ex.dfy(31,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // the optimized environment.\n', '    // the optimized environment.\n', '    // the optimized version of the environment.\n', '    // the optimized version of the environment. We do this by recursively\n', '    // the optimized version of the environment.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma with the sub-expressions.

   |
32 |     // calling the lemma with the sub-expressions.
   |                                                   ^

ex.dfy(32,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is

   |
32 |     // calling the lemma on the sub-expressions and using the fact that Eval is
   |                                                                                ^

ex.dfy(32,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // invoking the lemma on the sub-expressions.

   |
32 |     // invoking the lemma on the sub-expressions.
   |                                                  ^

ex.dfy(32,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // calling the lemma with the sub-expressions.\n', '    // calling the lemma on the sub-expressions and using the fact that Eval is\n', '    // invoking the lemma on the sub-expressions.\n', '    // invoking the lemma on the sub-expressions.\n', '    // invoking the lemma on the sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism.

   |
33 |     // a homomorphism.
   |                       ^

ex.dfy(33,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // well-behaved.

   |
33 |     // well-behaved.
   |                     ^

ex.dfy(33,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between

   |
33 |     // a homomorphism (i.e., it preserves addition and the interaction between
   |                                                                               ^

ex.dfy(33,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // a homomorphism.\n', '    // well-behaved.\n', '    // well-behaved.\n', '    // well-behaved.\n', '    // a homomorphism (i.e., it preserves addition and the interaction between\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).

   |
34 |     // the environment and the expression).
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // variables and their values in the environment).

   |
34 |     // variables and their values in the environment).
   |                                                       ^

ex.dfy(34,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // addition and variables).

   |
34 |     // addition and variables).
   |                                ^

ex.dfy(34,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // addition and the environment).

   |
34 |     // addition and the environment).
   |                                      ^

ex.dfy(34,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // the environment and the expression).\n', '    // the environment and the expression).\n', '    // variables and their values in the environment).\n', '    // addition and variables).\n', '    // addition and the environment).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 

   |
35 |     //
   |       ^

ex.dfy(35,6): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
}

ex.dfy(26,0): Error: a postcondition could not be proved on this return path
   |
26 | {
   | ^

ex.dfy(25,8): Related location: this is the postcondition that could not be proved
   |
25 | ensures Eval(Optimize(e), env) == Eval(e, env)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['    // \n', '}\n', '    // \n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in

   |
36 |     // This lemma is not written because it's not clear how to express it in
   |                                                                             ^

ex.dfy(36,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is proved by structural induction on the expression e.

   |
36 |     // This lemma is proved by structural induction on the expression e.
   |                                                                         ^

ex.dfy(36,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // In Dafny, we can do this by pattern matching on e and then recursively

   |
36 |     // In Dafny, we can do this by pattern matching on e and then recursively
   |                                                                              ^

ex.dfy(36,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma can be automatically proved by Dafny.

   |
36 |     // This lemma can be automatically proved by Dafny.
   |                                                        ^

ex.dfy(36,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // The proof will be by structural induction on the expression e.

   |
36 |     // The proof will be by structural induction on the expression e.
   |                                                                      ^

ex.dfy(36,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    // This lemma is not written because it's not clear how to express it in\n", '    // This lemma is proved by structural induction on the expression e.\n', '    // In Dafny, we can do this by pattern matching on e and then recursively\n', '    // This lemma can be automatically proved by Dafny.\n', '    // The proof will be by structural induction on the expression e.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny without causing a loop with the mutual recursion between Eval and

   |
37 |     // Dafny without causing a loop with the mutual recursion between Eval and
   |                                                                               ^

ex.dfy(37,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny without causing looping problems or other difficulties.

   |
37 |     // Dafny without causing looping problems or other difficulties.
   |                                                                     ^

ex.dfy(37,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny without running into issues with recursive calls and quantifiers.

   |
37 |     // Dafny without running into issues with recursive calls and quantifiers.
   |                                                                               ^

ex.dfy(37,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny without running into issues with the termination checker.

   |
37 |     // Dafny without running into issues with the termination checker.
   |                                                                       ^

ex.dfy(37,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's

   |
37 |     // Dafny, since it requires a more sophisticated reasoning than Dafny's
   |                                                                            ^

ex.dfy(37,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Dafny without causing a loop with the mutual recursion between Eval and\n', '    // Dafny without causing looping problems or other difficulties.\n', '    // Dafny without running into issues with recursive calls and quantifiers.\n', '    // Dafny without running into issues with the termination checker.\n', "    // Dafny, since it requires a more sophisticated reasoning than Dafny's\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's
    // automated reasoning is capable of.

   |
38 |     // automated reasoning is capable of.
   |                                          ^

ex.dfy(38,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's
    // automated reasoning can handle.

   |
38 |     // automated reasoning can handle.
   |                                       ^

ex.dfy(38,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's
    // automated reasoning can currently handle.

   |
38 |     // automated reasoning can currently handle.
   |                                                 ^

ex.dfy(38,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's
    // automated reasoning is currently capable of.

   |
38 |     // automated reasoning is currently capable of.
   |                                                    ^

ex.dfy(38,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // automated reasoning is capable of.\n', '    // automated reasoning can handle.\n', '    // automated reasoning can handle.\n', '    // automated reasoning can currently handle.\n', '    // automated reasoning is currently capable of.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: if e is a leaf (Const or Var), the property holds.
    // Inductive case: if e is an Add, we need to prove that the optimized version
    // of the left-hand side and the right-hand side combined with the original
    // environment gives the same result as the original expression combined with
    // the optimized version of the environment. We do this by recursively
    // calling the lemma on the sub-expressions and using the fact that Eval is
    // a homomorphism (i.e., it preserves addition and the interaction between
    // the environment and the expression).
    // 
    // This lemma is not written because it's not clear how to express it in
    // Dafny, since it requires a more sophisticated reasoning than Dafny's
    // automated reasoning can handle.
}

ex.dfy(26,0): Error: a postcondition could not be proved on this return path
   |
26 | {
   | ^

ex.dfy(25,8): Related location: this is the postcondition that could not be proved
   |
25 | ensures Eval(Optimize(e), env) == Eval(e, env)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case

   |
27 |     // base case
   |                 ^

ex.dfy(27,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases

   |
27 |     // Base cases
   |                  ^

ex.dfy(27,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const || e is Var {\n', '    // base case\n', '    if e is Const || e is Var {\n', '    match e\n', '    // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e is Const || e is Var {

   |
28 |     if e is Const || e is Var {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }

   |
28 |     if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                        ^

ex.dfy(28,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(_) || e == Var(_) {

   |
28 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(28,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const || e is Var {\n', '    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    if e == Const(_) || e == Var(_) {\n', '    if e is Const || e is Var {\n', '    if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(0) { assert Eval(Optimize(e), env) == Eval(e, env); }

   |
29 |     else if e == Var(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                           ^

ex.dfy(29,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

   |
29 |     else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                           ^

ex.dfy(29,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e == Var(0) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    else if e == Var(0) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }


   |
29 |     else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                           ^

ex.dfy(29,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Add(Const(0), rhs) { assert Eval(Optimize(e), env) == Eval(e, env); }

   |
30 |     else if e == Add(Const(0), rhs) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                                       ^

ex.dfy(30,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Add(_, _) {

   |
30 |     else if e == Add(_, _) {
   |                             ^

ex.dfy(30,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
    // Recursive case

   |
30 |     // Recursive case
   |                      ^

ex.dfy(30,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
    

   |
29 |     else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                                                                           ^

ex.dfy(29,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '    else if e == Add(Const(0), rhs) { assert Eval(Optimize(e), env) == Eval(e, env); }\n', '    else if e == Add(_, _) {\n', '    // Recursive case\n', '    \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Inductive case

   |
31 |     // Inductive case
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add

   |
31 |     // Recursive case for Add
   |                              ^

ex.dfy(31,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Inductive step

   |
31 |     // Inductive step
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case\n', '    // Recursive case for Add\n', '    // Inductive case\n', '    // Inductive step\n', '    // Recursive case for Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {

   |
32 |     else if e == Add(_, _) {
   |                             ^

ex.dfy(32,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e == Add(_, _) {\n', '    else if e == Add(_, _) {\n', '    else if e == Add(_, _) {\n', '    else if e == Add(_, _) {\n', '    else if e == Add(_, _) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        match e

   |
33 |         match e
   |                ^

ex.dfy(33,15): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e.lhs;

   |
33 |         var lhs := e.lhs;
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        // TODO: Write the recursive case for the lemma.

   |
33 |         // TODO: Write the recursive case for the lemma.
   |                                                         ^

ex.dfy(33,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;

   |
33 |         var lhs := e as Add;
   |                             ^

ex.dfy(33,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match e\n', '        var lhs := e.lhs;\n', '        // TODO: Write the recursive case for the lemma.\n', '        var lhs := e as Add;\n', '        var lhs := e as Add;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);

   |
34 |         var optLhs := Optimize(lhs.lhs);
   |                                         ^

ex.dfy(34,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        OptimizePreservesSemantics(lhs.lhs, env);

   |
34 |         OptimizePreservesSemantics(lhs.lhs, env);
   |                                                  ^

ex.dfy(34,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        assert Eval(Optimize(e), env) == Eval(lhs.lhs, env) + Eval(Optimize(lhs.rhs), env);

   |
34 |         assert Eval(Optimize(e), env) == Eval(lhs.lhs, env) + Eval(Optimize(lhs.rhs), env);
   |                                                                                            ^

ex.dfy(34,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var optLhs := Optimize(lhs.lhs);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        assert Eval(Optimize(e), env) == Eval(lhs.lhs, env) + Eval(Optimize(lhs.rhs), env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

   |
35 |         var optRhs := Optimize(lhs.rhs);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var optRhs := Optimize(lhs.rhs);\n', '        var optRhs := Optimize(lhs.rhs);\n', '        var optRhs := Optimize(lhs.rhs);\n', '        var optRhs := Optimize(lhs.rhs);\n', '        var optRhs := Optimize(lhs.rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);
        OptimizePreservesSemantics(lhs.lhs, env);

   |
36 |         OptimizePreservesSemantics(lhs.lhs, env);
   |                                                  ^

ex.dfy(36,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);


   |
35 |         var optRhs := Optimize(lhs.rhs);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);
        assert Eval(Add(optLhs, optRhs), env) == Eval(e, env);

   |
36 |         assert Eval(Add(optLhs, optRhs), env) == Eval(e, env);
   |                                                               ^

ex.dfy(36,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '\n', '\n', '        assert Eval(Add(optLhs, optRhs), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively for lhs and rhs

   |
37 |         // Call lemma recursively for lhs and rhs
   |                                                  ^

ex.dfy(37,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Recursive calls

   |
37 |         // Recursive calls
   |                           ^

ex.dfy(37,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Recursive call

   |
37 |         // Recursive call
   |                          ^

ex.dfy(37,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        OptimizePreservesSemantics(lhs.lhs, env);

   |
37 |         OptimizePreservesSemantics(lhs.lhs, env);
   |                                                  ^

ex.dfy(37,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively

   |
37 |         // Call lemma recursively
   |                                  ^

ex.dfy(37,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Call lemma recursively for lhs and rhs\n', '        // Recursive calls\n', '        // Recursive call\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        // Call lemma recursively\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);

   |
38 |         OptimizePreservesSemantics(lhs.lhs, env);
   |                                                  ^

ex.dfy(38,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n', '        OptimizePreservesSemantics(lhs.lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

   |
39 |         OptimizePreservesSemantics(lhs.rhs, env);
   |                                                  ^

ex.dfy(39,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(lhs.rhs, env);\n', '        OptimizePreservesSemantics(lhs.rhs, env);\n', '        OptimizePreservesSemantics(lhs.rhs, env);\n', '        OptimizePreservesSemantics(lhs.rhs, env);\n', '        OptimizePreservesSemantics(lhs.rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);


   |
39 |         OptimizePreservesSemantics(lhs.rhs, env);
   |                                                  ^

ex.dfy(39,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);

   |
41 |         assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
   |                                                                                   ^

ex.dfy(41,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Prove that the optimization did not change the result

   |
41 |         // Prove that the optimization did not change the result
   |                                                                 ^

ex.dfy(41,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Assert the result

   |
41 |         // Assert the result
   |                             ^

ex.dfy(41,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the induction hypothesis

   |
41 |         // Use the induction hypothesis
   |                                        ^

ex.dfy(41,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize

   |
41 |         // Use the fact that Eval is monotonic with respect to Optimize
   |                                                                        ^

ex.dfy(41,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);\n', '        // Prove that the optimization did not change the result\n', '        // Assert the result\n', '        // Use the induction hypothesis\n', '        // Use the fact that Eval is monotonic with respect to Optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);

   |
42 |         assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
   |                                                                                   ^

ex.dfy(42,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(optLhs, env) == Eval(lhs.lhs, env);

   |
42 |         assert Eval(optLhs, env) == Eval(lhs.lhs, env);
   |                                                        ^

ex.dfy(42,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(optLhs, env) <= Eval(lhs.lhs, env);

   |
42 |         assert Eval(optLhs, env) <= Eval(lhs.lhs, env);
   |                                                        ^

ex.dfy(42,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);\n', '        assert Eval(optLhs, env) == Eval(lhs.lhs, env);\n', '        assert Eval(optLhs, env) == Eval(lhs.lhs, env);\n', '        assert Eval(optLhs, env) <= Eval(lhs.lhs, env);\n', '        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
    }

   |
43 |     }
   |      ^

ex.dfy(43,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
        assert Eval(Optimize(e), env) == Eval(Add(optLhs, optRhs), env);

   |
43 |         assert Eval(Optimize(e), env) == Eval(Add(optLhs, optRhs), env);
   |                                                                         ^

ex.dfy(43,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '        assert Eval(Optimize(e), env) == Eval(Add(optLhs, optRhs), env);\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) => 
        if Eval(lhs, (x) => 0) == 0 then Optimize(rhs)
        else if Eval(rhs, (x) => 0) == 0 then Optimize(lhs)
        else Add(Optimize(lhs), Optimize(rhs))
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) { assert Eval(Optimize(e), env) == Eval(e, env); }
    else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }

    // Recursive case for Add
    else if e == Add(_, _) {
        var lhs := e as Add;
        var optLhs := Optimize(lhs.lhs);
        var optRhs := Optimize(lhs.rhs);

        // Call lemma recursively
        OptimizePreservesSemantics(lhs.lhs, env);
        OptimizePreservesSemantics(lhs.rhs, env);

        // Use the fact that Eval is monotonic with respect to Optimize
        assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
    }
}

   |
29 |     else if e == Var(_) { assert Eval(Optimize(e), env) == Eval(e, env); }
   |                      ^

ex.dfy(29,21): Error: unresolved identifier: _
   |
32 |     else if e == Add(_, _) {
   |                      ^

ex.dfy(32,21): Error: unresolved identifier: _
   |
32 |     else if e == Add(_, _) {
   |                         ^

ex.dfy(32,24): Error: unresolved identifier: _
   |
33 |         var lhs := e as Add;
   |                         ^^^

ex.dfy(33,24): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
34 |         var optLhs := Optimize(lhs.lhs);
   |                                    ^^^

ex.dfy(34,35): Error: type of the receiver is not fully determined at this program point
   |
35 |         var optRhs := Optimize(lhs.rhs);
   |                                    ^^^

ex.dfy(35,35): Error: type of the receiver is not fully determined at this program point
   |
38 |         OptimizePreservesSemantics(lhs.lhs, env);
   |                                        ^^^

ex.dfy(38,39): Error: type of the receiver is not fully determined at this program point
   |
39 |         OptimizePreservesSemantics(lhs.rhs, env);
   |                                        ^^^

ex.dfy(39,39): Error: type of the receiver is not fully determined at this program point
   |
42 |         assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
   |                                                               ^^^

ex.dfy(42,62): Error: type of the receiver is not fully determined at this program point
   |
42 |         assert Eval(Add(optLhs, optRhs), env) == Eval(Add(lhs.lhs, lhs.rhs), env);
   |                                                                        ^^^

ex.dfy(42,71): Error: type of the receiver is not fully determined at this program point
10 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 27
number of gen nodes: 14 (including leaves: 1)
number of back nodes: 13 (including leaves: 13)

expansion count: 16 (including failed: 3)

cache stats {'hit': 163, 'miss': 142}
calls to generate 61
Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Abstract Data Type for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = Const(val: int)\n', 'datatype Expr = Const(n: int)\n', '// Abstract Data Type for arithmetic expressions\n', 'datatype Expr =\n', 'datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n', '             | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['             | Add(left: Expr, right: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: function(string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                                                          ^

ex.dfy(5,73): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function(string) returns (int)): int {\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: function(string) returns (int)): int {
    match e

  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: function(string) returns (int)): int {
    match e
    case Const(val) => val

  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function(string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Evaluate(e: Expr, env: function(string) returns (int)): int

  |
5 | function method Evaluate(e: Expr, env: function(string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function(string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: function(string) returns (int)): int\n', 'function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '  reads env\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  decreases e

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
  reads e

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  decreases e\n', '  reads e\n', '{\n', '{\n', '  decreases e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val

  |
9 |   case Const(val) => val
  |                         ^

ex.dfy(9,24): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Eval(left, env) + Eval(right, env)

   |
11 |   case Add(left, right) => Eval(left, env) + Eval(right, env)
   |                                                              ^

ex.dfy(11,61): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(left, right) => Eval(left, env) + Eval(right, env)\n', '  case Add(left, right) => Eval(left, env) + Eval(right, env)\n', '  case Add(left, right) => Eval(left, env) + Eval(right, env)\n', '  case Add(left, right) => Eval(left, env) + Eval(right, env)\n', '  case Add(left, right) => Eval(left, env) + Eval(right, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(left, right) => Eval(left, env) + Eval(right, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int
{

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int
{
    match e

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function method Eval(e: Expr, env: func (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                         ^

ex.dfy(5,40): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                                  ^

ex.dfy(5,49): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: func (string) returns (int)): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{
  match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(left: Expr, right: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{
    match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n', '    match e\n', '    match e\n', '  match e\n', '    match e\n']
['             | Add(left: Expr, right: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(left: Expr, right: Expr)\n', '             | Add(left: Expr, right: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func (string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                         ^

ex.dfy(5,40): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                                  ^

ex.dfy(5,49): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                                                       ^

ex.dfy(5,70): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                         ^

ex.dfy(5,40): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                                  ^

ex.dfy(5,49): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function method Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: func (string) returns (int)): int {\n', 'function method Eval(e: Expr, env: func (string) returns (int)): int\n', 'function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
10 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                          ^

ex.dfy(10,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), rhs) => rhs

   |
16 |     case Add(Const(0), rhs) => rhs
   |                                   ^

ex.dfy(16,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>

   |
16 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(16,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |     case Add(lhs, Const(0)) => Optimize(lhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => rhs\n', '    case Add(lhs, rhs) =>\n', '    case Add(Const(0), rhs) => rhs\n', '    case Add(lhs, Const(0)) => Optimize(lhs)\n', '    case Add(lhs, Const(0)) => Optimize(lhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);

   |
17 |         var lhs_opt := Optimize(lhs);
   |                                      ^

ex.dfy(17,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var lhs_opt := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);

   |
18 |         var rhs_opt := Optimize(rhs);
   |                                      ^

ex.dfy(18,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt

   |
19 |         if lhs_opt == Const(0) then rhs_opt
   |                                            ^

ex.dfy(19,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt

   |
20 |         else if rhs_opt == Const(0) then lhs_opt
   |                                                 ^

ex.dfy(20,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)

   |
21 |         else Add(lhs_opt, rhs_opt)
   |                                   ^

ex.dfy(21,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e

   |
22 |     case _ => e
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesEval(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesEval(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['    ensures Eval(e, env) == Eval(Optimize(e), env)\n', '{\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)

   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    assert Eval(Optimize(e), env) == Eval(e, env);

   |
27 |     assert Eval(Optimize(e), env) == Eval(e, env);
   |                                                   ^

ex.dfy(27,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Eval(Optimize(e), env) == Eval(e, env)\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n', '    assert Eval(Optimize(e), env) == Eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)
}

   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)
}
```

   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)
}


   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['```\n', '\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)
}

method OptimizePreservesSemantics(e: Expr, env: string -> int)

   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{
    Eval(Optimize(e), env) == Eval(e, env)
}

method OptimizePreservesSemantics()

   |
27 |     Eval(Optimize(e), env) == Eval(e, env)
   |                            ^

ex.dfy(27,27): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['method OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'method OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'method OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'method OptimizePreservesSemantics()\n', 'method OptimizePreservesSemantics()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['requires true\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', '{\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'requires true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics

   |
29 |     // base case: if e is a constant or a variable, then the optimization does not change its semantics
   |                                                                                                        ^

ex.dfy(29,103): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    if e == Const(0) || e == Var(_) {

   |
29 |     if e == Const(0) || e == Var(_) {
   |                                      ^

ex.dfy(29,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    // base case: if e is a constant or a variable, then the optimization does not change its semantics\n', '    if e == Const(0) || e == Var(_) {\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e == Const(0) || e == Var(_)

   |
30 |     if e == Const(0) || e == Var(_)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}

   |
30 |     if e is Const || e is Var {}
   |                                 ^

ex.dfy(30,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {

   |
30 |     if e is Const || e is Var {
   |                                ^

ex.dfy(30,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e == Const(?val) || e == Var(?name) {

   |
30 |     if e == Const(?val) || e == Var(?name) {
   |                                             ^

ex.dfy(30,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e == Const(_) || e == Var(_) {

   |
30 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(30,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(0) || e == Var(_)\n', '    if e is Const || e is Var {}\n', '    if e is Const || e is Var {\n', '    if e == Const(?val) || e == Var(?name) {\n', '    if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma for its sub-expressions

   |
31 |     // inductive case: if e is an addition, then recursively prove the lemma for its sub-expressions
   |                                                                                                     ^

ex.dfy(31,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma

   |
31 |     // inductive case: if e is an addition, then recursively prove the lemma
   |                                                                             ^

ex.dfy(31,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    else if e is Add(lhs, rhs) {

   |
31 |     else if e is Add(lhs, rhs) {
   |                     ^

ex.dfy(31,20): Error: lbrace expected
   |
31 |     else if e is Add(lhs, rhs) {
   |                                ^

ex.dfy(31,31): Error: invalid Suffix
   |
31 |     else if e is Add(lhs, rhs) {
   |                     ^

ex.dfy(31,20): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    else if e is Add {}

   |
31 |     else if e is Add {}
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    else if e is Add {

   |
31 |     else if e is Add {
   |                       ^

ex.dfy(31,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // inductive case: if e is an addition, then recursively prove the lemma for its sub-expressions\n', '    // inductive case: if e is an addition, then recursively prove the lemma\n', '    else if e is Add(lhs, rhs) {\n', '    else if e is Add {}\n', '    else if e is Add {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add {

   |
32 |     else if e is Add {
   |                       ^

ex.dfy(32,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add

   |
32 |     else if e is Add
   |                     ^

ex.dfy(32,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e is Add {\n', '    else if e is Add {\n', '    else if e is Add\n', '    else if e is Add {\n', '    else if e is Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
    {

   |
33 |     {
   |      ^

ex.dfy(33,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions

   |
33 |         // optimize the sub-expressions
   |                                        ^

ex.dfy(33,39): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // recursively prove the lemma for the left-hand side and the right-hand side

   |
33 |         // recursively prove the lemma for the left-hand side and the right-hand side
   |                                                                                      ^

ex.dfy(33,85): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '        // optimize the sub-expressions\n', '        // recursively prove the lemma for the left-hand side and the right-hand side\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);

   |
34 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(34,8): Error: lbrace expected
   |
34 |         var lhs_opt := Optimize(e.lhs);
   |                                        ^

ex.dfy(34,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);

   |
34 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(34,8): Error: lbrace expected
   |
35 |         var rhs_opt := Optimize(e.rhs);
   |                                        ^

ex.dfy(35,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // prove that the optimization preserves the semantics

   |
34 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(34,8): Error: lbrace expected
   |
36 |         // prove that the optimization preserves the semantics
   |                                                               ^

ex.dfy(36,62): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // recursively prove the lemma for the optimized sub-expressions

   |
34 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(34,8): Error: lbrace expected
   |
36 |         // recursively prove the lemma for the optimized sub-expressions
   |                                                                         ^

ex.dfy(36,72): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // base case: if e is a constant or a variable, then the optimization does not change its semantics
    if e is Const || e is Var {}
    // inductive case: if e is an addition, then recursively prove the lemma
    else if e is Add
        // optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // prove that the optimized expression has the same semantics as the original one

   |
34 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(34,8): Error: lbrace expected
   |
36 |         // prove that the optimized expression has the same semantics as the original one
   |                                                                                          ^

ex.dfy(36,89): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        // prove that the optimization preserves the semantics\n', '        // recursively prove the lemma for the optimized sub-expressions\n', '        // prove that the optimized expression has the same semantics as the original one\n', '        // recursively prove the lemma for the optimized sub-expressions\n', '        // recursively prove the lemma for the optimized sub-expressions\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base cases

   |
29 |     // Base cases
   |                  ^

ex.dfy(29,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    if e == Const(_) || e == Var(_) {

   |
29 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(29,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case

   |
29 |     // Base case
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    if e is Const

   |
29 |     if e is Const
   |                  ^

ex.dfy(29,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base cases\n', '    if e == Const(_) || e == Var(_) {\n', '    match e\n', '    // Base case\n', '    if e is Const\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(?)

   |
30 |     if e == Const(0) || e == Var(?)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)

   |
30 |     if e == Const(0) || e == Var(_)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) {

   |
30 |     if e == Const(0) {
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(_) || e == Var(_)

   |
30 |     if e == Const(_) || e == Var(_)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(0) || e == Var(?)\n', '    if e == Const(0) || e == Var(_)\n', '    if e == Const(0) {\n', '    if e == Const(_) || e == Var(_)\n', '    if e == Const(0) || e == Var(_)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {

   |
31 |     {
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);

   |
32 |         assert Eval(e, env) == Eval(Optimize(e), env);
   |                                                       ^

ex.dfy(32,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '        assert Eval(e, env) == Eval(Optimize(e), env);\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }

   |
33 |     }
   |      ^

ex.dfy(33,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else

   |
34 |     else
   |         ^

ex.dfy(34,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else if e == Add(_, _)

   |
34 |     else if e == Add(_, _)
   |                           ^

ex.dfy(34,26): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else\n', '    else if e == Add(_, _)\n', '    else\n', '    else if e == Add(_, _)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {

   |
35 |     {
   |      ^

ex.dfy(35,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive case

   |
36 |         // Recursive case
   |                          ^

ex.dfy(36,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        match e

   |
36 |         match e
   |                ^

ex.dfy(36,15): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        assert e == Add(lhs, rhs) for some lhs, rhs;

   |
36 |         assert e == Add(lhs, rhs) for some lhs, rhs;
   |                                 ^

ex.dfy(36,32): Error: expected either 'by' or a semicolon following the assert expression
   |
36 |         assert e == Add(lhs, rhs) for some lhs, rhs;
   |                                            ^

ex.dfy(36,43): Error: gets expected
   |
36 |         assert e == Add(lhs, rhs) for some lhs, rhs;
   |                                            ^^^

ex.dfy(36,43): Error: Expected 'to' or 'downto'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step

   |
36 |         // Recursive step
   |                          ^

ex.dfy(36,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursive case\n', '        match e\n', '        assert e == Add(lhs, rhs) for some lhs, rhs;\n', '        match e\n', '        // Recursive step\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e

   |
37 |         match e
   |                ^

ex.dfy(37,15): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['        match e\n', '        match e\n', '        match e\n', '        match e\n', '        match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>

   |
38 |         case Add(lhs, rhs) =>
   |                              ^

ex.dfy(38,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(lhs, rhs) =>\n', '        case Add(lhs, rhs) =>\n', '        case Add(lhs, rhs) =>\n', '        case Add(lhs, rhs) =>\n', '        case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
            OptimizePreservesSemantics(lhs, env);

   |
39 |             OptimizePreservesSemantics(lhs, env);
   |                                                  ^

ex.dfy(39,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {

   |
39 |         {
   |          ^

ex.dfy(39,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
            assert Eval(e, env) == Eval(Optimize(e), env);

   |
39 |             assert Eval(e, env) == Eval(Optimize(e), env);
   |                                                           ^

ex.dfy(39,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(lhs, env);\n', '            OptimizePreservesSemantics(lhs, env);\n', '        {\n', '            assert Eval(e, env) == Eval(Optimize(e), env);\n', '        {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);

   |
40 |             OptimizePreservesSemantics(lhs, env);
   |                                                  ^

ex.dfy(40,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            var lhs_opt := Optimize(lhs);

   |
40 |             var lhs_opt := Optimize(lhs);
   |                                          ^

ex.dfy(40,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(lhs, env);\n', '            var lhs_opt := Optimize(lhs);\n', '            OptimizePreservesSemantics(lhs, env);\n', '            var lhs_opt := Optimize(lhs);\n', '            OptimizePreservesSemantics(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);

   |
41 |             OptimizePreservesSemantics(rhs, env);
   |                                                  ^

ex.dfy(41,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizePreservesSemantics(rhs, env);\n', '            OptimizePreservesSemantics(rhs, env);\n', '            OptimizePreservesSemantics(rhs, env);\n', '            OptimizePreservesSemantics(rhs, env);\n', '            OptimizePreservesSemantics(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
            assert Eval(lhs, env) == Eval(Optimize(lhs), env);

   |
42 |             assert Eval(lhs, env) == Eval(Optimize(lhs), env);
   |                                                               ^

ex.dfy(42,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
            assert Eval(e, env) == Eval(Optimize(e), env);

   |
42 |             assert Eval(e, env) == Eval(Optimize(e), env);
   |                                                           ^

ex.dfy(42,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }

   |
42 |         }
   |          ^

ex.dfy(42,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
            assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);

   |
42 |             assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);
   |                                                                                                           ^

ex.dfy(42,106): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            assert Eval(lhs, env) == Eval(Optimize(lhs), env);\n', '            assert Eval(e, env) == Eval(Optimize(e), env);\n', '        }\n', '            assert Eval(lhs, env) == Eval(Optimize(lhs), env);\n', '            assert Eval(lhs, env) + Eval(rhs, env) == Eval(Optimize(lhs), env) + Eval(Optimize(rhs), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
    }

   |
43 |     }
   |      ^

ex.dfy(43,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
        case _ => 

   |
43 |         case _ =>
   |                  ^

ex.dfy(43,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
        case _ => assert false;

   |
43 |         case _ => assert false;
   |                                ^

ex.dfy(43,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
        case _ => assert false; // dead code

   |
43 |         case _ => assert false; // dead code
   |                                             ^

ex.dfy(43,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '        case _ => \n', '        case _ => assert false;\n', '        case _ => assert false; // dead code\n', '        case _ => assert false;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
        case _ => assert false; // dead code
    }

   |
44 |     }
   |      ^

ex.dfy(44,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);
    }
    else
    {
        // Recursive step
        match e
        case Add(lhs, rhs) =>
        {
            OptimizePreservesSemantics(lhs, env);
            OptimizePreservesSemantics(rhs, env);
        }
        case _ => assert false; // dead code
    }
}

   |
30 |     if e == Const(0) || e == Var(_)
   |                                  ^

ex.dfy(30,33): Error: unresolved identifier: _
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 3)
number of back nodes: 16 (including leaves: 14)

expansion count: 23 (including failed: 7)

cache stats {'hit': 253, 'miss': 142}
calls to generate 79
Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['// ADT for arithmetic expressions\n', 'datatype Expr = \n', 'datatype Expr = Const(n: int)\n', '// ADT for arithmetic expressions\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr = \n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(value: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(val: int) 

SCORE
1.0
['  | Const(value: int)\n', '  | Const(v: int)\n', '    | Const(n: int)\n', '  | Const(val: int)\n', '    | Const(val: int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(x: string)

SCORE
1.0
['    | Var(name: string)\n', '    | Var(x: string)\n', '    | Var(x: string)\n', '    | Var(x: string)\n', '    | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

SCORE
1.0
['    | Add(e1: Expr, e2: Expr)\n', '    | Add(e1: Expr, e2: Expr)\n', '    | Add(e1: Expr, e2: Expr)\n', '    | Add(e1: Expr, e2: Expr)\n', '    | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions

SCORE
1.0
['// Evaluator\n', '// Evaluator for arithmetic expressions\n', '// Evaluator\n', '// Evaluator for arithmetic expressions\n', '// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: function (string) returns (int)): int

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function method Eval(e: Expr, env: function (string) returns (int)): int

  |
8 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(8,35): Error: invalid TypeAndToken
  |
8 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: function (string) returns (int)): int {

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
  |
8 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                    ^

ex.dfy(8,67): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: function (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: function (string) returns (int)): int {
    match e

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
  |
9 |     match e
  |            ^

ex.dfy(9,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: function (string) returns (int)): int {
    match e {

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
  |
9 |     match e {
  |              ^

ex.dfy(9,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e {\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: function (string) returns (int)): int {
    match e
    case Const(n) => n

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
   |
10 |     case Const(n) => n
   |                       ^

ex.dfy(10,22): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string => int): int

  |
8 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
8 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: function (string) returns (int)): int 

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function evaluate(e: Expr, env: string -> int): int\n', 'function eval(e: Expr, env: function (string) returns (int)): int \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string => int): int
{

  |
8 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function Eval(e: Expr, env: string => int): int
{
    match e

  |
8 | function Eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function

SCORE
1.0
['// Evaluator\n', '// Evaluator\n', '// Evaluator function\n', '// Evaluator\n', '// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function eval(e: Expr, env: function (string) returns (int)): int

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int

  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function Eval(e: Expr, env: string -> int): int

SCORE
1.0
['function eval(e: Expr, env: string -> int): int\n', 'function eval(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{
    match e

   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n

   |
11 |     case Const(n) => n
   |                       ^

ex.dfy(11,22): Error: rbrace expected
  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)

   |
12 |     case Var(name) => env(name)
   |                                ^

ex.dfy(12,31): Error: rbrace expected
  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

   |
13 |     case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
   |                                                      ^

ex.dfy(13,53): Error: rbrace expected
  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n', '    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
}

  |
8 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
8 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function eval(e: Expr, env: function (string) returns (int)): int 

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function method Eval(e: Expr, env: function (string) returns (int)): int

  |
8 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(8,35): Error: invalid TypeAndToken
  |
8 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(8,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function evaluate(e: Expr, env: function (string) returns (int)): int

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: function (string) returns (int)): int \n', 'function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function eval(e: Expr, env: function (string) returns (int)): int 
{

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int 
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator function
function eval(e: Expr, env: function (string) returns (int)): int 
{
    match e

  |
8 | function eval(e: Expr, env: function (string) returns (int)): int 
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
['\n', '\n', '\n', '\n', '\n']
['// Evaluator\n', '// Evaluator for arithmetic expressions\n', '// Evaluator for arithmetic expressions\n', '// Evaluator\n', '// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: function (string) returns (int)): int

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function Eval(e: Expr, env: function (string) returns (int)): int

  |
8 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(8,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string => int): int

  |
8 | function eval(e: Expr, env: string => int): int
  |                                    ^

ex.dfy(8,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: string => int): int

  |
8 | function evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(8,39): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function Eval(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: string => int): int\n', 'function evaluate(e: Expr, env: string => int): int\n', 'function evaluate(e: Expr, env: string => int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: function (string) returns (int)): int
{

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: function (string) returns (int)): int
    match e

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '    match e\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function evaluate(e: Expr, env: function (string) returns (int)): int
    match e
        case Const(n) => n

  |
8 | function evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
-1.0
['        case Const(n) => n\n', '        case Const(n) => n\n', '        case Const(n) => n\n', '        case Const(n) => n\n', '        case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function Evaluate(e: Expr, env: function(string) returns (int)): int

  |
8 | function Evaluate(e: Expr, env: function(string) returns (int)): int
  |                                 ^

ex.dfy(8,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function evaluate(e: Expr, env: string => int): int\n', 'function eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function(string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env

  |
9 |     reads env
  |           ^^^

ex.dfy(9,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '    reads env\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{
    match e

   |
11 |     match e
   |            ^

ex.dfy(11,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{
    match e
    case Const(n) => n

   |
12 |     case Const(n) => n
   |                       ^

ex.dfy(12,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{
    match e
    case Const(n) => n
    case Var(name) => env(name)

   |
13 |     case Var(name) => env(name)
   |                                ^

ex.dfy(13,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
14 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(14,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    reads env
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

  |
9 |     reads env
  |           ^^^

ex.dfy(9,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0

  |
9 |     requires forall x | x in env.Keys :: env[x] >= 0
  |                                  ^^^^

ex.dfy(9,33): Error: member 'Keys' does not exist in function type '_#Func1'
  |
9 |     requires forall x | x in env.Keys :: env[x] >= 0
  |                                             ^

ex.dfy(9,44): Error: element selection requires a sequence, array, multiset, or map (got string -> int)
2 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    match e

  |
9 |     match e
  |     ^

ex.dfy(9,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '    requires forall x | x in env.Keys :: env[x] >= 0\n', '    match e\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{
    match e

   |
11 |     match e
   |            ^

ex.dfy(11,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{
    match e
    case Const(n) => n

   |
12 |     case Const(n) => n
   |                       ^

ex.dfy(12,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{
    match e
    case Const(n) => n
    case Var(name) => env[name]

   |
13 |     case Var(name) => env[name]
   |                                ^

ex.dfy(13,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env[name]\n', '    case Var(name) => env[name]\n', '    case Var(name) => env[name]\n', '    case Var(name) => env[name]\n', '    case Var(name) => env[name]\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{
    match e
    case Const(n) => n
    case Var(name) => env[name]
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
14 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(14,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n', '    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator for arithmetic expressions
function eval(e: Expr, env: string -> int): int
    requires forall x | x in env.Keys :: env[x] >= 0
{
    match e
    case Const(n) => n
    case Var(name) => env[name]
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
}

  |
9 |     requires forall x | x in env.Keys :: env[x] >= 0
  |                                  ^^^^

ex.dfy(9,33): Error: member 'Keys' does not exist in function type '_#Func1'
  |
9 |     requires forall x | x in env.Keys :: env[x] >= 0
  |                                             ^

ex.dfy(9,44): Error: element selection requires a sequence, array, multiset, or map (got string -> int)
   |
13 |     case Var(name) => env[name]
   |                          ^

ex.dfy(13,25): Error: element selection requires a sequence, array, multiset, or map (got string -> int)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int

SCORE
1.0
['function Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function eval(e: Expr, env: string -> int): int\n', 'function evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e

   |
10 |     match e
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n

   |
11 |     case Const(n) => n
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n', '    case Const(n) => n\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)

   |
12 |     case Var(name) => env(name)
   |                                ^

ex.dfy(12,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)

   |
13 |     case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
   |                                                              ^

ex.dfy(13,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n', '    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n', '    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n', '    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n', '    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer

SCORE
1.0
['// Optimizer\n', '// Optimizer\n', '// Optimizer\n', '// Optimizer\n', '// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr

SCORE
1.0
['function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n', 'function optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
    reads this

   |
18 |     reads this
   |           ^^^^

ex.dfy(18,10): Error: 'this' is not allowed in a 'static' context
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '    reads this\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e

   |
19 |     match e
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)

   |
20 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(20,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
21 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(21,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
22 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(22,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
23 |     case _ => e
   |                ^

ex.dfy(23,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma for optimizer preserving semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma to prove that the optimizer preserves the semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma to prove that the optimizer preserves semantics

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma

SCORE
1.0
['// Lemma for optimizer preserving semantics\n', '// Lemma to prove that the optimizer preserves the semantics\n', '// Lemma to prove that the optimizer preserves semantics\n', '// Lemma\n', '// Lemma\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures evaluate(optimize(e), env) == evaluate(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    requires true\n', '    ensures evaluate(optimize(e), env) == evaluate(e, env)\n', '{\n', '    ensures evaluate(optimize(e), env) == evaluate(e, env)\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(optimize(e), env) == evaluate(e, env)

SCORE
1.0
['    ensures evaluate(e, env) == evaluate(optimize(e), env)\n', '    ensures evaluate(e, env) == evaluate(optimize(e), env)\n', '    ensures evaluate(optimize(e), env) == evaluate(e, env)\n', '    ensures evaluate(optimize(e), env) == evaluate(e, env)\n', '    ensures evaluate(optimize(e), env) == evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{

   |
30 | {
   |  ^

ex.dfy(30,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const

   |
31 |     // Base case: Const
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    match e

   |
31 |     match e
   |            ^

ex.dfy(31,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Const\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const

   |
32 |     if e is Const
   |                  ^

ex.dfy(32,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const && e is not Add

   |
32 |     if e is Const && e is not Add
   |                               ^

ex.dfy(32,30): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e == Const(0) {

   |
32 |     if e == Const(0) {
   |                       ^

ex.dfy(32,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e is Const\n', '    if e is Const\n', '    if e is Const && e is not Add\n', '    if e == Const(0) {\n', '    if e is Const\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {

   |
33 |     {
   |      ^

ex.dfy(33,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var

   |
35 |     // Base case: Var
   |                      ^

ex.dfy(35,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Var\n', '    // Base case: Var\n', '    // Base case: Var\n', '    // Base case: Var\n', '    // Base case: Var\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var

   |
36 |     else if e is Var
   |                     ^

ex.dfy(36,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e is Var\n', '    else if e is Var\n', '    else if e is Var\n', '    else if e is Var\n', '    else if e is Var\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {

   |
37 |     {
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }

   |
38 |     }
   |      ^

ex.dfy(38,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add

   |
39 |     // Inductive case: Add
   |                           ^

ex.dfy(39,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: Add\n', '    // Inductive case: Add\n', '    // Inductive case: Add\n', '    // Inductive case: Add\n', '    // Inductive case: Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add

   |
40 |     else if e is Add
   |                     ^

ex.dfy(40,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e is Add\n', '    else if e is Add\n', '    else if e is Add\n', '    else if e is Add\n', '    else if e is Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {

   |
41 |     {
   |      ^

ex.dfy(41,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        var e1 := e.e1;

   |
42 |         var e1 := e.e1;
   |                        ^

ex.dfy(42,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // recursively call lemma for sub-expressions

   |
42 |         // recursively call lemma for sub-expressions
   |                                                      ^

ex.dfy(42,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls

   |
42 |         // Recursive calls
   |                           ^

ex.dfy(42,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        assert e == Add(e1, e2);

   |
42 |         assert e == Add(e1, e2);
   |                                 ^

ex.dfy(42,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var e1 := e.e1;\n', '        // recursively call lemma for sub-expressions\n', '        // Recursive calls\n', '        var e1 := e.e1;\n', '        assert e == Add(e1, e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        OptimizePreservesSemantics(e.e1, env);

   |
43 |         OptimizePreservesSemantics(e.e1, env);
   |                                               ^

ex.dfy(43,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);

   |
43 |         assert OptimizePreservesSemantics(e.e1, env);
   |                                                      ^

ex.dfy(43,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        OptimizePreservesSemantics(e.e1, env);\n', '        OptimizePreservesSemantics(e.e1, env);\n', '        assert OptimizePreservesSemantics(e.e1, env);\n', '        OptimizePreservesSemantics(e.e1, env);\n', '        OptimizePreservesSemantics(e.e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);

   |
44 |         assert OptimizePreservesSemantics(e.e2, env);
   |                                                      ^

ex.dfy(44,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert OptimizePreservesSemantics(e.e2, env);\n', '        assert OptimizePreservesSemantics(e.e2, env);\n', '        assert OptimizePreservesSemantics(e.e2, env);\n', '        assert OptimizePreservesSemantics(e.e2, env);\n', '        assert OptimizePreservesSemantics(e.e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);
    }

   |
45 |     }
   |      ^

ex.dfy(45,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);
    }
}

   |
32 |     if e is Const
   |             ^^^^^

ex.dfy(32,12): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
36 |     else if e is Var
   |                  ^^^

ex.dfy(36,17): Error: Type or type parameter is not declared in this scope: Var (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
40 |     else if e is Add
   |                  ^^^

ex.dfy(40,17): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
43 |         assert OptimizePreservesSemantics(e.e1, env);
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(43,15): Error: expression is not allowed to invoke a lemma (OptimizePreservesSemantics)
   |
43 |         assert OptimizePreservesSemantics(e.e1, env);
   |                                          ^

ex.dfy(43,41): Error: lemma call is not allowed to be used in an expression context (OptimizePreservesSemantics)
   |
44 |         assert OptimizePreservesSemantics(e.e2, env);
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(44,15): Error: expression is not allowed to invoke a lemma (OptimizePreservesSemantics)
   |
44 |         assert OptimizePreservesSemantics(e.e2, env);
   |                                          ^

ex.dfy(44,41): Error: lemma call is not allowed to be used in an expression context (OptimizePreservesSemantics)
   |
32 |     if e is Const
   |          ^^

ex.dfy(32,9): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
   |
36 |     else if e is Var
   |               ^^

ex.dfy(36,14): Error: type test for type 'Var' must be from an expression assignable to it (got 'Expr')
   |
40 |     else if e is Add
   |               ^^

ex.dfy(40,14): Error: type test for type 'Add' must be from an expression assignable to it (got 'Expr')
10 resolution/type errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);
    }
    // No-op case: everything else

   |
46 |     // No-op case: everything else
   |                                   ^

ex.dfy(46,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);
    }
    // No other cases possible

   |
46 |     // No other cases possible
   |                               ^

ex.dfy(46,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '    // No-op case: everything else\n', '    // No other cases possible\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions
datatype Expr = 
    | Const(n: int)
    | Var(name: string)
    | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int
{
    match e
    case Const(n) => n
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
}

// Optimizer
function optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
}

// Lemma
lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    requires true
    ensures evaluate(e, env) == evaluate(optimize(e), env)
{
    // Base case: Const
    if e is Const
    {
    }
    // Base case: Var
    else if e is Var
    {
    }
    // Inductive case: Add
    else if e is Add
    {
        // Recursive calls
        assert OptimizePreservesSemantics(e.e1, env);
        assert OptimizePreservesSemantics(e.e2, env);
    }
    // No other cases possible
}

   |
32 |     if e is Const
   |             ^^^^^

ex.dfy(32,12): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
36 |     else if e is Var
   |                  ^^^

ex.dfy(36,17): Error: Type or type parameter is not declared in this scope: Var (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
40 |     else if e is Add
   |                  ^^^

ex.dfy(40,17): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
43 |         assert OptimizePreservesSemantics(e.e1, env);
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(43,15): Error: expression is not allowed to invoke a lemma (OptimizePreservesSemantics)
   |
43 |         assert OptimizePreservesSemantics(e.e1, env);
   |                                          ^

ex.dfy(43,41): Error: lemma call is not allowed to be used in an expression context (OptimizePreservesSemantics)
   |
44 |         assert OptimizePreservesSemantics(e.e2, env);
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(44,15): Error: expression is not allowed to invoke a lemma (OptimizePreservesSemantics)
   |
44 |         assert OptimizePreservesSemantics(e.e2, env);
   |                                          ^

ex.dfy(44,41): Error: lemma call is not allowed to be used in an expression context (OptimizePreservesSemantics)
   |
32 |     if e is Const
   |          ^^

ex.dfy(32,9): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
   |
36 |     else if e is Var
   |               ^^

ex.dfy(36,14): Error: type test for type 'Var' must be from an expression assignable to it (got 'Expr')
   |
40 |     else if e is Add
   |               ^^

ex.dfy(40,14): Error: type test for type 'Add' must be from an expression assignable to it (got 'Expr')
10 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 43
number of gen nodes: 22 (including leaves: 3)
number of back nodes: 21 (including leaves: 19)

expansion count: 29 (including failed: 8)

cache stats {'hit': 290, 'miss': 130}
calls to generate 84
Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(v: int)\n', '// ADT for arithmetic expressions\n', 'datatype Expr = Const(val: int)\n', '// ADT for arithmetic expressions\n', 'datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
              | Var(name: string)

SCORE
1.0
['             | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  |                                                         ^

ex.dfy(5,56): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int {

  |
5 | function Evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(5,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int {\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e

  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(v) => v

  |
7 |     case Const(v) => v
  |                       ^

ex.dfy(7,22): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v\n', '    case Const(v) => v\n', '    case Const(v) => v\n', '    case Const(v) => v\n', '    case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(v) => v
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(v) => v
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

  |
9 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
  |                                                          ^

ex.dfy(9,57): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(v) => v
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                           ^

ex.dfy(5,74): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int {\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int {\n', 'function method Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '  match e\n', '  match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v

  |
8 |   case Const(v) => v
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)

   |
10 |   case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
   |                                                                ^

ex.dfy(10,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):

   |
13 | lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
   |                                                                     ^

ex.dfy(13,68): Error: this symbol not expected in MethodSpec
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimizeLemma(e: Expr, env: string -> int, optimized: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):\n', 'lemma EvaluateOptimizeLemma(e: Expr, env: string -> int, optimized: Expr)\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
  Evaluate(e, env) == Evaluate(optimized, env)

   |
13 | lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
   |                                                                     ^

ex.dfy(13,68): Error: this symbol not expected in MethodSpec
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
  Evaluate(optimized, env) == Evaluate(e, env)

   |
13 | lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
   |                                                                     ^

ex.dfy(13,68): Error: this symbol not expected in MethodSpec
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
  Evaluate(optimized, env) == Evaluate(Optimize(e), env)

   |
13 | lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
   |                                                                     ^

ex.dfy(13,68): Error: this symbol not expected in MethodSpec
1 parse errors detected in ex.dfy

SCORE
None
['  Evaluate(e, env) == Evaluate(optimized, env)\n', '  Evaluate(e, env) == Evaluate(optimized, env)\n', '  Evaluate(optimized, env) == Evaluate(e, env)\n', '  Evaluate(optimized, env) == Evaluate(Optimize(e), env)\n', '  Evaluate(optimized, env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
  Evaluate(e, env) == Evaluate(optimized, env)
{

   |
13 | lemma EvaluateOptimize(e: Expr, env: string -> int, optimized: Expr):
   |                                                                     ^

ex.dfy(13,68): Error: this symbol not expected in MethodSpec
   |
15 | {
   |  ^

ex.dfy(15,1): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['{\n', '{\n', '{\n', '{\n', '{\n']
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)

   |
16 |   case Add(Const(0), rhs) => Optimize(rhs)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>

   |
16 |   case Add(lhs, rhs) =>
   |                        ^

ex.dfy(16,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |   case Add(lhs, Const(0)) => Optimize(lhs)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), rhs) => Optimize(rhs)\n', '  case Add(lhs, rhs) =>\n', '  case Add(lhs, rhs) =>\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(Const(0), rhs) => Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var newLhs := Optimize(lhs);

   |
17 |     var newLhs := Optimize(lhs);
   |                                 ^

ex.dfy(17,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);

   |
17 |     var lhs_opt := Optimize(lhs);
   |                                  ^

ex.dfy(17,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var newLhs := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);

   |
18 |     var rhs_opt := Optimize(rhs);
   |                                  ^

ex.dfy(18,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var rhs_opt := Optimize(rhs);\n', '    var rhs_opt := Optimize(rhs);\n', '    var rhs_opt := Optimize(rhs);\n', '    var rhs_opt := Optimize(rhs);\n', '    var rhs_opt := Optimize(rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt is Const(0) then rhs_opt

   |
19 |     if lhs_opt is Const(0) then rhs_opt
   |                        ^

ex.dfy(19,23): Error: then expected
   |
19 |     if lhs_opt is Const(0) then rhs_opt
   |                            ^

ex.dfy(19,27): Error: else expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt

   |
19 |     if lhs_opt == Const(0) then rhs_opt
   |                                        ^

ex.dfy(19,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else

   |
19 |     if lhs_opt == Const(0) then rhs_opt else
   |                                             ^

ex.dfy(19,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if lhs_opt is Const(0) then rhs_opt\n', '    if lhs_opt == Const(0) then rhs_opt\n', '    if lhs_opt == Const(0) then rhs_opt\n', '    if lhs_opt == Const(0) then rhs_opt\n', '    if lhs_opt == Const(0) then rhs_opt else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else

   |
20 |     if rhs_opt == Const(0) then lhs_opt else
   |                                             ^

ex.dfy(20,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if rhs_opt == Const(0) then lhs_opt else\n', '    if rhs_opt == Const(0) then lhs_opt else\n', '    if rhs_opt == Const(0) then lhs_opt else\n', '    if rhs_opt == Const(0) then lhs_opt else\n', '    if rhs_opt == Const(0) then lhs_opt else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)

   |
21 |     Add(lhs_opt, rhs_opt)
   |                          ^

ex.dfy(21,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
      Add(lhs_opt, rhs_opt)

   |
21 |       Add(lhs_opt, rhs_opt)
   |                            ^

ex.dfy(21,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Add(lhs_opt, rhs_opt)\n', '    Add(lhs_opt, rhs_opt)\n', '    Add(lhs_opt, rhs_opt)\n', '      Add(lhs_opt, rhs_opt)\n', '      Add(lhs_opt, rhs_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e

   |
22 |   case _ => e
   |              ^

ex.dfy(22,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
28 |   match e
   |          ^

ex.dfy(28,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case

   |
28 |   // base case
   |               ^

ex.dfy(28,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases

   |
28 |   // Base cases
   |                ^

ex.dfy(28,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  // base case\n', '  // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {

   |
29 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(29,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {

   |
29 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(29,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(_) || e == Var(_) {\n', '  if e == Const(0) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else if e == Add(_, _) {

   |
30 |   } else if e == Add(_, _) {
   |                             ^

ex.dfy(30,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {

   |
30 |   } else {
   |           ^

ex.dfy(30,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Add(_, _) {\n', '  } else {\n', '  } else {\n', '  } else {\n', '  } else {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case

   |
31 |     // Recursive case
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    assert e == Add(_, _);

   |
31 |     assert e == Add(_, _);
   |                           ^

ex.dfy(31,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case\n', '    assert e == Add(_, _);\n', '    // Recursive case\n', '    assert e == Add(_, _);\n', '    // Recursive case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    match e

   |
32 |     match e
   |            ^

ex.dfy(32,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);

   |
32 |     assert e == Add(_, _);
   |                           ^

ex.dfy(32,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    assert e == Add(_, _);\n', '    match e\n', '    match e\n', '    assert e == Add(_, _);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := Optimize(e.lhs);

   |
33 |     var lhs := Optimize(e.lhs);
   |                                ^

ex.dfy(33,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;

   |
33 |     var lhs := (e as Add).lhs;
   |                               ^

ex.dfy(33,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := e.lhs;

   |
33 |     var lhs := e.lhs;
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var lhs := Optimize(e.lhs);\n', '    var lhs := (e as Add).lhs;\n', '    var lhs := e.lhs;\n', '    var lhs := e.lhs;\n', '    var lhs := e.lhs;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;

   |
34 |     var rhs := (e as Add).rhs;
   |                               ^

ex.dfy(34,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var rhs := (e as Add).rhs;\n', '    var rhs := (e as Add).rhs;\n', '    var rhs := (e as Add).rhs;\n', '    var rhs := (e as Add).rhs;\n', '    var rhs := (e as Add).rhs;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;
    OptimizerPreservesSemantics(lhs, env);

   |
35 |     OptimizerPreservesSemantics(lhs, env);
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;
    var lhs_opt := Optimize(lhs);

   |
35 |     var lhs_opt := Optimize(lhs);
   |                                  ^

ex.dfy(35,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(lhs, env);\n', '    var lhs_opt := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    OptimizerPreservesSemantics(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);

   |
36 |     OptimizerPreservesSemantics(rhs, env);
   |                                           ^

ex.dfy(36,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);
  }

   |
37 |   }
   |    ^

ex.dfy(37,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {
  } else {
    // Recursive case
    assert e == Add(_, _);
    var lhs := (e as Add).lhs;
    var rhs := (e as Add).rhs;
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);
  }
}

   |
29 |   if e == Const(0) || e == Var(_) {
   |                                ^

ex.dfy(29,31): Error: unresolved identifier: _
   |
32 |     assert e == Add(_, _);
   |                     ^

ex.dfy(32,20): Error: unresolved identifier: _
   |
32 |     assert e == Add(_, _);
   |                        ^

ex.dfy(32,23): Error: unresolved identifier: _
   |
33 |     var lhs := (e as Add).lhs;
   |                      ^^^

ex.dfy(33,21): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
33 |     var lhs := (e as Add).lhs;
   |                           ^^^

ex.dfy(33,26): Error: type of the receiver is not fully determined at this program point
   |
34 |     var rhs := (e as Add).rhs;
   |                      ^^^

ex.dfy(34,21): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
34 |     var rhs := (e as Add).rhs;
   |                           ^^^

ex.dfy(34,26): Error: type of the receiver is not fully determined at this program point
7 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case

   |
28 |   // Base case
   |               ^

ex.dfy(28,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.

   |
28 |   // Base case: If e is a constant or a variable, the claim is trivially true.
   |                                                                               ^

ex.dfy(28,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case\n', '  // Base case\n', '  // Base case: If e is a constant or a variable, the claim is trivially true.\n', '  match e\n', '  // Base cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e == Const(?v) || e == Var(?name) {

   |
29 |   if e == Const(?v) || e == Var(?name) {
   |                                         ^

ex.dfy(29,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e == Const(0) || e == Var(_)

   |
29 |   if e == Const(0) || e == Var(_)
   |                                  ^

ex.dfy(29,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e == Const(0) || e == Var(?)

   |
29 |   if e == Const(0) || e == Var(?)
   |                                  ^

ex.dfy(29,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

   |
29 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(29,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(?v) || e == Var(?name) {\n', '  if e == Const(0) || e == Var(_)\n', '  if e == Const(0) || e == Var(?)\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}


   |
29 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(29,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}
  // Inductive case: e is an addition.

   |
30 |   // Inductive case: e is an addition.
   |                                       ^

ex.dfy(30,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}
  else if e is Add // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.

   |
30 |   else if e is Add // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.
   |                                                                                                                ^

ex.dfy(30,111): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}
  // Inductive case: If e is an addition, recursively prove the claim for the sub-expressions.

   |
30 |   // Inductive case: If e is an addition, recursively prove the claim for the sub-expressions.
   |                                                                                               ^

ex.dfy(30,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '  // Inductive case: e is an addition.\n', '  else if e is Add // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.\n', '\n', '  // Inductive case: If e is an addition, recursively prove the claim for the sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, recursively call the lemma on the sub-expressions.

   |
31 |   // Inductive case: If e is an addition, recursively call the lemma on the sub-expressions.
   |                                                                                             ^

ex.dfy(31,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we recursively prove the claim for the sub-expressions.

   |
31 |   // Inductive case: If e is an addition, we recursively prove the claim for the sub-expressions.
   |                                                                                                  ^

ex.dfy(31,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.

   |
31 |   // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
   |                                                                                              ^

ex.dfy(31,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.

   |
31 |   // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.
   |                                                                                               ^

ex.dfy(31,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, recursively prove the claim for lhs and rhs.

   |
31 |   // Inductive case: If e is an addition, recursively prove the claim for lhs and rhs.
   |                                                                                       ^

ex.dfy(31,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If e is an addition, recursively call the lemma on the sub-expressions.\n', '  // Inductive case: If e is an addition, we recursively prove the claim for the sub-expressions.\n', '  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.\n', '  // Inductive case: If e is an addition, recursively prove the claim for its sub-expressions.\n', '  // Inductive case: If e is an addition, recursively prove the claim for lhs and rhs.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  else

   |
32 |   else
   |       ^

ex.dfy(32,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add

   |
32 |   if e is Add
   |              ^

ex.dfy(32,13): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  else if e is Add

   |
32 |   else if e is Add
   |                   ^

ex.dfy(32,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  if e is Add\n', '  else if e is Add\n', '  else if e is Add\n', '  if e is Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {

   |
33 |   {
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    var lhs := e.lhs;

   |
34 |     var lhs := e.lhs;
   |                      ^

ex.dfy(34,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.

   |
34 |     // Optimize the sub-expressions.
   |                                     ^

ex.dfy(34,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var lhs := e.lhs;\n', '    var lhs := e.lhs;\n', '    var lhs := e.lhs;\n', '    // Optimize the sub-expressions.\n', '    var lhs := e.lhs;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);

   |
35 |     var lhs_opt := Optimize(e.lhs);
   |                                    ^

ex.dfy(35,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var lhs_opt := Optimize(e.lhs);\n', '    var lhs_opt := Optimize(e.lhs);\n', '    var lhs_opt := Optimize(e.lhs);\n', '    var lhs_opt := Optimize(e.lhs);\n', '    var lhs_opt := Optimize(e.lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

   |
36 |     var rhs_opt := Optimize(e.rhs);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var rhs_opt := Optimize(e.rhs);\n', '    var rhs_opt := Optimize(e.rhs);\n', '    var rhs_opt := Optimize(e.rhs);\n', '    var rhs_opt := Optimize(e.rhs);\n', '    var rhs_opt := Optimize(e.rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);


   |
36 |     var rhs_opt := Optimize(e.rhs);
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Recursively prove the claim for the sub-expressions.

   |
38 |     // Recursively prove the claim for the sub-expressions.
   |                                                            ^

ex.dfy(38,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Recursively invoke the lemma for the sub-expressions.

   |
38 |     // Recursively invoke the lemma for the sub-expressions.
   |                                                             ^

ex.dfy(38,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions.

   |
38 |     // Prove the claim for the sub-expressions.
   |                                                ^

ex.dfy(38,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.

   |
38 |     // Prove the claim for the sub-expressions by induction.
   |                                                             ^

ex.dfy(38,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively prove the claim for the sub-expressions.\n', '    // Recursively invoke the lemma for the sub-expressions.\n', '    // Prove the claim for the sub-expressions.\n', '    // Prove the claim for the sub-expressions by induction.\n', '    // Recursively invoke the lemma for the sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemanticsLhs(lhs_opt: Expr)

   |
39 |     lemma OptimizerPreservesSemanticsLhs(lhs_opt: Expr)
   |     ^

ex.dfy(39,4): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemanticsLhs(env: string -> int)

   |
39 |     lemma OptimizerPreservesSemanticsLhs(env: string -> int)
   |     ^

ex.dfy(39,4): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    OptimizerPreservesSemantics(e.lhs, env);

   |
39 |     OptimizerPreservesSemantics(e.lhs, env);
   |                                             ^

ex.dfy(39,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
2 parse errors detected in ex.dfy

SCORE
None
['    lemma OptimizerPreservesSemanticsLhs(lhs_opt: Expr)\n', '    lemma OptimizerPreservesSemanticsLhs(env: string -> int)\n', '    OptimizerPreservesSemantics(e.lhs, env);\n', '    lemma OptimizerPreservesSemantics(e.lhs, env);\n', '    lemma OptimizerPreservesSemanticsLhs(env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
None
['    lemma OptimizerPreservesSemantics(e.rhs, env);\n', '    lemma OptimizerPreservesSemantics(e.rhs, env);\n', '    lemma OptimizerPreservesSemantics(e.rhs, env);\n', '    lemma OptimizerPreservesSemantics(e.rhs, env);\n', '    lemma OptimizerPreservesSemantics(e.rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);


   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);

    // Use the induction hypotheses to prove the claim for e.

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);

    // Now we need to prove the claim for the addition itself.

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);

    // The claim follows from the induction hypotheses.

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the claim is trivially true.
  if e is Const || e is Var {}

  // Inductive case: If e is an addition, we need to prove the claim for its sub-expressions.
  if e is Add
  {
    // Optimize the sub-expressions.
    var lhs_opt := Optimize(e.lhs);
    var rhs_opt := Optimize(e.rhs);

    // Prove the claim for the sub-expressions by induction.
    lemma OptimizerPreservesSemantics(e.lhs, env);
    lemma OptimizerPreservesSemantics(e.rhs, env);

    // Use the induction hypotheses to prove the claim for the addition.

   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |     ^

ex.dfy(39,4): Error: rbrace expected
   |
39 |     lemma OptimizerPreservesSemantics(e.lhs, env);
   |                                        ^

ex.dfy(39,39): Error: colon expected
   |
40 |     lemma OptimizerPreservesSemantics(e.rhs, env);
   |                                        ^

ex.dfy(40,39): Error: colon expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    // Use the induction hypotheses to prove the claim for e.\n', '    // Now we need to prove the claim for the addition itself.\n', '    // The claim follows from the induction hypotheses.\n', '    // Use the induction hypotheses to prove the claim for the addition.\n', '    // Use the induction hypotheses to prove the claim for the addition.\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
28 |   match e
   |          ^

ex.dfy(28,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant

   |
28 |   // Base case: e is a constant
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: If e is a constant or variable, the optimization doesn't change anything.

   |
28 |   // Base case: If e is a constant or variable, the optimization doesn't change anything.
   |                                                                                          ^

ex.dfy(28,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  // Base case: e is a constant\n', '  match e\n', "  // Base case: If e is a constant or variable, the optimization doesn't change anything.\n", '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e == Const(0) {

   |
29 |   if e == Const(0) {
   |                     ^

ex.dfy(29,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e == Const(_) {

   |
29 |   if e == Const(_) {
   |                     ^

ex.dfy(29,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const

   |
29 |   if e is Const
   |                ^

ex.dfy(29,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) {\n', '  if e == Const(_) {\n', '  if e == Const(_) {\n', '  if e is Const\n', '  if e == Const(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {

   |
30 |   {
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable

   |
32 |   // Base case: e is a variable
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: e is a variable\n', '  // Base case: e is a variable\n', '  // Base case: e is a variable\n', '  // Base case: e is a variable\n', '  // Base case: e is a variable\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var

   |
33 |   else if e is Var
   |                   ^

ex.dfy(33,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e is Var\n', '  else if e is Var\n', '  else if e is Var\n', '  else if e is Var\n', '  else if e is Var\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {

   |
34 |   {
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }

   |
35 |   }
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }
  // Inductive case: e is an addition

   |
36 |   // Inductive case: e is an addition
   |                                      ^

ex.dfy(36,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: e is an addition\n', '  // Inductive case: e is an addition\n', '  // Inductive case: e is an addition\n', '  // Inductive case: e is an addition\n', '  // Inductive case: e is an addition\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }
  // Inductive case: e is an addition
  else if e is Add

   |
37 |   else if e is Add
   |                   ^

ex.dfy(37,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }
  // Inductive case: e is an addition
  else if e is Add(lhs, rhs)

   |
37 |   else if e is Add(lhs, rhs)
   |                   ^

ex.dfy(37,18): Error: lbrace expected
   |
37 |   else if e is Add(lhs, rhs)
   |                             ^

ex.dfy(37,28): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['  else if e is Add\n', '  else if e is Add\n', '  else if e is Add\n', '  else if e is Add\n', '  else if e is Add(lhs, rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }
  // Inductive case: e is an addition
  else if e is Add(lhs, rhs)
  {

   |
37 |   else if e is Add(lhs, rhs)
   |                   ^

ex.dfy(37,18): Error: lbrace expected
   |
38 |   {
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |   else if e is Add(lhs, rhs)
   |                   ^

ex.dfy(37,18): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);
    var rhs_opt := Optimize(rhs);
    if lhs_opt == Const(0) then rhs_opt else
    if rhs_opt == Const(0) then lhs_opt else
    Add(lhs_opt, rhs_opt)
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: e is a constant
  if e is Const
  {
  }
  // Base case: e is a variable
  else if e is Var
  {
  }
  // Inductive case: e is an addition
  else if e is Add(lhs, rhs)
  {
    OptimizerPreservesSemantics(lhs, env);

   |
37 |   else if e is Add(lhs, rhs)
   |                   ^

ex.dfy(37,18): Error: lbrace expected
   |
38 |   {
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |   else if e is Add(lhs, rhs)
   |                   ^

ex.dfy(37,18): Error: missing semicolon at end of statement
   |
39 |     OptimizerPreservesSemantics(lhs, env);
   |                                           ^

ex.dfy(39,42): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
-1.0
['    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 27
number of gen nodes: 14 (including leaves: 2)
number of back nodes: 13 (including leaves: 12)

expansion count: 18 (including failed: 5)

cache stats {'hit': 250, 'miss': 135}
calls to generate 77
Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// The abstract data type for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = Const(val: int)\n', 'datatype Expr = Const(v: int)\n', 'datatype Expr = Const(n: int)\n', '// The abstract data type for arithmetic expressions\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n', '              | Var(name: string)\n', '             | Var(name: string)\n', '             | Var(name: string)\n', '             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                         ^

ex.dfy(5,40): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  |                                                  ^

ex.dfy(5,49): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function(string) returns(int)): int

  |
5 | function method Evaluate(e: Expr, env: function(string) returns(int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function(string) returns(int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  |                                                         ^

ex.dfy(5,56): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: func (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: function(string) returns(int)): int\n', 'function Eval(e: Expr, env: string -> int): int {\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e

  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(val) => val

  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

  |
9 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
  |                                                          ^

ex.dfy(9,57): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function method Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '  match e\n', '  match e\n', '    match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val

  |
8 |   case Const(val) => val
  |                         ^

ex.dfy(8,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
9 |   case Var(name) => env(name)
  |                              ^

ex.dfy(9,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)

   |
10 |   case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
   |                                                                ^

ex.dfy(10,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n', '  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |   case Add(lhs, Const(0)) => Optimize(lhs)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>

   |
16 |   case Add(lhs, rhs) =>
   |                        ^

ex.dfy(16,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), rhs) => Optimize(rhs)

   |
16 |   case Add(Const(0), rhs) => Optimize(rhs)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(lhs, rhs) =>\n', '  case Add(lhs, Const(0)) => Optimize(lhs)\n', '  case Add(Const(0), rhs) => Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var lhs_opt := Optimize(lhs);

   |
17 |     var lhs_opt := Optimize(lhs);
   |                                  ^

ex.dfy(17,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var new_lhs := Optimize(lhs);

   |
17 |     var new_lhs := Optimize(lhs);
   |                                  ^

ex.dfy(17,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else

   |
17 |     if lhs == Const(0) then Optimize(rhs) else
   |                                               ^

ex.dfy(17,46): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    var l := Optimize(lhs);

   |
17 |     var l := Optimize(lhs);
   |                            ^

ex.dfy(17,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    var lhs_opt := Optimize(lhs);\n', '    var new_lhs := Optimize(lhs);\n', '    var lhs_opt := Optimize(lhs);\n', '    if lhs == Const(0) then Optimize(rhs) else\n', '    var l := Optimize(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else

   |
18 |     if rhs == Const(0) then Optimize(lhs) else
   |                                               ^

ex.dfy(18,46): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if rhs == Const(0) then Optimize(lhs) else\n', '    if rhs == Const(0) then Optimize(lhs) else\n', '    if rhs == Const(0) then Optimize(lhs) else\n', '    if rhs == Const(0) then Optimize(lhs) else\n', '    if rhs == Const(0) then Optimize(lhs) else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))

   |
19 |     Add(Optimize(lhs), Optimize(rhs))
   |                                      ^

ex.dfy(19,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Add(Optimize(lhs), Optimize(rhs))\n', '    Add(Optimize(lhs), Optimize(rhs))\n', '    Add(Optimize(lhs), Optimize(rhs))\n', '    Add(Optimize(lhs), Optimize(rhs))\n', '    Add(Optimize(lhs), Optimize(rhs))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e is Const then

   |
26 |   if e is Const then
   |                 ^

ex.dfy(26,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var

   |
26 |   // Base case: Const or Var
   |                             ^

ex.dfy(26,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
26 |   match e
   |          ^

ex.dfy(26,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the lemma holds trivially

   |
26 |   // Base case: if e is a constant or a variable, the lemma holds trivially
   |                                                                            ^

ex.dfy(26,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Const then\n', '  // Base case: Const or Var\n', '  match e\n', '  match e\n', '  // Base case: if e is a constant or a variable, the lemma holds trivially\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)

   |
27 |   if e == Const(0) || e == Var(0)
   |                                  ^

ex.dfy(27,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e is Const || e is Var {

   |
27 |   if e is Const || e is Var {
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(_) || e == Var(_) {

   |
27 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(_) {

   |
27 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(0)\n', '  match e\n', '  if e is Const || e is Var {\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(0) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {

   |
28 |   {
   |    ^

ex.dfy(28,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    assert Evaluate(e, env) == Evaluate(Optimize(e), env);

   |
29 |     assert Evaluate(e, env) == Evaluate(Optimize(e), env);
   |                                                           ^

ex.dfy(29,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Since Const(0) and Var(0) are not Add, the premise does not hold.

   |
29 |     // Since Const(0) and Var(0) are not Add, the premise does not hold.
   |                                                                         ^

ex.dfy(29,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize

   |
29 |     // Nothing to optimize
   |                           ^

ex.dfy(29,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Evaluate(e, env) == Evaluate(Optimize(e), env);\n', '    // Since Const(0) and Var(0) are not Add, the premise does not hold.\n', '  }\n', '    // Nothing to optimize\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else if e == Add(lhs, rhs)

   |
31 |   else if e == Add(lhs, rhs)
   |                             ^

ex.dfy(31,28): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else

   |
31 |   else
   |       ^

ex.dfy(31,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(lhs, rhs)\n', '  else\n', '  else\n', '  else\n', '  else if e == Add(lhs, rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {

   |
32 |   {
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive case: Add

   |
33 |     // Inductive case: Add
   |                           ^

ex.dfy(33,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Recursive case: Add

   |
33 |     // Recursive case: Add
   |                           ^

ex.dfy(33,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add

   |
33 |     // Inductive step: Add
   |                           ^

ex.dfy(33,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: Add\n', '    // Recursive case: Add\n', '    // Inductive step: Add\n', '    // Inductive case: Add\n', '    // Recursive case: Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    assert e == Add(lhs, rhs);

   |
34 |     assert e == Add(lhs, rhs);
   |                               ^

ex.dfy(34,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    match e

   |
34 |     match e
   |            ^

ex.dfy(34,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(lhs, rhs);\n', '    match e\n', '    match e\n', '    assert e == Add(lhs, rhs);\n', '    assert e == Add(lhs, rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    assert e == Add(lhs, rhs);
    OptimizerPreservesSemantics(lhs, env);

   |
35 |     OptimizerPreservesSemantics(lhs, env);
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n', '    OptimizerPreservesSemantics(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    assert e == Add(lhs, rhs);
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);

   |
36 |     OptimizerPreservesSemantics(rhs, env);
   |                                           ^

ex.dfy(36,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n', '    OptimizerPreservesSemantics(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    assert e == Add(lhs, rhs);
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);
  }

   |
37 |   }
   |    ^

ex.dfy(37,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: Const or Var
  if e == Const(0) || e == Var(0)
  {
    // Nothing to optimize
  }
  else
  {
    // Inductive step: Add
    assert e == Add(lhs, rhs);
    OptimizerPreservesSemantics(lhs, env);
    OptimizerPreservesSemantics(rhs, env);
  }
}

   |
34 |     assert e == Add(lhs, rhs);
   |                     ^^^

ex.dfy(34,20): Error: unresolved identifier: lhs
   |
34 |     assert e == Add(lhs, rhs);
   |                          ^^^

ex.dfy(34,25): Error: unresolved identifier: rhs
   |
35 |     OptimizerPreservesSemantics(lhs, env);
   |                                 ^^^

ex.dfy(35,32): Error: unresolved identifier: lhs
   |
36 |     OptimizerPreservesSemantics(rhs, env);
   |                                 ^^^

ex.dfy(36,32): Error: unresolved identifier: rhs
   |
27 |   if e == Const(0) || e == Var(0)
   |                            ^^^

ex.dfy(27,27): Error: incorrect argument type for datatype constructor parameter 'name' (expected string, found int)
5 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases

   |
26 |   // Base cases
   |                ^

ex.dfy(26,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  // Base cases\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(_) {

   |
27 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) then

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {

   |
27 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(27,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) {

   |
27 |   if e == Const(0) {
   |                     ^

ex.dfy(27,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(_) {\n', '  if e == Const(0) then\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(0) {\n', '  if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) then
  else if e == Var(_) then

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) then
  {

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) then
    assert Evaluate(e, env) == 0;

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Var(_) then\n', '  {\n', '  {\n', '    assert Evaluate(e, env) == 0;\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) then
    assert Evaluate(e, env) == 0;
    assert Evaluate(Optimize(e), env) == 0;

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Evaluate(Optimize(e), env) == 0;\n', '    assert Evaluate(Optimize(e), env) == 0;\n', '    assert Evaluate(Optimize(e), env) == 0;\n', '    assert Evaluate(Optimize(e), env) == 0;\n', '    assert Evaluate(Optimize(e), env) == 0;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '{\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  assert Evaluate(Optimize(e), env) == Evaluate(e, env)

   |
25 |   assert Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                                                        ^

ex.dfy(25,55): Error: invalid AssertStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  assert Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)
}

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
{
  Evaluate(Optimize(e), env) == Evaluate(e, env)
}
```

   |
25 |   Evaluate(Optimize(e), env) == Evaluate(e, env)
   |                              ^

ex.dfy(25,29): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case

   |
26 |   // Base case
   |               ^

ex.dfy(26,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
26 |   match e
   |          ^

ex.dfy(26,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case

   |
26 |   // base case
   |               ^

ex.dfy(26,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case\n', '  match e\n', '  match e\n', '  // base case\n', '  // Base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {

   |
27 |   if e == Const(0) {
   |                     ^

ex.dfy(27,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) then

   |
27 |   if e == Const(0) then
   |                    ^

ex.dfy(27,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) {\n', '  if e == Const(0) {\n', '  if e == Const(0) {\n', '  if e == Const(0) {\n', '  if e == Const(0) then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else

   |
28 |   } else
   |         ^

ex.dfy(28,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
    assert Evaluate(Optimize(e), env) == Evaluate(Const(0), env);

   |
28 |     assert Evaluate(Optimize(e), env) == Evaluate(Const(0), env);
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {

   |
28 |   } else if e == Var(0) {
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(_) {

   |
28 |   } else if e == Var(_) {
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else\n', '    assert Evaluate(Optimize(e), env) == Evaluate(Const(0), env);\n', '  } else if e == Var(0) {\n', '  } else\n', '  } else if e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else

   |
29 |   } else
   |         ^

ex.dfy(29,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(0, 0) {

   |
29 |   } else if e == Add(0, 0) {
   |                             ^

ex.dfy(29,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), Const(0)) {

   |
29 |   } else if e == Add(Const(0), Const(0)) {
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {

   |
29 |   } else if e == Add(Const(0), _) {
   |                                    ^

ex.dfy(29,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else\n', '  } else if e == Add(0, 0) {\n', '  } else if e == Add(Const(0), Const(0)) {\n', '  } else if e == Add(Const(0), _) {\n', '  } else if e == Add(Const(0), Const(0)) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {

   |
30 |   } else if e == Add(_, Const(0)) {
   |                                    ^

ex.dfy(30,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
    assert Optimize(Add(Const(0), _)) == _;

   |
30 |     assert Optimize(Add(Const(0), _)) == _;
   |                                            ^

ex.dfy(30,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
    assert Optimize(e) == Optimize(Add(Const(0), _));

   |
30 |     assert Optimize(e) == Optimize(Add(Const(0), _));
   |                                                      ^

ex.dfy(30,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else if e == Add(_, Const(0)) {\n', '    assert Optimize(Add(Const(0), _)) == _;\n', '  } else if e == Add(_, Const(0)) {\n', '    assert Optimize(e) == Optimize(Add(Const(0), _));\n', '  } else if e == Add(_, Const(0)) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {

   |
31 |   } else {
   |           ^

ex.dfy(31,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else if e == Add(Add(_, _), _) {

   |
31 |   } else if e == Add(Add(_, _), _) {
   |                                     ^

ex.dfy(31,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n', '  } else {\n', '  } else {\n', '  } else {\n', '  } else if e == Add(Add(_, _), _) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive case

   |
32 |     // recursive case
   |                      ^

ex.dfy(32,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step

   |
32 |     // recursive step
   |                      ^

ex.dfy(32,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // recursive case\n', '    // recursive case\n', '    // recursive step\n', '    // recursive step\n', '    // recursive case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    OptimizePreservesEvaluate(e.lhs, env);

   |
33 |     OptimizePreservesEvaluate(e.lhs, env);
   |                                           ^

ex.dfy(33,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e

   |
33 |     match e
   |            ^

ex.dfy(33,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    assert e == Add(?lhs, ?rhs);

   |
33 |     assert e == Add(?lhs, ?rhs);
   |                                 ^

ex.dfy(33,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesEvaluate(e.lhs, env);\n', '    OptimizePreservesEvaluate(e.lhs, env);\n', '    match e\n', '    assert e == Add(?lhs, ?rhs);\n', '    assert e == Add(?lhs, ?rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) {

   |
34 |     case Add(lhs, rhs) {
   |                        ^

ex.dfy(34,23): Error: darrow expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>

   |
34 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(34,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) {\n', '    case Add(lhs, rhs) =>\n', '    case Add(lhs, rhs) {\n', '    case Add(lhs, rhs) {\n', '    case Add(lhs, rhs) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);

   |
35 |       assert Optimize(lhs) != Const(0);
   |                                        ^

ex.dfy(35,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      OptimizePreservesEvaluate(lhs, env);

   |
35 |       OptimizePreservesEvaluate(lhs, env);
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) == lhs && Optimize(rhs) == rhs;

   |
35 |       assert Optimize(lhs) == lhs && Optimize(rhs) == rhs;
   |                                                           ^

ex.dfy(35,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Optimize(lhs) != Const(0);\n', '      OptimizePreservesEvaluate(lhs, env);\n', '      OptimizePreservesEvaluate(lhs, env);\n', '      OptimizePreservesEvaluate(lhs, env);\n', '      assert Optimize(lhs) == lhs && Optimize(rhs) == rhs;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);
      assert Optimize(rhs) != Const(0);

   |
36 |       assert Optimize(rhs) != Const(0);
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert Optimize(rhs) != Const(0);\n', '      assert Optimize(rhs) != Const(0);\n', '      assert Optimize(rhs) != Const(0);\n', '      assert Optimize(rhs) != Const(0);\n', '      assert Optimize(rhs) != Const(0);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);
      assert Optimize(rhs) != Const(0);
      OptimizePreservesEvaluate(lhs, env);

   |
37 |       OptimizePreservesEvaluate(lhs, env);
   |                                           ^

ex.dfy(37,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);
      assert Optimize(rhs) != Const(0);
      lemma OptimizePreservesEvaluate(lhs, env);

   |
37 |       lemma OptimizePreservesEvaluate(lhs, env);
   |       ^

ex.dfy(37,6): Error: this symbol not expected in CaseStmt
   |
37 |       lemma OptimizePreservesEvaluate(lhs, env);
   |                                                 ^

ex.dfy(37,48): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesEvaluate(lhs, env);\n', '      lemma OptimizePreservesEvaluate(lhs, env);\n', '      OptimizePreservesEvaluate(lhs, env);\n', '      OptimizePreservesEvaluate(lhs, env);\n', '      lemma OptimizePreservesEvaluate(lhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);
      assert Optimize(rhs) != Const(0);
      lemma OptimizePreservesEvaluate(lhs, env);
      lemma OptimizePreservesEvaluate(rhs, env);

   |
37 |       lemma OptimizePreservesEvaluate(lhs, env);
   |       ^

ex.dfy(37,6): Error: this symbol not expected in CaseStmt
   |
38 |       lemma OptimizePreservesEvaluate(rhs, env);
   |       ^

ex.dfy(38,6): Error: this symbol not expected in CaseStmt
   |
38 |       lemma OptimizePreservesEvaluate(rhs, env);
   |                                                 ^

ex.dfy(38,48): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['      lemma OptimizePreservesEvaluate(rhs, env);\n', '      lemma OptimizePreservesEvaluate(rhs, env);\n', '      lemma OptimizePreservesEvaluate(rhs, env);\n', '      lemma OptimizePreservesEvaluate(rhs, env);\n', '      lemma OptimizePreservesEvaluate(rhs, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // base case
  if e == Const(0) {
  } else if e == Var(0) {
  } else if e == Add(Const(0), _) {
  } else if e == Add(_, Const(0)) {
  } else {
    // recursive step
    match e
    case Add(lhs, rhs) =>
      assert Optimize(lhs) != Const(0);
      assert Optimize(rhs) != Const(0);
      lemma OptimizePreservesEvaluate(lhs, env);
      lemma OptimizePreservesEvaluate(rhs, env);
  }

   |
37 |       lemma OptimizePreservesEvaluate(lhs, env);
   |       ^

ex.dfy(37,6): Error: this symbol not expected in CaseStmt
   |
38 |       lemma OptimizePreservesEvaluate(rhs, env);
   |       ^

ex.dfy(38,6): Error: this symbol not expected in CaseStmt
   |
39 |   }
   |    ^

ex.dfy(39,3): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var

   |
26 |   // Base cases: Const and Var
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  // Base case\n', '  // Base cases: Const and Var\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)

   |
27 |   // Case: Add(lhs, rhs)
   |                         ^

ex.dfy(27,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  if e is Const || e is Var {}

   |
27 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(27,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  if e is Const || e is Var {

   |
27 |   if e is Const || e is Var {
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(Const(0), _)

   |
27 |   // Case: Add(Const(0), _)
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  if e is Const then

   |
27 |   if e is Const then
   |                 ^

ex.dfy(27,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Case: Add(lhs, rhs)\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n', '  // Case: Add(Const(0), _)\n', '  if e is Const then\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  // Case: Optimize(Add(lhs, rhs)) with lhs or rhs is Const(0)

   |
28 |   // Case: Optimize(Add(lhs, rhs)) with lhs or rhs is Const(0)
   |                                                               ^

ex.dfy(28,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)

   |
28 |   //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  // Recursive calls

   |
28 |   // Recursive calls
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   Case: lhs is Const(0)

   |
28 |   //   Case: lhs is Const(0)
   |                             ^

ex.dfy(28,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Case: Optimize(Add(lhs, rhs)) with lhs or rhs is Const(0)\n', '  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)\n', '}\n', '  // Recursive calls\n', '  //   Case: lhs is Const(0)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)

   |
29 |   //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
   |                                                                  ^

ex.dfy(29,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)\n', '  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)\n', '  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)\n', '  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)\n', '  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
  //   If neither is 0, then recursively call lemma on lhs and rhs

   |
30 |   //   If neither is 0, then recursively call lemma on lhs and rhs
   |                                                                   ^

ex.dfy(30,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
  //   Otherwise, recursively call lemma for lhs and rhs

   |
30 |   //   Otherwise, recursively call lemma for lhs and rhs
   |                                                         ^

ex.dfy(30,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
  //   Otherwise, recursively call lemma on lhs and rhs

   |
30 |   //   Otherwise, recursively call lemma on lhs and rhs
   |                                                        ^

ex.dfy(30,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
  //   In all other cases, recursively call lemma on lhs and rhs

   |
30 |   //   In all other cases, recursively call lemma on lhs and rhs
   |                                                                 ^

ex.dfy(30,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If neither is 0, then recursively call lemma on lhs and rhs\n', '  //   Otherwise, recursively call lemma for lhs and rhs\n', '  //   Otherwise, recursively call lemma on lhs and rhs\n', '  //   Otherwise, recursively call lemma on lhs and rhs\n', '  //   In all other cases, recursively call lemma on lhs and rhs\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Evaluate(lhs, env) + Evaluate(rhs, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(lhs, rhs) =>
    if lhs == Const(0) then Optimize(rhs) else
    if rhs == Const(0) then Optimize(lhs) else
    Add(Optimize(lhs), Optimize(rhs))
  case _ => e
}

lemma OptimizePreservesEvaluate(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases: Const and Var
  // Case: Add(lhs, rhs)
  //   If lhs is 0, then Optimize(rhs) is the same as Optimize(e)
  //   If rhs is 0, then Optimize(lhs) is the same as Optimize(e)
  //   Otherwise, recursively call lemma for lhs and rhs
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 31
number of gen nodes: 16 (including leaves: 2)
number of back nodes: 15 (including leaves: 14)

expansion count: 20 (including failed: 5)

cache stats {'hit': 238, 'miss': 147}
calls to generate 77
Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n', 'datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '             | Var(name: string)\n', '              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(lhs: Expr, rhs: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func(string) returns(int)): int

  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                        ^

ex.dfy(5,39): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                                 ^

ex.dfy(5,48): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
['function method Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: func(string) returns(int)): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func(string) returns(int)): int
{

  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                        ^

ex.dfy(5,39): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                                 ^

ex.dfy(5,48): Error: this symbol not expected in FunctionSpec
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func(string) returns(int)): int
{
  match e

  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                        ^

ex.dfy(5,39): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                                 ^

ex.dfy(5,48): Error: this symbol not expected in FunctionSpec
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func(string) returns(int)): int
{
    match e

  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                        ^

ex.dfy(5,39): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  |                                                 ^

ex.dfy(5,48): Error: this symbol not expected in FunctionSpec
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: func(string) returns(int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n', '  match e\n', '  match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function method (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                                    ^

ex.dfy(5,51): Error: invalid NoUSIdentOrDigits
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^^^^^^^^

ex.dfy(5,35): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: function method (string) returns (int)): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: function (string) returns (int)): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{
  match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int
{
    match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n', '    match e\n', '    match e\n', '    match e\n', '  match e\n']
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  |                                                         ^

ex.dfy(5,56): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int {\n', 'function method Eval(e: Expr, env: string -> int): int {\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e

  |
6 |   match e
  |          ^

ex.dfy(6,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
    match e

  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '    match e\n', '  match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val

  |
7 |   case Const(val) => val
  |                         ^

ex.dfy(7,24): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)

  |
8 |   case Var(name) => env(name)
  |                              ^

ex.dfy(8,29): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

  |
9 |   case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
  |                                                        ^

ex.dfy(9,55): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int {
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Evaluate(e: Expr, env: function (string) returns (int)): int

  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                        ^

ex.dfy(5,39): Error: invalid TypeAndToken
  |
5 | function method Evaluate(e: Expr, env: function (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                           ^

ex.dfy(5,74): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: function (string) returns (int)): int\n', 'function method Eval(e: Expr, env: function (string) returns (int)): int {\n', 'function method Evaluate(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '  requires forall x, y :: env(x) == env(y) <==> x == y\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{
  match e
  case Const(val) => val

  |
9 |   case Const(val) => val
  |                         ^

ex.dfy(9,24): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n', '  case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{
  match e
  case Const(val) => val
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
11 |   case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                        ^

ex.dfy(11,55): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: string -> int): int
  requires forall x, y :: env(x) == env(y) <==> x == y
{
  match e
  case Const(val) => val
  case Var(name) => env(name)
  case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(lhs: Expr, rhs: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: string -> int): int

  |
5 | function method Eval(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                    ^

ex.dfy(5,67): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Evaluate(e: Expr, env: string -> int): int

  |
5 | function method Evaluate(e: Expr, env: string -> int): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
1 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: function (string) returns (int)): int {\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Evaluate(e: Expr, env: string -> int): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {
    match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
6 |     match e
  |            ^

ex.dfy(6,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {
  match e

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
6 |   match e
  |          ^

ex.dfy(6,9): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '  match e\n', '    match e\n', '    match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {
    match e
    case Const(val) => val

  |
5 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(5,28): Error: invalid TypeAndToken
  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function method (string) returns (int)): int

  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                                    ^

ex.dfy(5,51): Error: invalid NoUSIdentOrDigits
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^^^^^^^^

ex.dfy(5,35): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
['function method Evaluate(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: function method (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function method (string) returns (int)): int
{

  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                                    ^

ex.dfy(5,51): Error: invalid NoUSIdentOrDigits
  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^^^^^^^^

ex.dfy(5,35): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
5 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function method (string) returns (int)): int
{
  match e

  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                                    ^

ex.dfy(5,51): Error: invalid NoUSIdentOrDigits
  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^^^^^^^^

ex.dfy(5,35): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
5 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

function method Eval(e: Expr, env: function method (string) returns (int)): int
{
    match e

  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^

ex.dfy(5,35): Error: invalid TypeAndToken
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                                    ^

ex.dfy(5,51): Error: invalid NoUSIdentOrDigits
  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
  |
5 | function method Eval(e: Expr, env: function method (string) returns (int)): int
  |                                    ^^^^^^^^

ex.dfy(5,35): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
5 parse errors detected in ex.dfy

SCORE
-1.0
['  match e\n', '  match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function method Eval(e: Expr, env: func (string) returns (int)): int {

  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                         ^

ex.dfy(5,40): Error: closeparen expected
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                                  ^

ex.dfy(5,49): Error: this symbol not expected in FunctionSpec
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  |                                                                       ^

ex.dfy(5,70): Error: invalid UnaryExpression
  |
5 | function method Eval(e: Expr, env: func (string) returns (int)): int {
  | ^^^^^^^^

ex.dfy(5,0): Error: the phrase 'function method' is not allowed when using --function-syntax:4; to declare a compiled function, use just 'function'
4 parse errors detected in ex.dfy

SCORE
None
['function method Eval(e: Expr, env: string -> int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: func (string) returns (int)): int {\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function method Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e

  |
7 |     match e
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '  match e\n', '    match e\n', '    match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val

  |
8 |     case Const(val) => val
  |                           ^

ex.dfy(8,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n', '    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)

  |
9 |     case Var(name) => env(name)
  |                                ^

ex.dfy(9,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n', '    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)

   |
10 |     case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
   |                                                          ^

ex.dfy(10,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n', '    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e

   |
15 |     match e
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(Const(0), rhs) => Optimize(rhs)

   |
16 |     case Add(Const(0), rhs) => Optimize(rhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, Const(0)) => Optimize(lhs)

   |
16 |     case Add(lhs, Const(0)) => Optimize(lhs)
   |                                             ^

ex.dfy(16,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>

   |
16 |     case Add(lhs, rhs) =>
   |                          ^

ex.dfy(16,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), rhs) => Optimize(rhs)\n', '    case Add(lhs, Const(0)) => Optimize(lhs)\n', '    case Add(lhs, rhs) =>\n', '    case Add(lhs, Const(0)) => Optimize(lhs)\n', '    case Add(Const(0), rhs) => Optimize(rhs)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var l := Optimize(lhs);

   |
17 |         var l := Optimize(lhs);
   |                                ^

ex.dfy(17,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);

   |
17 |         var lhs_opt := Optimize(lhs);
   |                                      ^

ex.dfy(17,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var l := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        var l := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n', '        var lhs_opt := Optimize(lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);

   |
18 |         var rhs_opt := Optimize(rhs);
   |                                      ^

ex.dfy(18,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n', '        var rhs_opt := Optimize(rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt

   |
19 |         if lhs_opt == Const(0) then rhs_opt
   |                                            ^

ex.dfy(19,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt is Const(0) then rhs_opt

   |
19 |         if lhs_opt is Const(0) then rhs_opt
   |                            ^

ex.dfy(19,27): Error: then expected
   |
19 |         if lhs_opt is Const(0) then rhs_opt
   |                                ^

ex.dfy(19,31): Error: else expected
2 parse errors detected in ex.dfy

SCORE
None
['        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt is Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n', '        if lhs_opt == Const(0) then rhs_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt

   |
20 |         else if rhs_opt == Const(0) then lhs_opt
   |                                                 ^

ex.dfy(20,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n', '        else if rhs_opt == Const(0) then lhs_opt\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)

   |
21 |         else Add(lhs_opt, rhs_opt)
   |                                   ^

ex.dfy(21,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n', '        else Add(lhs_opt, rhs_opt)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e

   |
22 |     case _ => e
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
    ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'requires true\n', 'requires true\n', '    ensures Eval(Optimize(e), env) == Eval(e, env)\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases

   |
29 |     // Base cases
   |                  ^

ex.dfy(29,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base case: If e is a constant or a variable, the result is trivially true.

   |
29 |     // Base case: If e is a constant or a variable, the result is trivially true.
   |                                                                                  ^

ex.dfy(29,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    if e == Const(_) || e == Var(_) {

   |
29 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(29,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base cases\n', '    match e\n', '    // Base case: If e is a constant or a variable, the result is trivially true.\n', '    if e == Const(_) || e == Var(_) {\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(_) || e == Var(_) {

   |
30 |     if e == Const(_) || e == Var(_) {
   |                                      ^

ex.dfy(30,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) {

   |
30 |     if e == Const(0) || e == Var(_) {
   |                                      ^

ex.dfy(30,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) then

   |
30 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(30,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) {

   |
30 |     if e == Const(0) {
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(_) || e == Var(_) {\n', '    if e == Const(0) || e == Var(_) {\n', '    if e == Const(0) || e == Var(_) then\n', '    if e == Const(0) {\n', '    if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) then
        assert Eval(Optimize(e), env) == Eval(e, env);

   |
30 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(30,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) then
        // nothing to prove

   |
30 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(30,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(Optimize(e), env) == Eval(e, env);\n', '        assert Eval(Optimize(e), env) == Eval(e, env);\n', '        assert Eval(Optimize(e), env) == Eval(e, env);\n', '        assert Eval(Optimize(e), env) == Eval(e, env);\n', '        // nothing to prove\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) then
        // nothing to prove
    else

   |
30 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(30,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // Base cases
    if e == Const(0) || e == Var(_) then
        // nothing to prove
    else 

   |
30 |     if e == Const(0) || e == Var(_) then
   |                                     ^

ex.dfy(30,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n', '    else \n', '    else \n', '    else\n', '    else\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true

   |
29 |     // base case: if e is a constant or variable, the result is trivially true
   |                                                                               ^

ex.dfy(29,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    match e\n', '    match e\n', '    match e\n', '    // base case: if e is a constant or variable, the result is trivially true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e == Const(?val) || e == Var(?name) {

   |
30 |     if e == Const(?val) || e == Var(?name) {
   |                                             ^

ex.dfy(30,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e == Const(0) || e == Var(?)

   |
30 |     if e == Const(0) || e == Var(?)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}

   |
30 |     if e is Const || e is Var {}
   |                                 ^

ex.dfy(30,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(?val) || e == Var(?name) {\n', '    if e == Const(0) || e == Var(?)\n', '    if e == Const(?val) || e == Var(?name) {\n', '    if e is Const || e is Var {}\n', '    if e == Const(?val) || e == Var(?name) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: e is an addition

   |
31 |     // inductive case: e is an addition
   |                                        ^

ex.dfy(31,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    else if e is Add {

   |
31 |     else if e is Add {
   |                       ^

ex.dfy(31,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, recursively apply the lemma to the sub-expressions

   |
31 |     // inductive case: if e is an addition, recursively apply the lemma to the sub-expressions
   |                                                                                               ^

ex.dfy(31,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version

   |
31 |     // inductive case: if e is an addition, we need to show that the optimized version
   |                                                                                       ^

ex.dfy(31,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    else if e is Add

   |
31 |     else if e is Add
   |                     ^

ex.dfy(31,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // inductive case: e is an addition\n', '    else if e is Add {\n', '    // inductive case: if e is an addition, recursively apply the lemma to the sub-expressions\n', '    // inductive case: if e is an addition, we need to show that the optimized version\n', '    else if e is Add\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // still evaluates to the same value as the original expression

   |
32 |     // still evaluates to the same value as the original expression
   |                                                                    ^

ex.dfy(32,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // still evaluates to the same result

   |
32 |     // still evaluates to the same result
   |                                          ^

ex.dfy(32,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.

   |
32 |     // preserves the semantics.
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // still evaluates to the same value as the original expression\n', '    // still evaluates to the same value as the original expression\n', '    // still evaluates to the same result\n', '    // preserves the semantics.\n', '    // still evaluates to the same value as the original expression\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add {

   |
33 |     else if e is Add {
   |                       ^

ex.dfy(33,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add

   |
33 |     else if e is Add
   |                     ^

ex.dfy(33,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if e is Add {\n', '    else if e is Add\n', '    else if e is Add {\n', '    else if e is Add\n', '    else if e is Add {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
    {

   |
34 |     {
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions

   |
34 |         // we recursively optimize the sub-expressions
   |                                                       ^

ex.dfy(34,54): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // recursively invoke the lemma on the sub-expressions

   |
34 |         // recursively invoke the lemma on the sub-expressions
   |                                                               ^

ex.dfy(34,62): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '        // we recursively optimize the sub-expressions\n', '        // recursively invoke the lemma on the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
35 |         var lhs_opt := Optimize(e.lhs);
   |                                        ^

ex.dfy(35,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n', '        var lhs_opt := Optimize(e.lhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
36 |         var rhs_opt := Optimize(e.rhs);
   |                                        ^

ex.dfy(36,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n', '        var rhs_opt := Optimize(e.rhs);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // we need to show that the optimized addition preserves the semantics

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
37 |         // we need to show that the optimized addition preserves the semantics
   |                                                                               ^

ex.dfy(37,78): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // then we recursively prove the lemma for these sub-expressions

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
37 |         // then we recursively prove the lemma for these sub-expressions
   |                                                                         ^

ex.dfy(37,72): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // we then recursively prove the lemma for the sub-expressions

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
37 |         // we then recursively prove the lemma for the sub-expressions
   |                                                                       ^

ex.dfy(37,70): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // we show that the optimized version preserves the semantics

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
37 |         // we show that the optimized version preserves the semantics
   |                                                                      ^

ex.dfy(37,69): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(Optimize(e), env) == Eval(e, env)
{
    // base case: if e is a constant or variable, the result is trivially true
    if e is Const || e is Var {}
    // inductive case: if e is an addition, we need to show that the optimized version
    // preserves the semantics.
    else if e is Add
        // we recursively optimize the sub-expressions
        var lhs_opt := Optimize(e.lhs);
        var rhs_opt := Optimize(e.rhs);
        // we recursively invoke the lemma on the sub-expressions

   |
35 |         var lhs_opt := Optimize(e.lhs);
   |         ^

ex.dfy(35,8): Error: lbrace expected
   |
37 |         // we recursively invoke the lemma on the sub-expressions
   |                                                                  ^

ex.dfy(37,65): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        // we need to show that the optimized addition preserves the semantics\n', '        // then we recursively prove the lemma for these sub-expressions\n', '        // we then recursively prove the lemma for the sub-expressions\n', '        // we show that the optimized version preserves the semantics\n', '        // we recursively invoke the lemma on the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)

SCORE
1.0
['ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n', 'ensures Eval(Optimize(e), env) == Eval(e, env)\n', 'ensures Eval(e, env) == Eval(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    if e == Const(0) {

   |
29 |     if e == Const(0) {
   |                       ^

ex.dfy(29,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base cases

   |
29 |     // Base cases
   |                  ^

ex.dfy(29,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result

   |
29 |     // Base case: if e is a constant or a variable, the optimization doesn't change the result
   |                                                                                               ^

ex.dfy(29,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    if e == Const(0) || e == Var(_) {

   |
29 |     if e == Const(0) || e == Var(_) {
   |                                      ^

ex.dfy(29,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    match e

   |
29 |     match e
   |            ^

ex.dfy(29,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(0) {\n', '    // Base cases\n', "    // Base case: if e is a constant or a variable, the optimization doesn't change the result\n", '    if e == Const(0) || e == Var(_) {\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(?val) || e == Var(?name)

   |
30 |     if e == Const(?val) || e == Var(?name)
   |                                           ^

ex.dfy(30,42): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)

   |
30 |     if e == Const(0) || e == Var(_)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(0)

   |
30 |     if e == Const(0) || e == Var(0)
   |                                    ^

ex.dfy(30,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e is Const || e is Var {}

   |
30 |     if e is Const || e is Var {}
   |                                 ^

ex.dfy(30,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if e == Const(?val) || e == Var(?name)\n', '    if e == Const(0) || e == Var(_)\n', '    if e == Const(0) || e == Var(0)\n', '    if e is Const || e is Var {}\n', '    if e == Const(0) || e == Var(0)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {

   |
31 |     {
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
        assert Eval(e, env) == Eval(Optimize(e), env);

   |
32 |         assert Eval(e, env) == Eval(Optimize(e), env);
   |                                                       ^

ex.dfy(32,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
        // nothing to prove

   |
32 |         // nothing to prove
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Eval(e, env) == Eval(Optimize(e), env);\n', '    }\n', '    }\n', '    }\n', '        // nothing to prove\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else

   |
33 |     else
   |         ^

ex.dfy(33,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else if e == Add(Const(0), _)

   |
33 |     else if e == Add(Const(0), _)
   |                                  ^

ex.dfy(33,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else if e == Add(_, _)

   |
33 |     else if e == Add(_, _)
   |                           ^

ex.dfy(33,26): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else if e == Add(Const(0), _)\n', '    else if e == Add(_, _)\n', '    else if e == Add(_, _)\n', '    else if e == Add(_, _)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {

   |
34 |     {
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions

   |
35 |         // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions
   |                                                                                                    ^

ex.dfy(35,99): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: if e is an addition, optimize its sub-expressions and then check the lemma recursively

   |
35 |         // Recursive case: if e is an addition, optimize its sub-expressions and then check the lemma recursively
   |                                                                                                                  ^

ex.dfy(35,113): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition

   |
35 |         // Recursive case: e is an addition
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Inductive case: e is an addition, so we recursively prove the lemma for its sub-expressions

   |
35 |         // Inductive case: e is an addition, so we recursively prove the lemma for its sub-expressions
   |                                                                                                       ^

ex.dfy(35,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions\n', '        // Recursive case: if e is an addition, optimize its sub-expressions and then check the lemma recursively\n', '        // Recursive case: e is an addition\n', '        // Inductive case: e is an addition, so we recursively prove the lemma for its sub-expressions\n', '        // Recursive case: e is an addition\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _);

   |
36 |         assert e == Add(_, _);
   |                               ^

ex.dfy(36,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        // We need to show that the optimized sub-expressions also preserve the semantics

   |
36 |         // We need to show that the optimized sub-expressions also preserve the semantics
   |                                                                                          ^

ex.dfy(36,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _)

   |
36 |         assert e == Add(_, _)
   |                              ^

ex.dfy(36,29): Error: invalid AssertStmt
1 parse errors detected in ex.dfy

SCORE
None
['        assert e == Add(_, _);\n', '        assert e == Add(_, _);\n', '        // We need to show that the optimized sub-expressions also preserve the semantics\n', '        assert e == Add(_, _);\n', '        assert e == Add(_, _)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _)
        var lhs := e.lhs;

   |
36 |         assert e == Add(_, _)
   |                             ^

ex.dfy(36,28): Error: expected either 'by' or a semicolon following the assert expression
   |
37 |         var lhs := e.lhs;
   |                          ^

ex.dfy(37,25): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _)
        var lhs := Add(_, _).lhs;

   |
36 |         assert e == Add(_, _)
   |                             ^

ex.dfy(36,28): Error: expected either 'by' or a semicolon following the assert expression
   |
37 |         var lhs := Add(_, _).lhs;
   |                                  ^

ex.dfy(37,33): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _)
        var lhs := (e as Add).lhs;

   |
36 |         assert e == Add(_, _)
   |                             ^

ex.dfy(36,28): Error: expected either 'by' or a semicolon following the assert expression
   |
37 |         var lhs := (e as Add).lhs;
   |                                   ^

ex.dfy(37,34): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        var lhs := e.lhs;\n', '        var lhs := e.lhs;\n', '        var lhs := Add(_, _).lhs;\n', '        var lhs := (e as Add).lhs;\n', '        var lhs := e.lhs;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(lhs: Expr, rhs: Expr)

function Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(val) => val
    case Var(name) => env(name)
    case Add(lhs, rhs) => Eval(lhs, env) + Eval(rhs, env)
}

function Optimize(e: Expr): Expr
{
    match e
    case Add(lhs, rhs) =>
        var lhs_opt := Optimize(lhs);
        var rhs_opt := Optimize(rhs);
        if lhs_opt == Const(0) then rhs_opt
        else if rhs_opt == Const(0) then lhs_opt
        else Add(lhs_opt, rhs_opt)
    case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Eval(e, env) == Eval(Optimize(e), env)
{
    // Base case: if e is a constant or a variable, the optimization doesn't change the result
    if e == Const(0) || e == Var(_)
    {
    }
    else
    {
        // Recursive case: e is an addition
        assert e == Add(_, _)
        var lhs := e.lhs;
        var rhs := e.rhs;

   |
36 |         assert e == Add(_, _)
   |                             ^

ex.dfy(36,28): Error: expected either 'by' or a semicolon following the assert expression
   |
38 |         var rhs := e.rhs;
   |                          ^

ex.dfy(38,25): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        var rhs := e.rhs;\n', '        var rhs := e.rhs;\n', '        var rhs := e.rhs;\n', '        var rhs := e.rhs;\n', '        var rhs := e.rhs;\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 4)
number of back nodes: 17 (including leaves: 14)

expansion count: 26 (including failed: 9)

cache stats {'hit': 266, 'miss': 149}
calls to generate 83
Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// ADT for arithmetic expressions

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
// Arithmetic expressions ADT

SCORE
1.0
['datatype Expr =\n', '// ADT for arithmetic expressions\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr =\n', '// Arithmetic expressions ADT\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
    Const(val: int)

SCORE
1.0
['  | Const(i: int)\n', '  | Const(v: int)\n', '  | Const(val: int)\n', '  | Const(val: int)\n', '    Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(n: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(n: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string => int): int

  |
6 | function Evaluate(e: Expr, env: string => int): int
  |                                        ^

ex.dfy(6,39): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: function (string) returns (int)): int

  |
6 | function Evaluate(e: Expr, env: function (string) returns (int)): int
  |                                 ^

ex.dfy(6,32): Error: invalid TypeAndToken
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: string => int): int\n', 'function Eval(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: string => int): int\n', 'function Evaluate(e: Expr, env: string -> int): int\n', 'function Evaluate(e: Expr, env: function (string) returns (int)): int\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  reads env\n', '  reads env\n', '  reads env\n', '  reads env\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
  decreases e

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  decreases e\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{
  match e

  |
9 |   match e
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(v) => v

   |
10 |   case Const(v) => v
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(v) => v
  case Var(name) => env(name)

   |
11 |   case Var(name) => env(name)
   |                              ^

ex.dfy(11,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
12 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(12,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
  reads env
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

  |
7 |   reads env
  |         ^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got string -> int)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '  reads env\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e

  |
8 |   match e
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v

  |
9 |   case Const(v) => v
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n', '  case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)

   |
10 |   case Var(name) => env(name)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n', '  case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

   |
11 |   case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
   |                                                            ^

ex.dfy(11,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n', '  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr

SCORE
1.0
['function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n', 'function Optimize(e: Expr): Expr\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e

   |
16 |   match e
   |          ^

ex.dfy(16,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)

   |
17 |   case Add(Const(0), e2) => Optimize(e2)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => e2

   |
17 |   case Add(Const(0), e2) => e2
   |                               ^

ex.dfy(17,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => e2\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n', '  case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)

   |
18 |   case Add(e1, Const(0)) => Optimize(e1)
   |                                         ^

ex.dfy(18,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n', '  case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
19 |   case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                      ^

ex.dfy(19,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n', '  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e

   |
20 |   case _ => e
   |              ^

ex.dfy(20,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n', 'lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'requires true\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', '  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  if e is Const || e is Var {

   |
27 |   if e is Const || e is Var {
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.

   |
27 |   // Base case: if e is a constant or a variable, the result is trivial.
   |                                                                         ^

ex.dfy(27,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases

   |
27 |   // Base cases
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  if e is Const || e is Var {\n', '  // Base case: if e is a constant or a variable, the result is trivial.\n', '  // Base cases\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) || e == Var(?name)

   |
28 |   if e == Const(0) || e == Var(?name)
   |                                      ^

ex.dfy(28,37): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_) {

   |
28 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)

   |
28 |   if e == Const(_) || e == Var(_)
   |                                  ^

ex.dfy(28,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(0) {

   |
28 |   if e == Const(0) {
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(?name)\n', '  if e == Const(_) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_)\n', '  if e == Const(0) {\n', '  if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {

   |
29 |   {
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else if e == Add(_, _)

   |
31 |   else if e == Add(_, _)
   |                         ^

ex.dfy(31,24): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else if e == Add(Const(0), _)

   |
31 |   else if e == Add(Const(0), _)
   |                                ^

ex.dfy(31,31): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else

   |
31 |   else
   |       ^

ex.dfy(31,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(_, _)\n', '  else if e == Add(_, _)\n', '  else if e == Add(Const(0), _)\n', '  else if e == Add(Const(0), _)\n', '  else\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {

   |
32 |   {
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    // Recursive cases

   |
33 |     // Recursive cases
   |                       ^

ex.dfy(33,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);

   |
33 |     assert e == Add(_, _);
   |                           ^

ex.dfy(33,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    // Inductive cases

   |
33 |     // Inductive cases
   |                       ^

ex.dfy(33,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive cases\n', '    // Recursive cases\n', '    assert e == Add(_, _);\n', '    // Inductive cases\n', '    // Recursive cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    var e1 := (match e { case Add(x, _) => x });

   |
34 |     var e1 := (match e { case Add(x, _) => x });
   |                                                 ^

ex.dfy(34,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    var e1 := (match e { case Add(e1, _) => e1 });

   |
34 |     var e1 := (match e { case Add(e1, _) => e1 });
   |                                                   ^

ex.dfy(34,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    var e1, e2 := match e { case Add(e1, e2) => (e1, e2) };

   |
34 |     var e1, e2 := match e { case Add(e1, e2) => (e1, e2) };
   |                                                            ^

ex.dfy(34,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls

   |
34 |     // Recursive calls
   |                       ^

ex.dfy(34,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var e1 := (match e { case Add(x, _) => x });\n', '    var e1 := (match e { case Add(e1, _) => e1 });\n', '    var e1, e2 := match e { case Add(e1, e2) => (e1, e2) };\n', '    var e1 := (match e { case Add(x, _) => x });\n', '    // Recursive calls\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls
    OptimizePreservesSemantics(e.e1, env);

   |
35 |     OptimizePreservesSemantics(e.e1, env);
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls
    OptimizePreservesSemantics(/* first sub-expression */, env);

   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                          ^

ex.dfy(35,57): Error: closeparen expected
   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                               ^

ex.dfy(35,62): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls
    OptimizePreservesSemantics(match e { case Add(e1, _) => e1 }, env);

   |
35 |     OptimizePreservesSemantics(match e { case Add(e1, _) => e1 }, env);
   |                                                                        ^

ex.dfy(35,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e.e1, env);\n', '    OptimizePreservesSemantics(/* first sub-expression */, env);\n', '    OptimizePreservesSemantics(match e { case Add(e1, _) => e1 }, env);\n', '    OptimizePreservesSemantics(e.e1, env);\n', '    OptimizePreservesSemantics(match e { case Add(e1, _) => e1 }, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls
    OptimizePreservesSemantics(/* first sub-expression */, env);
    OptimizePreservesSemantics(/* second sub-expression */, env);

   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                          ^

ex.dfy(35,57): Error: closeparen expected
   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                               ^

ex.dfy(35,62): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(/* second sub-expression */, env);\n', '    OptimizePreservesSemantics(/* second sub-expression */, env);\n', '    OptimizePreservesSemantics(/* second sub-expression */, env);\n', '    OptimizePreservesSemantics(/* second sub-expression */, env);\n', '    OptimizePreservesSemantics(/* second sub-expression */, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base cases
  if e == Const(_) || e == Var(_)
  {
  }
  else
  {
    assert e == Add(_, _);
    // Recursive calls
    OptimizePreservesSemantics(/* first sub-expression */, env);
    OptimizePreservesSemantics(/* second sub-expression */, env);
  }

   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                          ^

ex.dfy(35,57): Error: closeparen expected
   |
35 |     OptimizePreservesSemantics(/* first sub-expression */, env);
   |                                                               ^

ex.dfy(35,62): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case

   |
27 |   // Base case
   |               ^

ex.dfy(27,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case\n', '  // Base cases\n', '  match e\n', '  match e\n', '  // Base case: if e is a constant or a variable, the result is trivial.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {

   |
28 |   if e is Const || e is Var {
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

   |
28 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(28,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Const || e is Var {\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.

   |
29 |   // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.
   |                                                                                             ^

ex.dfy(29,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}


   |
28 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(28,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, recursively prove the lemma.

   |
29 |   // Inductive case: if e is an addition, recursively prove the lemma.
   |                                                                       ^

ex.dfy(29,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}
  // Inductive case: if e is an addition, we recursively prove the lemma for its operands.

   |
29 |   // Inductive case: if e is an addition, we recursively prove the lemma for its operands.
   |                                                                                           ^

ex.dfy(29,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: if e is an addition, recursively call the lemma on the sub-expressions.\n', '\n', '\n', '  // Inductive case: if e is an addition, recursively prove the lemma.\n', '  // Inductive case: if e is an addition, we recursively prove the lemma for its operands.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma for the sub-expressions.

   |
30 |   // Inductive case: if e is an addition, recursively prove the lemma for the sub-expressions.
   |                                                                                               ^

ex.dfy(30,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.

   |
30 |   // Inductive case: if e is an addition, recursively prove the lemma.
   |                                                                       ^

ex.dfy(30,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions.

   |
30 |   // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions.
   |                                                                                               ^

ex.dfy(30,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: if e is an addition, recursively prove the lemma for the sub-expressions.\n', '  // Inductive case: if e is an addition, recursively prove the lemma.\n', '  // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions.\n', '  // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions.\n', '  // Inductive case: if e is an addition, recursively prove the lemma for its sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  if e is Add {

   |
31 |   if e is Add {
   |                ^

ex.dfy(31,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  if e is Add {}

   |
31 |   if e is Add {}
   |                 ^

ex.dfy(31,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add

   |
31 |   else if e is Add
   |                   ^

ex.dfy(31,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Add {\n', '  if e is Add {}\n', '  if e is Add {\n', '  else if e is Add\n', '  if e is Add {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {

   |
32 |   {
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    assert Optimize(e) is Add;

   |
33 |     assert Optimize(e) is Add;
   |                               ^

ex.dfy(33,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;

   |
33 |     var e1 := e.e1;
   |                    ^

ex.dfy(33,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    assert e == Add(e1, e2);

   |
33 |     assert e == Add(e1, e2);
   |                             ^

ex.dfy(33,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Optimize(e) is Add;\n', '    assert Optimize(e) is Add;\n', '    var e1 := e.e1;\n', '    assert Optimize(e) is Add;\n', '    assert e == Add(e1, e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;
    var e2 := e.e2;

   |
34 |     var e2 := e.e2;
   |                    ^

ex.dfy(34,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    var e2 := e.e2;\n', '    var e2 := e.e2;\n', '    var e2 := e.e2;\n', '    var e2 := e.e2;\n', '    var e2 := e.e2;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;
    var e2 := e.e2;
    OptimizePreservesSemantics(e1, env);

   |
35 |     OptimizePreservesSemantics(e1, env);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;
    var e2 := e.e2;
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);

   |
36 |     OptimizePreservesSemantics(e2, env);
   |                                         ^

ex.dfy(36,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;
    var e2 := e.e2;
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
  }

   |
37 |   }
   |    ^

ex.dfy(37,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  // Base case: if e is a constant or a variable, the result is trivial.
  if e is Const || e is Var {}

  // Inductive case: if e is an addition, recursively prove the lemma.
  else if e is Add
  {
    var e1 := e.e1;
    var e2 := e.e2;
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
  }
}

   |
28 |   if e is Const || e is Var {}
   |           ^^^^^

ex.dfy(28,10): Error: Type or type parameter is not declared in this scope: Const (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
28 |   if e is Const || e is Var {}
   |                         ^^^

ex.dfy(28,24): Error: Type or type parameter is not declared in this scope: Var (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
31 |   else if e is Add
   |                ^^^

ex.dfy(31,15): Error: Type or type parameter is not declared in this scope: Add (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
28 |   if e is Const || e is Var {}
   |        ^^

ex.dfy(28,7): Error: type test for type 'Const' must be from an expression assignable to it (got 'Expr')
   |
28 |   if e is Const || e is Var {}
   |                      ^^

ex.dfy(28,21): Error: type test for type 'Var' must be from an expression assignable to it (got 'Expr')
   |
31 |   else if e is Add
   |             ^^

ex.dfy(31,12): Error: type test for type 'Add' must be from an expression assignable to it (got 'Expr')
6 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n', 'ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n', 'ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e

   |
27 |   match e
   |          ^

ex.dfy(27,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially

   |
27 |   // Base case: If e is a constant or variable, the property holds trivially
   |                                                                             ^

ex.dfy(27,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases

   |
27 |   // Base cases
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  // Base case: If e is a constant or variable, the property holds trivially\n', '  // Base cases\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {}

   |
28 |   if e is Const || e is Var {}
   |                               ^

ex.dfy(28,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {

   |
28 |   if e is Const || e is Var {
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {\n', '  if e is Const || e is Var {}\n', '  if e is Const || e is Var {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {

   |
29 |   } else {
   |           ^

ex.dfy(29,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n', '  } else {\n', '  }\n', '  } else {\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively prove the property for its sub-expressions

   |
30 |     // Inductive case: If e is an addition, recursively prove the property for its sub-expressions
   |                                                                                                   ^

ex.dfy(30,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property

   |
30 |     // Inductive case: If e is an addition, recursively check the property
   |                                                                           ^

ex.dfy(30,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    assert e is Add;

   |
30 |     assert e is Add;
   |                     ^

ex.dfy(30,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively prove the property for the sub-expressions

   |
30 |     // Inductive case: If e is an addition, recursively prove the property for the sub-expressions
   |                                                                                                   ^

ex.dfy(30,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: If e is an addition, recursively prove the property for its sub-expressions\n', '    // Inductive case: If e is an addition, recursively check the property\n', '    // Inductive case: If e is an addition, recursively prove the property for its sub-expressions\n', '    assert e is Add;\n', '    // Inductive case: If e is an addition, recursively prove the property for the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    match e

   |
31 |     match e
   |            ^

ex.dfy(31,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions e1 and e2

   |
31 |     // for the sub-expressions e1 and e2
   |                                         ^

ex.dfy(31,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions

   |
31 |     // for the sub-expressions
   |                               ^

ex.dfy(31,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e\n', '    // for the sub-expressions e1 and e2\n', '    match e\n', '    // for the sub-expressions\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions
    assert e is Add;

   |
32 |     assert e is Add;
   |                     ^

ex.dfy(32,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions
    match e

   |
32 |     match e
   |            ^

ex.dfy(32,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    assert e is Add;\n', '    assert e is Add;\n', '    match e\n', '    match e\n', '    match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions
    match e
    case Add(e1, e2) {

   |
33 |     case Add(e1, e2) {
   |                      ^

ex.dfy(33,21): Error: darrow expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) {\n', '    case Add(e1, e2) {\n', '    case Add(e1, e2) {\n', '    case Add(e1, e2) {\n', '    case Add(e1, e2) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions
    match e
    case Add(e1, e2) {
      OptimizePreservesSemantics(e1, env);

   |
33 |     case Add(e1, e2) {
   |                      ^

ex.dfy(33,21): Error: darrow expected
   |
34 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(34,42): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e1, env);\n', '      OptimizePreservesSemantics(e1, env);\n', '      OptimizePreservesSemantics(e1, env);\n', '      OptimizePreservesSemantics(e1, env);\n', '      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or variable, the property holds trivially
  if e is Const || e is Var {
  } else {
    // Inductive case: If e is an addition, recursively check the property
    // for the sub-expressions
    match e
    case Add(e1, e2) {
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);

   |
33 |     case Add(e1, e2) {
   |                      ^

ex.dfy(33,21): Error: darrow expected
   |
35 |       OptimizePreservesSemantics(e2, env);
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e2, env);\n', '      OptimizePreservesSemantics(e2, env);\n', '      OptimizePreservesSemantics(e2, env);\n', '      OptimizePreservesSemantics(e2, env);\n', '      OptimizePreservesSemantics(e2, env);\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for recursion

   |
27 |   // Base cases for recursion
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  if e is Const {}

   |
27 |   if e is Const {}
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction

   |
27 |   // Base cases for the induction
   |                                  ^

ex.dfy(27,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base case: If e is a constant or a variable, the property holds trivially

   |
27 |   // Base case: If e is a constant or a variable, the property holds trivially
   |                                                                               ^

ex.dfy(27,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n', '  // Base cases for recursion\n', '  if e is Const {}\n', '  // Base cases for the induction\n', '  // Base case: If e is a constant or a variable, the property holds trivially\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))

   |
28 |   if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
   |                                                                                            ^

ex.dfy(28,91): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(_)

   |
28 |   if e == Const(0) || e == Var(_)
   |                                  ^

ex.dfy(28,33): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e is Const || e is Var {

   |
28 |   if e is Const || e is Var {
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(_) {

   |
28 |   if e == Const(0) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(_) || e == Var(_) {

   |
28 |   if e == Const(_) || e == Var(_) {
   |                                    ^

ex.dfy(28,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))\n', '  if e == Const(0) || e == Var(_)\n', '  if e is Const || e is Var {\n', '  if e == Const(0) || e == Var(_) {\n', '  if e == Const(_) || e == Var(_) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {

   |
29 |   {
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else if e == Add(?e1, ?e2)

   |
31 |   else if e == Add(?e1, ?e2)
   |                             ^

ex.dfy(31,28): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else

   |
31 |   else
   |       ^

ex.dfy(31,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case

   |
31 |   else // Inductive case
   |                         ^

ex.dfy(31,24): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else if e == Add(?e1, ?e2)\n', '  else\n', '  else\n', '  else // Inductive case\n', '  else if e == Add(?e1, ?e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {

   |
32 |   {
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {
    assert e == Add(?e1, ?e2);

   |
33 |     assert e == Add(?e1, ?e2);
   |                               ^

ex.dfy(33,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n', '    assert e == Add(?e1, ?e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {
    assert e == Add(?e1, ?e2);
    OptimizePreservesSemantics(e1, env);

   |
34 |     OptimizePreservesSemantics(e1, env);
   |                                         ^

ex.dfy(34,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n', '    OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {
    assert e == Add(?e1, ?e2);
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);

   |
35 |     OptimizePreservesSemantics(e2, env);
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n', '    OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {
    assert e == Add(?e1, ?e2);
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
  }

   |
36 |   }
   |    ^

ex.dfy(36,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int
{
  match e
  case Const(v) => v
  case Var(name) => env(name)
  case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
}

function Optimize(e: Expr): Expr
{
  match e
  case Add(Const(0), e2) => Optimize(e2)
  case Add(e1, Const(0)) => Optimize(e1)
  case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
  case _ => e
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
requires true
ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Base cases for the induction
  if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
  {
  }
  else // Inductive case
  {
    assert e == Add(?e1, ?e2);
    OptimizePreservesSemantics(e1, env);
    OptimizePreservesSemantics(e2, env);
  }
}

   |
28 |   if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
   |                                ^^^^^

ex.dfy(28,31): Error: unresolved identifier: ?name
   |
28 |   if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
   |                                                             ^^^

ex.dfy(28,60): Error: unresolved identifier: ?e2
   |
28 |   if e == Const(0) || e == Var(?name) || e == Add(Const(0), ?e2) || e == Add(?e1, Const(0))
   |                                                                              ^^^

ex.dfy(28,77): Error: unresolved identifier: ?e1
   |
33 |     assert e == Add(?e1, ?e2);
   |                     ^^^

ex.dfy(33,20): Error: unresolved identifier: ?e1
   |
33 |     assert e == Add(?e1, ?e2);
   |                          ^^^

ex.dfy(33,25): Error: unresolved identifier: ?e2
   |
34 |     OptimizePreservesSemantics(e1, env);
   |                                ^^

ex.dfy(34,31): Error: unresolved identifier: e1
   |
35 |     OptimizePreservesSemantics(e2, env);
   |                                ^^

ex.dfy(35,31): Error: unresolved identifier: e2
7 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 2)
number of back nodes: 14 (including leaves: 13)

expansion count: 19 (including failed: 5)

cache stats {'hit': 264, 'miss': 136}
calls to generate 80
=====SUMMARY STATISTICS=====

Experiment: run_diversity.py for 10 trials

Trial times: [493.4660723209381, 481.78950667381287, 232.0740692615509, 383.5191524028778, 382.0195264816284, 362.890962600708, 370.6243360042572, 394.36851501464844, 393.15979194641113, 388.1078507900238]

Trial calls: [365, 460, 220, 305, 395, 420, 385, 385, 415, 400]


Time Statistics:

  Min: 232.07 sec, Max: 493.47 sec, Average: 388.20 sec, Standard Deviation: 67.30 sec

Call Statistics:

  Min: 220 calls, Max: 460 calls, Average: 375.00 calls, Standard Deviation: 64.11 calls

To complete all experiments, 71 minutes and 51 seconds elapsed.


